# 第 9 章攻击自动化

自动化工具使我们能够探索和利用比任何手动方法可能更多的漏洞。在我看来，没有什么能比得上由经验丰富的安全专家执行的手动安全测试和一组自动化部分。复杂的脚本可以在多个主机之间分割攻击，避免被列入黑名单。

本章涵盖的主题如下：

*   带 paramiko 的 SFTP 自动装置
*   Nmap 自动化
*   W3AFRESTAPI
*   使用 MSGRPC 编写 Metasploit 脚本
*   OWASP zap API
*   破解验证码
*   用 Python 访问 beefapi
*   用 Python 访问 Nessus6API

# 帕拉米科

通过 SSH 在远程系统中运行命令是自动化最常见的组件之一。Python 模块 paramiko 通过向 SSH 提供编程接口使这变得容易。Paramiko 为您提供了一种通过导入的库在 Python 中使用 SSH 函数的简单方法。这允许我们驱动 SSH 任务，通常您会手动执行这些任务。

## 与 paramiko 建立 SSH 连接

paramiko 的主要类是`paramiko.SSHClient`，它提供了一个启动服务器连接的基本接口：

![Establish SSH connection with paramiko](images/1-1.jpg)

这将创建一个新的 SSHClient 实例，然后我们调用连接到 SSH 服务器的`connect()`方法。

当我们使用任何 SSH 客户端连接到远程计算机时，该远程主机的密钥将自动存储在主目录中的`.ssh/known_hosts`文件中。因此，当我们第一次连接到远程系统时，我们将收到一条消息，如下所示：

![Establish SSH connection with paramiko](images/4323OS_09_01.jpg)

当您为此消息键入`yes`时，它将在`known_hosts`文件中添加一个条目。通过接受此消息，将为该主机添加一个信任级别。同样的规则也适用于帕拉米科。默认情况下，SSHClient 实例将拒绝连接没有在我们的`known_hosts`文件中保存密钥的主机。这将在创建自动化脚本时产生问题。我们可以设置主机密钥策略，使用 paramiko 自动添加缺少的主机密钥，如下所示：

```
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) 

```

现在，使用自动添加主机键连接到`ssh`的脚本如下：

![Establish SSH connection with paramiko](images/2-1.jpg)

## 使用 paramiko 运行命令

我们现在通过 paramiko 连接到远程主机。然后，我们可以使用此连接在远程主机上运行命令：

```
stdin, stdout, stderr = sshObj.exec_command('uptime') 
for line in stdout.readlines():

        print line.strip()

ssh.close()

```

响应数据将是元组（`stdin`、`stdout`、`stderr`），我们可以读取输出并写入输入。例如，如果我们正在运行一个需要输入的命令，我们可以使用`stdin`：

```
stdin, stdout, stderr = ssh.exec_command("sudo ls") 
stdin.write('password\n') 
stdin.flush() 
for line in stdout.readlines(): 
        print line.strip()

```

有了这个，我们可以创建一个交互式 shell，它可以自动化许多任务。

## 带 paramiko 的 SFTP

我们还可以使用 paramiko 在具有 SFTP 的远程主机上处理文件操作。

### 提示

**SFTP**代表**SSH 文件传输协议**或**安全文件传输协议**。它是一个独立的协议，其工作原理几乎与通过 SSH 的安全连接的 FTP 相同。

为此，我们首先像前面一样实例化一个新的`paramiko.SSHClient`实例：

![SFTP with paramiko](images/3.jpg)

然后在连接到远程主机后使用`open_sftp()`，将返回一个`paramiko.SFTPClient`客户端对象。`paramiko.SFTPClient`将支持所有 SFTP 操作。在这里，我们列出了远程服务器根目录中的文件。

我们可以使用`get()`方法下载，使用`put()`方法与 paramiko 上传文件。

要下载远程密码文件，请执行以下操作：

```
remotepath = '/etc/passwd' 
localpath = '/home/remote-passwd' 
sftp.get(remotepath, localpath)

```

要将文件上载到远程主机，请执行以下操作：

```
remotepath = '/home/some-image.jpg' 
localpath = '/home/some-image.jpg' 
sftp.put(localpath, remotepath) 

```

# python nmap

**网络映射器**（**Nmap**是一款免费的开源工具，用于网络发现和安全审计。它运行在所有主要的计算机操作系统上，Linux、Windows 和 Mac OS X 都有官方的二进制软件包。`python-nmap`库有助于以编程方式处理`nmap`的扫描结果，以自动化端口扫描任务。

通常我们在安装`python-nmap`后需要导入模块`nmap`：

```
import nmap

```

实例化`nmap`端口扫描仪：

```
nmap = nmap.PortScanner() 
host = '127.0.0.1' 

```

设置要扫描的`host`和`port`范围：

```
nmap.scan(host, '1-1024') 

```

我们可以打印用于扫描的`command_line`命令：

```
print nmap.command_line()

```

此外，我们还可以获得`nmap`扫描信息：

```
print nmap.scaninfo()

```

现在我们扫描所有主机：

```
for host in nmap.all_hosts(): 
    print('Host : %s (%s)' % (host, nmap[host].hostname())) 
    print('State : %s' % nmap[host].state()) 

```

我们还扫描所有协议：

```
for proto in nmap[host].all_protocols(): 
    print('Protocol : %s' % proto) 

listport = nmap[host]['tcp'].keys() 
listport.sort() 

for port in listport: 
    print('port : %s\tstate : %s' % (port, nmap[host][proto][port]['state']))
```

此脚本将提供如下输出：

![python-nmap](images/image_09_002.jpg)

### 提示

您可以从这里获得更多的`python-nmap`选项：[https://bitbucket.org/xael/python-nmap](https://bitbucket.org/xael/python-nmap) 。

# W3af REST API

**Web 应用程序审计和攻击框架**（**W3af**是一个强大而灵活的环境，用于 Web 漏洞评估和利用 Web 应用程序漏洞。它有许多可以相互通信的插件。例如，发现插件收集不同的 URL 进行测试并传递给审计插件，审计插件使用这些 URL 搜索漏洞。W3af 还可以利用它发现的漏洞。

W3af 有八种不同类型的插件：

*   **发现插件**：对 web 应用程序进行爬网，以查找新的 URL、表单和 web 应用程序的许多其他有趣部分。这些插件在一个循环中运行，输出作为下一个插件的输入。
*   **审计插件**：这些是 W3af 的主要部分，它们将发现插件的输出作为输入，扫描所有类型的 web 应用程序漏洞，如 SQL、XSS 注入等。
*   **Grep 插件**：与 UNIX Grep 实用程序一样，它们搜索每个 HTTP 请求和响应，以找到不寻常和有趣的信息。它可以是 IP、错误代码、电子邮件 ID、信用卡号码，甚至是危险的 JavaScript 代码。
*   **Bruteforce 插件**：这些插件有助于强制执行基本 HTTP 身份验证，并形成在发现阶段发现的登录身份验证。
*   **攻击插件**：该插件将从知识库中读取漏洞对象，并尝试对其进行攻击。
*   **Mangle 插件**：这些插件有助于基于正则表达式修改请求和响应，如 sed editor。
*   **规避插件**：这些插件有助于避免简单的**入侵检测规则**（**IDS**）。
*   **输出插件**：这些插件有助于创建不同文件格式的输出文件，如报表。

我们可以使用`w3af`API 连接`w3af`并使用这些模块。首先，我们必须运行`w3af`API。为此，获取`w3af`并运行`w3af_api`：

```
 $ ./w3af_api

```

`w3af`API 已经配置了一些可用于特定任务的配置文件。例如，`OWASP_TOP10`配置文件包括几个用于执行 OWASP 前 10 名安全分析的发现、审计和 grep 插件。因此，我们可以利用这些配置文件，或者我们可以创建自己的配置文件来运行`w3af`。

使用`w3af_api_client`从脚本访问`w3af_api`。安装`w3af_api_client`并导入：

```
from w3af_api_client import Connection, Scan

```

现在我们可以创建到`w3af`API 的连接。这将在端口`5000`上运行：

```
connection = Connection('http://127.0.0.1:5000/')

```

我们可以通过检查其版本来确保连接正确：

```
print connection.get_version() 

```

现在，我们可以定义要扫描的配置文件和目标 URL：

```
profile = file('w3af/profiles/OWASP_TOP10.pw3af').read() 
target = ['http://localhost'] 

```

然后，我们实例化扫描实例：

```
scan = Scan(connection) 

```

现在我们可以开始扫描了：

```
scan.start(profile, target) 

```

开始扫描后，我们可以获得结果、URL 和日志：

```
scan.get_urls() 
scan.get_log() 
scan.get_findings() 

```

我们可以通过以下方式获得`fuzzable`URL：

```
scan.get_fuzzable_requests()

```

由于 W3af 是一个 Python 工具，我们可以在脚本中将`w3af`作为模块导入，并在脚本中使用其功能。为此，我们必须为`w3af`下载`setup.py`。我们可以从[获取整个模块的文件 https://github.com/andresriancho/w3af-module](https://github.com/andresriancho/w3af-module) 。

下载此模块并验证子模块文件夹`w3af`中是否包含所有文件。如果没有，请从[下载`w3af`文件夹 https://github.com/andresriancho/w3af](https://github.com/andresriancho/w3af) 并替换该文件夹。

然后，运行以下命令：

```
 $ sudo python setup.py install

```

这将以 Python 模块的形式安装`w3af`。接下来，我们可以像导入其他 Python 模块一样导入它：

```
import w3af 

```

或者，我们可以导入其他`w3af`模块，例如：

```
from w3af.core.data.kb.shell import Shell
```

# 使用 MSGRPC 编写 Metasploit 脚本

**Metasploit**是一个开源项目，为开发、测试和执行漏洞利用提供公共资源。它还可用于创建安全测试工具、利用模块以及作为渗透测试框架。

Metasploit 是用 Ruby 编写的，它不支持用 Python 编写的模块或脚本。

但是，Metasploit 确实有一个使用 MSGPACK 的 MSGRPC 双向 RPC（远程过程调用）接口。`pymetasploit`Python 模块帮助 Python 和 Metasploit 的`msgrpc`进行交互。

所以在编写脚本之前，我们必须加载`msfconsole`并启动`msgrpc`服务。接下来，让我们启动 Metasploit 和 MSGRPC 接口。我们可以在 Metasploit 中使用`msfrpcd`启动 MSGRPC。以下是`msfrpcd`的完整选项：

```
$ ./msfrpcd

```

结果如下：

![Metasploit scripting with MSGRPC](images/image_09_007.jpg)

要使用密码`123456`启动 MSGRPC：

```
$ ./msfrpcd -P 123456 -n -f 

```

![Metasploit scripting with MSGRPC](images/image_09_008.jpg)

现在 Metasploit 的 RPC 接口正在监听端口`55553`。我们可以继续编写 Python 脚本。

与 MSGRPC 的交互几乎类似于与`msfconsole`的交互。首先，我们必须创建一个`msfrpc`类的实例。然后，使用凭据登录到`msgrpc`服务器，并创建一个虚拟控制台。

我们可以使用 pymetasploitpython 模块来使用 Python 自动化开发任务。从[克隆模块 https://github.com/allfro/pymetasploit](https://github.com/allfro/pymetasploit) ：

```
$ git clone https://github.com/allfro/pymetasploit.git

```

移动到以下模块文件夹：

```
$ cd pymetasploit

```

安装模块：

```
$ python setup.py install

```

现在，我们可以在脚本中导入模块：

```
from metasploit.msfrpc import MsfRpcClient

```

然后，我们可以为`MsfRpcClient`创建一个新实例。我们必须在 Metasploit 中进行身份验证才能运行其中的任何命令。因此，将要进行身份验证的密码传递给 Metasploit：

```
client = MsfRpcClient('123456') 

```

我们可以使用此实例浏览 Metasploit 的核心功能：

```
dir(client) 

```

这将列出核心功能。现在我们可以列出辅助选项：

```
auxilary = client.modules.auxiliary 
for i in auxilary: 
   print "\t%s" % I

```

类似地，我们可以使用相同的语法列出漏洞利用、编码器、有效负载和 post 的所有核心模块。我们可以使用以下使用方法激活其中一个模块：

```
scan = client.modules.use('auxiliary', 'scanner/ssh/ssh_version') 

```

然后我们可以设置参数：

```
scan['VERBOSE'] = True 
scan['RHOSTS'] = '192.168.1.119'

```

最后，运行模块：

```
Print scan.execute() 

```

如果执行成功，则输出如下：

```
{'job_id': 17, 'uuid': 'oxutdiys'}

```

如果失败，`job_id`将为无。

接下来，如果攻击成功，我们可以使用 sessions 方法访问 Shell 和控制台：

```
client.sessions.list

```

这将列出所有当前活动会话。如果攻击为受害者提供了外壳访问权限，那么我们可以获取可用外壳并通过以下方式访问它们：

```
shell = client.sessions.session(1) 
shell.write('whoami\n') 
print shell.read() 

```

我们也可以连接到控制台并像在`msfconsole`中那样运行命令：

导入模块：

```
from metasploit.msfrpc import MsfRpcClient 
from metasploit.msfconsole import MsfRpcConsole 

```

创建客户端：

```
client = MsfRpcClient('123456', user='msf') 

```

使用客户端创建控制台：

```
console = MsfRpcConsole(client) 

```

现在，我们可以使用此实例运行 Metasploit 命令，如下所示：

```
console.execute('use scanner/ssh/ssh_version') 
console.execute('set RHOSTS 192.168.1.119') 
console.execute('set VERBOSE True') 
console.execute('run')

```

输出将在控制台中打印。

这里我们使用了 PyMetasploit 模块，但是我们也可以使用 msgrpc 模块（[https://github.com/SpiderLabs/msfrpc](https://github.com/SpiderLabs/msfrpc) ）。这将帮助我们访问底层函数，并在脚本中处理结果和控制台输出。

# 使用 Python 的 ClamAV 杀毒软件

我们可以在 Linux、MacOSX 和 Windows 上使用开源 Python 模块 pyClamd 来使用 ClamAV 防病毒引擎。要从 Python 以编程方式使用 ClamAV，必须运行`clamd`守护进程的实例。

### 提示

您可以在 Windows、Linux 和 MacOSx 中安装 ClamAV。要在 Windows 和 Linux 中安装，请参阅[上的官方 ClamAV 文档 http://www.clamav.net/documents/installing-clamav](http://www.clamav.net/documents/installing-clamav) 。要在 MacOSX 中安装，请使用自制软件。

安装 ClamAV 后，将其配置为与网络套接字或 Unix 套接字一起使用。为此，我们必须更新`clamd`配置。对于 Linux，您可以在`/etc/clamav/`文件夹中找到两个配置文件；对于 Windows，您可以在`c:\clamAV\`文件夹中找到两个配置文件；对于 MacOSX，您可以在`/usr/local/etc/clamav`文件夹中找到两个配置文件。文件如下：`freshclam.conf`和`clamd.conf`。

如果找不到这些配置文件，请从示例配置文件创建它们，并更新`freshclam.conf`文件中的数据库镜像 URL。Freshclam 将获取防病毒数据库更新，因此我们应该立即运行它以获取初始数据库：

```
DatabaseMirror database.clamav.net

```

更新数据库镜像后，下载具有以下内容的 ClamAV 数据库：

```
$ freshclam -v

```

在`clamd.conf`中启用 Unix 套接字或网络套接字。要启用 Unix 套接字，请使用以下内容更新`clamd.conf`：

```
LocalSocket /tmp/clamd.sock 

```

现在您可以在终端窗口中使用`clamd`运行`clamd`守护程序。

在 Windows 中将`clamd`作为服务安装时，请运行安装程序并将其安装到`c:\clamav\`的默认位置。此外，请确保正确配置 Unix 套接字，并且在`config`文件中指定的位置存在。

然后您可以使用 Python 脚本中的`clamd`。导入`pyclamd`模块：

```
import pyclamd

```

接下来，尝试使用 Unix 套接字连接到`clamd`守护进程，如果失败，尝试连接到网络套接字：

```
try: 
   clamd = pyclamd.ClamdUnixSocket() 
   # test if clamd unix socket is reachable 
   clamd.ping() 
except pyclamd.ConnectionError: 
   # if failed,  test for network socket 
   clamd = pyclamd.ClamdNetworkSocket() 
   try: 
         clamd.ping() 
   except pyclamd.ConnectionError: 
         raise ValueError('could not connect to clamd server either by unix
         or network socket')

```

我们可以通过打印`clamd`版本来确认代码：

```
print(clamd.version()) 

```

最后，扫描文件或文件夹中的病毒：

```
print(clamd.scan_file('path-to-file-or-folder-to-scan')) 

```

这将输出病毒特征的详细信息（如果发现）。

### 提示

您可以在此处获得完整的 pyclamd 文档：[http://xael.org/pages/python-module-pyclamd.html](http://xael.org/pages/python-module-pyclamd.html) 。

# 来自 Python 的 OWASP ZAP

**OWASP ZAP**（**Zed 攻击代理**）是一款用 Java 编写的开源、跨平台 web 应用程序安全扫描工具，可在所有流行的操作系统中使用：Windows、Linux 和 Mac OS X。

OWASP ZAP 提供了一个 RESTAPI，它允许我们编写一个脚本以编程方式与 ZAP 通信。我们可以使用`python-owasp-zap`模块访问此 API。`python-owasp-zap-v2.4`模块可安装 pip。

首先加载所需的模块：

```
from zapv2 import ZAPv2 
from pprint import pprint 
import time 

```

定义要扫描的目标：

```
target = 'http://127.0.0.1'

```

现在我们可以实例化`zap`实例，如下所示：

```
zap = zapv2()
```

这将实例化一个新实例，假设`zap`在默认端口`8080`中侦听。如果 Zap 侦听非默认端口，则必须将自定义代理设置作为参数传递，如下所示：

```
zap = ZAPv2(proxies={'http': 'http://127.0.0.1:8090', 'https': 'http://127.0.0.1:8090'}) 

```

在`zap`中设置目标并启动会话：

```
zap.urlopen(target) 

```

最好等待一段时间，以便在`zap`中更新 URL 列表：

```
time.sleep(2)

```

现在，我们可以开始爬网任务：

```
zap.spider.scan(target) 

```

我们可以通过以下方式开始被动扫描：

```
zap.ascan.scan(target)

```

最后，我们可以使用`pprint`打印警报：

```
pprint (zap.core.alerts())

```

这将向我们提供来自`zap`的警报。

## 破解弱验证码

**验证码**（**全自动公共图灵测试，用于区分计算机和人类**）是一种挑战-响应测试，以确保响应由人类生成。它有助于防止机器人发送垃圾邮件、欺诈注册、伪造抽奖条目等。

许多站点都实现了自己的验证码，在这种情况下，我们可以从源代码处获取验证码图像。这可以是一个链接，在每次访问 URL 时生成一个带有新随机数字的图像。因此，为了绕过验证码，我们需要获得图像中的随机数字或单词。

我们已经学习了如何使用 Python 自动发送 post 请求。在这里，我们可以学习从图像中获取随机代码。我们可以使用`pytesseract`Python 模块通过**光学字符读取器**（**OCR**引擎读取图像。

### 提示

您可以在此处阅读有关 PyteSeract 的更多信息，以便将其安装到您的系统上：[https://github.com/madmaze/pytesseract](https://github.com/madmaze/pytesseract) 。

通常，我们可以导入所需的模块：

```
import pytesseract 
from urllib import urlretrieve 
from PIL import Image 

```

下载验证码图像并保存：

```
link = 'http://www.cs.sfu.ca/~mori/research/gimpy/ez/96.jpg' 
urlretrieve(link,'temp.png') 

```

使用 OCR 引擎读取图像：

```
print pytesseract.image_to_string(Image.open('temp.png'))  

```

这将打印出验证码中的单词。有时，根据验证码图像中使用的噪声，它需要一些图像处理。为此，我们可以使用`PIL`库功能。下面是一个使字母加粗的示例：

```
img = Image.open('temp.png') 
img = img.convert("RGBA") 
pix = img.load() 

for y in xrange(img.size[1]): 
   for x in xrange(img.size[0]): 
         if pix[x, y][0] < 90: 
               pix[x, y] = (0, 0, 0, 255) 

for y in xrange(img.size[1]): 
   for x in xrange(img.size[0]): 
         if pix[x, y][1] < 136: 
               pix[x, y] = (0, 0, 0, 255) 

for y in xrange(img.size[1]): 
   for x in xrange(img.size[0]): 
         if pix[x, y][2] > 0: 
               pix[x, y] = (255, 255, 255, 255) 

img.save("temp.png", "png")
```

然后，使用此输出图像为 OCR 引擎提供信息。在得到验证码图像中的单词后，我们可以在表单上填写验证码值。

### 提示

为了提高精度，我们可以训练 OCR 引擎。欲了解更多有关训练 Tesseract 的信息：[https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract) 。

## 用 Python 实现牛肉自动化

**浏览器攻击框架**（**牛肉**）是一种利用浏览器漏洞评估目标安全问题的安全工具。BeEF 是一个为安全测试人员提供客户端攻击向量的框架。此外，它允许我们为每个浏览器和上下文选择特定的模块。本节将讨论如何使用框架中提供的 RESTAPI 来自动化任务及其特性。

BeEF 关注使用 JavaScript 钩子的客户上下文。它创建了一个可以从控制面板控制的僵尸网络。当用户浏览包含钩子的网站时，该浏览器将自动成为该僵尸网络的一部分。然后，攻击者可以向钩子发送指令，在受害者的钩子 web 浏览器上执行任务。这将允许访问有关 web 浏览器的基本信息，启用或禁用插件和扩展，或者可以强制导航到其他网站。由于它是一个简单的 JavaScript 文件，在受害者访问的网页上下文中运行，因此关闭此网站（包括挂钩）将断开浏览器与僵尸网络的连接，从而解决问题。

### 安装牛肉

牛肉是用红宝石制成的。因此，它需要在您的系统上安装 Ruby 解释器。通常，使用多个工具（如 BeEF 和 Metasploit）有点困难，因为它们都是用 Ruby 开发的，并且使用不同版本的 Ruby。因此，最好使用**Ruby 版本管理器**（**RVM**）在您的系统上管理多个 Ruby 版本。

您可以在这里查看 RVM 官方网站[https://rvm.io](https://rvm.io) 。

这将有助于使事情变得更容易，你将节省很多时间。

要安装 BeEF，请使用以下命令从 GitHub 下载项目的最新版本：

```
$ git clone https://github.com/beefproject/beef.git beef-lastest 

```

然后安装捆绑程序：

```
$ sudo gem install bundler

```

然后安装牛肉：

```
$ cd beef-lastest 
$ bundle install

```

要运行此命令，请使用以下命令：

```
$ ./beef

```

输出结果如下：

![Installing BeEF](images/Capture.jpg)

*   从一个 web 界面管理多个受害者既低效又乏味。BeEF 有一个 RESTAPI，可以帮助自动化许多任务。要访问此 API，它需要一个 API 密钥，该密钥在启动时由 BeEF 生成。

![Installing BeEF](images/4323OS_09_06.jpg)

### 连接牛肉和蛋黄酱

BeEF 可以与 Metasploit 集成，并在钩住的受害者浏览器中运行漏洞攻击和有效负载。要使用 Metasploit 扩展，我们必须像以前一样使用 Metasploit 框架中的`msfrpcd`实用程序启动 MSGRPC。除此之外，我们还必须启用 BeEF 中可用的 Metasploit 扩展，编辑 BeEF 文件夹根目录中的主配置文件（`config.yaml`），并通过更改以下内容来启用`"extension"`部分中的 Metasploit 扩展：

```
metasploit:
enable: false
```

致：

```
metasploit:
enable: true
```

主配置文件已准备好支持 Metasploit 扩展，并且 MSGRPC 服务已启动。现在，我们必须更新扩展设置以更新到 MSGRPC 服务器的连接详细信息。为此，编辑 Metasploit 扩展名的配置文件（`extensions/metasploit/config.xml`：

![Connecting BeEF with Metasploit](images/4323OS_09_07.jpg)

现在，我们可以开始吃牛肉了。如果连接成功，将有一个额外的通知，指示加载的 Metasploit 攻击次数，如下所示：

![Connecting BeEF with Metasploit](images/Capture-2.jpg)

### 用 Python 访问牛肉 API

BeEF 的 restapi 几乎具备了自动化可以从 wedui 完成的活动所需的一切。这个 API 不是很复杂，因为它只需要发送带有正确参数的 HTTP 请求。因此，可以使用 Python 使用不同的库自动化这些 HTTP 请求。

正如我们在前几章中所讨论的，Python 有许多用于处理 HTTP 请求的库，如`urllib`、`urllib2`、`httplib`和`requests`。在这里，我们将使用一个名为 BeefAPI 的简单库，该库是用`requests`模块编写的。

我们可以从 GitHub[下载 BeEF API Python 库 https://github.com/byt3bl33d3r/BeEF-API](https://github.com/byt3bl33d3r/BeEF-API) 。要安装它，您只需要使用参数`install`运行`setup.py`脚本。

然后，我们可以导入`BeefAPI`模块并登录到 BeEF API：

```
from beefapi import BeefAPI
Beef =  BeefAPI ({})
Beef.login ( 'beef' , 'beef' )
```

现在，我们可以列出所有已加载的模块，包括：

```
for module in beef.modules: 
   print module.id, module.name
```

我们可以使用以下命令在模块中搜索特定字符串：

```
for module in beef.modules.findbyname('firefox'):
   print module.id, module.name
```

这将打印名称中带有字符串`firefox`的所有模块。

我们可以针对一个或多个钩住的浏览器运行一个模块，为此，我们必须获得相应的浏览器对象，然后通过指定针对浏览器使用的模块标识符在其上运行该模块。每个钩住的浏览对象都有一个名为`run`的方法，该方法接收一个表示模块标识符的数值作为参数：

```
for hook in  beef.hooked_browsers.online:
   commandID=  hook.run(231)['command_id']
   print  beef.modules.findbyid(231).results(hook.session, commandID)
```

标识符为`231`的模块为*替换视频*模块。此模块将重写所有匹配链接的所有 href 属性。`run`方法将执行指定的模块，并返回一个带有命令标识符（`command_id`的`.json`格式的结构，该标识符随后将用于获取模块返回的结果。

# 用 Python 访问 Nessus 6 API

Nessus 是 Tenable Network Security 开发的流行漏洞扫描器之一，该扫描器扫描计算机，如果发现攻击者可用于访问连接到网络的任何计算机的任何漏洞，则会发出警报。Nessus 提供了一个 API 以编程方式访问它。我们可以使用任何库来发出 HTTP 请求，这在 Python 中非常丰富 https://github.com/tenable/nessrest 使用 Nessus 6 REST API 的`requests`模块。

要在 Python 脚本中使用此模块，请在安装后像导入其他模块一样导入它。我们可以用`pip`安装`nessrest`模块：

```
$ pip install nessrest

```

然后，将其导入到我们的脚本中：

```
from nessrest import ness6rest
```

现在我们可以初始化扫描程序，因为我们使用自签名证书运行 Nessus，所以必须禁用 SSL 证书检查。为此，将另一个参数`insecure=True`传递给`Scanner`初始值设定项：

```
scan = ness6rest.Scanner(url="https://localhost:8834", login="user", password="password", insecure=True)
```

要添加和启动扫描，请指定目标并运行扫描：

```
scan.scan_add(targets="192.168.1.107")
scan.scan_run()
```

我们可以通过以下方式获得扫描结果：

```
scan.scan_results()
```

### 提示

要了解更多 Nessus 6 中提供的服务，您可以查看 Nessus 安装`https://localhost:8834/nessus6-api.html`中包含的文档。您必须启动 Nessus 实例才能查看此文档。

# 总结

我们已经浏览了一些可用于安全自动化的库。现在我们准备在脚本中使用这些模块。这将帮助我们自动化许多安全任务。我们还可以将一个脚本或工具的结果用于另一个脚本或工具，从而将这些工具层叠起来，以自动化 pentesting。

本书深入了解了 Python 及其相关模块的基本用法，有助于读者获得深入的渗透测试知识。简而言之，这些章节涵盖了使用 Python 执行安全测试的基本思想。借助本书中介绍的技术和资源，读者可以在安全测试方面达到前所未有的高度。Python 的威力还没有完全发挥出来。它在安全测试方面的推广是广泛的，我们将读者置于十字路口，以便更深入地探讨这一点。