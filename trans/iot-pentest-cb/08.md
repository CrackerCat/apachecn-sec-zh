# 固件安全最佳实践

在本章中，我们将介绍以下配方：

*   防止内存损坏漏洞
*   防止注射攻击
*   保护固件更新
*   保护敏感信息的安全
*   强化嵌入式框架
*   保护第三方代码和组件

# 介绍

嵌入式软件是物联网的核心，尽管嵌入式应用程序安全通常不被认为是嵌入式开发人员和物联网设备制造商的优先事项。这可能是由于缺乏安全编码知识或团队代码库之外的其他挑战造成的。开发人员面临的其他挑战可能包括但不限于**原始设计制造商**（**ODM**）供应链、有限内存、小堆栈以及将固件更新安全推送到端点的挑战。本章提供了开发人员可纳入嵌入式固件应用程序的实用最佳实践指南。根据 OWASP 的嵌入式应用程序安全项目（[https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security) ），嵌入式最佳实践包括：

*   缓冲区和堆栈溢出保护
*   注射攻击预防
*   保护固件更新
*   保护敏感信息的安全
*   身份管理控制
*   嵌入式框架与基于 C 语言的工具链强化
*   调试代码和接口的使用
*   保护设备通信安全
*   数据收集和存储的使用
*   保护第三方代码
*   威胁建模

本章将介绍前面提到的几个最佳实践，这些实践主要是针对 POSIX 环境量身定制的，但是这些原则的设计与平台无关。

# 防止内存损坏漏洞

在使用低级语言（如 C）时，如果开发人员没有以编程方式正确检查和验证边界，则很有可能出现内存损坏错误。防止使用已知的危险函数和 API 有助于防止固件中的内存损坏漏洞。例如，已知的不安全 C 函数的非详尽列表包括：`strcat`、`strcpy`、`sprintf`、`scanf`和`gets`。常见内存损坏漏洞（如缓冲区溢出或堆溢出）可能包括堆栈或堆溢出。攻击这些特定内存损坏漏洞时的影响因操作系统平台而异。例如，商用 RTOS 平台（如 QNX Neutrino）将每个进程及其堆栈与文件系统隔离，从而最大限度地减少攻击面。但是，对于常见的嵌入式 Linux 发行版，情况可能并非如此。嵌入式 Linux 中的缓冲区溢出可能导致攻击者任意执行恶意代码和修改操作系统。在此配方中，我们将展示工具如何帮助检测易受攻击的 C 函数，并提供安全控制以及防止内存损坏漏洞的最佳实践。

# 准备

对于该配方，将使用以下工具：

*   **Failfinder**：Failfinder 是一款免费的 C/C++静态代码分析工具，可报告潜在的安全漏洞。

# 怎么做。。。

常见的 Linux 实用程序有助于搜索 C/C++代码文件。尽管如此，在防止 IDE 插件开发人员可以使用的内存损坏漏洞方面，市面上有一些可用的源代码分析工具，它们比普通实用程序做得更好。出于演示目的，我们将在以下步骤中展示如何使用 grep 和 failfinder 在代码文件中搜索预定义的函数易受攻击调用和规则列表。

1.  要发现不安全的 C 函数，可以使用几种方法。最简单的形式是使用一个`grep`表达式，类似于下面的示例：

```
$ grep -E '(strcpy|strcat|sprintf|strlen|memcpy|fopen|gets)' code.c

```

此表达式可以调整为更智能，也可以封装在脚本中，该脚本可以在每个构建或特定基础上执行。

2.  或者，通过调用`flawfinder`和代码段的路径，可以使用`flawfinder`等免费工具来搜索易受攻击的函数，如下例所示：

```
$ flawfinder fuzzgoat.c
Flawfinder version 1.31, (C) 2001-2014 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 169
Examining fuzzgoat.c

FINAL RESULTS:

fuzzgoat.c:1049: [4] (buffer) strcpy:
Does not check for buffer overflows when copying to destination (CWE-120).
Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is easily misused).
    fuzzgoat.c:368: [2] (buffer) memcpy:
    Does not check for buffer overflows when copying to destination        (CWE-120).
    Make sure destination can always hold the source data.
fuzzgoat.c:401: [2] (buffer) sprintf:
    Does not check for buffer overflows (CWE-120). Use sprintf_s, 
    snprintf, or vsnprintf. Risk is low because the source has a    
    constant maximum length.
    <SNIP>
fuzzgoat.c:1036: [2] (buffer) strcpy:
    Does not check for buffer overflows when copying to destination (CWE-120).
    Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is 
    easily
    misused). Risk is low because the source is a constant string.
fuzzgoat.c:1041: [2] (buffer) sprintf:
    Does not check for buffer overflows (CWE-120). Use sprintf_s, 
    snprintf, or vsnprintf. Risk is low because the source has a      
    constant maximum length.
fuzzgoat.c:1051: [2] (buffer) strcpy:
    Does not check for buffer overflows when copying to destination (CWE-120).
    Consider using strcpy_s, strncpy, or strlcpy (warning, strncpy is    
    easily misused). Risk is low because the source is a constant     
    string.
ANALYSIS SUMMARY:

Hits = 24
Lines analyzed = 1082 in approximately 0.02 seconds (59316 lines/second)
Physical Source Lines of Code (SLOC) = 765
Hits@level = [0] 0 [1] 0 [2] 23 [3] 0 [4] 1 [5] 0
Hits@level+ = [0+] 24 [1+] 24 [2+] 24 [3+] 1 [4+] 1 [5+] 0
Hits/KSLOC@level+ = [0+] 31.3725 [1+] 31.3725 [2+] 31.3725 [3+] 
1.30719 [4+] 1.30719 [5+] 0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming for Linux and Unix HOWTO'
(http://www.dwheeler.com/secure-programs) for more information.

```

3.  在使用中发现易受攻击的 C 函数时，必须合并安全的替代方案。例如，以下易受攻击的代码使用不安全的`gets()`函数，该函数不检查缓冲区长度：

```
#include <stdio.h> 
int main () { 
    char userid[8]; 
    int allow = 0; 
    printf external link("Enter your userID, please: "); 
    gets(userid);  
    if (grantAccess(userid)) { 
        allow = 1; 
    } 
    if (allow != 0) {  
        privilegedAction(); 
    } 
    return 0; 
} 
```

4.  可以使用`8`上任意数量的字符对`userid`进行溢出，例如具有自定义执行功能的**缓冲区溢出漏洞**（**BoF**）有效负载。为了减少缓冲区溢出，`fgets()`功能可用作安全的替代方案。下面的示例代码展示了如何安全地使用`fgets()`并正确分配内存：

```
#include <stdio.h> 
#include <stdlib.h> 
#define LENGTH 8 
int main () { 
    char* userid, *nlptr; 
    int allow = 0; 

    userid = malloc(LENGTH * sizeof(*userid)); 
    if (!userid) 
        return EXIT_FAILURE; 
    printf external link("Enter your userid, please: "); 
    fgets(userid,LENGTH, stdin); 
    nlptr = strchr(userid, '\n'); 
    if (nlptr) *nlptr = '\0'; 

    if (grantAccess(userid)) { 
        allow = 1; 
    } 
    if (allow != 0) { 
        priviledgedAction(); 
    } 

    free(userid); 

    return 0; 
} 
```

相同的缓解措施可用于其他安全替代功能，如`snprintf()`、`strlcpy()`和`strlcat()`。根据操作系统平台的不同，某些安全的替代方案可能不可用。执行您自己的研究以确定特定体系结构和平台的安全替代方案非常重要。英特尔已经创建了一个名为`safestringlib`的开源跨平台库，以防止使用这些不安全的禁用函数；使用替代的安全更换功能。有关`safestringlib`的更多详细信息，请访问 GitHub 页面：[https://github.com/01org/safestringlib](https://github.com/01org/safestringlib) 。

其他内存安全控制可用于防止内存损坏漏洞，例如：

*   使用安全的编译器标志，例如-fPIE、-fstack-protector-all、-Wl、-z、noexecstack、-Wl、-z、noexecaspect 和其他可能取决于特定编译器版本的标志。
*   首选包含内存管理单元（MMU）的片上系统（SoC）和微控制器（MCU）。MMU 隔离线程和进程，以在内存漏洞被利用时减少攻击面。
*   首选包含**内存保护单元**（**MPU**）的**片上系统**（**SoC**）和**微控制器**（**MCU**）。MPU 强制执行内存和独立进程的访问规则，以及强制执行特权规则。
*   如果没有 MMU 或 MPU 可用，则使用已知位监控堆栈，通过确定堆栈中有多少不再包含已知位来监控堆栈的消耗量。
*   使用后，请注意缓冲区和空闲缓冲区中放置的内容。

通过**地址空间布局随机化**（**ASLR**）和其他堆栈控件利用内存漏洞确实需要攻击者付出大量努力才能利用。尽管如此，在某些情况下仍然是可能的。确保代码具有弹性，并对存储在内存中的数据采用纵深防御方法，将有助于嵌入式设备的安全态势。

# 另见

*   有关进一步的安全内存管理指南，请参考卡内基梅隆大学的安全证书 C 编码标准（[https://www.securecoding.cert.org/confluence/display/c/SEI+证书+C+编码+标准](https://www.securecoding.cert.org/confluence/display/c/SEI+CERT+C+Coding+Standard)。
*   对于进一步的安全内存管理指南，参考卡耐基-梅隆的安全证书 C++Cald-编码标准 https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637 ）

# 防止注射攻击

注入攻击是任何 web 应用程序中最常见的漏洞之一，尤其是在物联网系统中。事实上，自 2010 年以来，注射被评为 OWASP 前 10 名的前 2 名。注入攻击有多种类型，如**操作系统**（**OS**）命令注入、跨站点脚本（例如 JavaScript 注入）、SQL 注入、日志注入，以及表达式语言注入等。在物联网和嵌入式系统中，最常见的注入攻击类型是操作系统命令注入；应用程序接受不受信任的用户输入并传递该值以执行 shell 命令，而无需输入验证或正确的转义和跨站点脚本（XSS）。此配方将向您展示如何通过确保所有不受信任的数据和用户输入都经过验证、消毒并使用其他安全功能来减轻命令注入攻击。

# 怎么做。。。

当 IoT 设备运行时，命令注入漏洞不难测试静态和动态。固件可以调用`system()`、`exec()`和类似的变体来执行操作系统命令，或者调用外部脚本来运行解释语言（如 Lua）的操作系统调用。命令注入漏洞也可能由缓冲区溢出引起。下面的步骤和示例展示了易受命令注入攻击的代码，以及如何减轻命令注入的影响。之后，我们将列出防止常见注入攻击的常见安全控制。

1.  下面的代码片段调用危险的`system()`C 函数删除`home`目录中的`.cfg`文件。如果攻击者能够控制该功能，则可能会连接后续 shell 命令以执行未经授权的操作。此外，攻击者还可以操纵环境变量来删除以`.cfg`结尾的任何文件：

```
#include <stdlib.h> 

void func(void) { 
  system("rm ~/.cfg"); 
}
```

2.  为了缓解前面的易受攻击代码，将使用`unlink()`函数而不是`system()`函数。`unlink()`功能不易受到符号链接和命令注入攻击。`unlink()`函数删除符号链接，不影响由符号链接内容命名的文件或目录。这降低了`unlink()`功能对符号链接攻击的敏感性，但不能完全阻止符号链接攻击；如果命名目录相同，也可以将其删除。`unlink()`函数不会阻止命令注入攻击，应使用类似的上下文函数，而不是执行操作系统调用：

```
#include <pwd.h> 
#include <unistd.h> 
#include <string.h> 
#include <stdlib.h> 
#include <stdio.h> 
void func(void) { 
  const char *file_format = "%s/.cfg"; 
  size_t len; 
  char *pathname; 
  struct passwd *pwd; 

  pwd = getpwuid(getuid()); 
  if (pwd == NULL) { 
    /* Handle error */ 
  } 

  len = strlen(pwd->pw_dir) + strlen(file_format) + 1; 
  pathname = (char *)malloc(len); 
  if (NULL == pathname) { 
    /* Handle error */ 
  } 
  int r = snprintf(pathname, len, file_format, pwd->pw_dir); 
  if (r < 0 || r >= len) { 
    /* Handle error */ 
  } 
  if (unlink(pathname) != 0) { 
    /* Handle error */ 
  } 

  free(pathname); 
} 
```

还有其他几种方法可以缓解注入攻击。以下是防止注入攻击的常见最佳做法和控制措施列表：

*   如果可能，避免直接调用操作系统调用。
*   如果需要，白名单接受命令并在执行之前验证输入值。
*   使用数字的查找映射来命令用户驱动的字符串，这些字符串可能会被传递到操作系统，例如`{1:ping -c 5}`。
*   在代码库上执行静态代码分析，并在使用操作系统命令（如`os.system()`）时发出警报。
*   将所有用户输入视为不可信的，并输出返回给用户的数据的编码字符。（例如，`Convert & to &amp`、`Convert < to &lt`、`Convert > to &gt`等。）
*   对于 XSS，使用 HTTP 响应头，如 X-XSS-Protection 和内容安全策略，并配置相应的指令。
*   确保在生产固件构建（例如，[）上禁用带有命令执行的调试接口 http://example.com/command.php](http://example.com/command.php) ）。

在生产环境中使用固件之前，上述控件始终需要进行测试。通过注入攻击，设备和用户将面临被攻击者和胭脂设备接管的风险。2017 年，IoT 收割者和 Persirai 僵尸网络将发生此类事件。这只是开始。

# 另见

*   有关进一步的注射预防指南和注意事项，请参考 OWASP 的嵌入式应用程序安全项目（[https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security) 和 OWASP XSS（跨站点脚本）预防备忘单[https://www.owasp.org/index.php/XSS_（跨站点脚本）_ 预防作弊单](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)。

# 保护固件更新

根据行业的不同，只有制造商、供应商或企业授权的固件才能闪存到设备上。为确保实现这一点，必须在下载固件时使用健壮的更新机制，并在适用时更新与第三方软件或库相关的功能。所有固件均应使用加密签名，以验证自开发人员创建并签署文件以来，文件未被修改或篡改。签名和验证过程使用公钥加密技术，在不首先获得私钥访问权的情况下，很难伪造数字签名（例如，PGP 签名）。当使用公钥加密时，必须安全地存储它，并且不向意外方公开。如果私钥泄露，软件开发人员必须撤销泄露的密钥，并需要使用新密钥重新签署所有以前的固件版本。对于许多已经要求用户将设备或牵引车送回服务店的物联网产品来说，这一直是一个问题。保护固件更新的实施方式因部署物联网设备的行业而异。例如，一些产品可能有**无线**（**OTA**更新，而其他产品可能需要通过 USB 或通过加载新固件映像的接口手动更新。对于一些常见的消费级物联网设备，这可能不是一个大问题，但是如果未经授权的恶意固件加载到连接的车辆或医疗设备上，后果可能是致命的。此配方将列出可用于保护固件更新的功能。

# 怎么做。。。

在为嵌入式物联网设备实施安全更新生态系统时，有许多变量和注意事项需要考虑。某些体系结构、SOC 或引导加载程序可能无法执行使用弹性固件更新系统所需的所有操作。由于采用安全更新系统的复杂性和多样性，我们将讨论制造商应在固件更新设计中采取的高级措施。为简单起见，我们将使用嵌入式 Linux 作为平台，并提供安全更新系统所需的要求。同样，并非所有以下要求都是可行的，但是，设备制造商在使用安全更新系统时，必须进行尽职调查并了解风险。以下列表是安全固件更新的安全控制和要求。

1.  为引导加载程序实现安全引导或验证引导。
2.  使用安全硬件芯片（例如 TPM、HSM、安全元件）保护安全引导密钥。

3.  确保可靠的更新机制利用加密签名的固件映像来更新功能。
4.  图像必须在下载后和闪烁时进行验证。
5.  确保通过最新的安全 TLS 版本下载更新（在撰写本文时，这是 TLS 1.2）：
    *   确保更新验证了更新服务器的公钥和证书链
6.  包括一项功能，以按照预定义的计划使用自动固件更新：
    *   在高度易受攻击的用例中强制更新
    *   对于某些设备（如医疗设备），应考虑计划推送更新，以防止强制更新产生可能的问题
7.  确保清楚显示固件版本。
8.  确保固件更新包括包含安全相关漏洞的变更日志。
9.  通过电子邮件、应用程序通知或登录应用程序时通知客户新固件可用。
10.  确保采用了防降级保护（防回滚）机制，以便设备无法还原为易受攻击的固件版本。
11.  考虑实现一个完整的度量体系结构 T1 T1（MultT2，IMA OutT3），它允许内核通过对一个存储/计算哈希（称为标签）进行验证来检查文件是否没有被改变。**扩展验证模块**（**EVM**检查文件属性（包括扩展属性）。

有两种类型的标签可用：

*   不可变的和有符号的
*   易于理解的

12.  考虑实现一个只读根文件系统，它可以为需要本地持久性的目录创建一个覆盖。

安全更新系统在很大程度上依赖公钥加密来签名和验证固件映像。这需要基础架构和管理来维护设备签名和验证密钥的生命周期。如果密钥受损或需要更新，则应在部署生产之前对其进行测试，以防止设备损坏。尽管如此，仍有第三方公司提供**无线固件**（**FOTA**）更新服务，将责任转移给服务提供商。对于制造商必须支付网络数据费用的互联车辆等产品而言，这可能会很昂贵。在选择更新机制时，应该考虑一些框架，例如更新框架（[https://theupdateframework.github.io/](https://theupdateframework.github.io/) 和 Uptane（[https://uptane.github.io/](https://uptane.github.io/) 用于连接的车辆。

# 保护敏感信息的安全

由于存储空间有限且利润微薄，保护敏感数据对物联网设备来说可能是一个挑战。通常，敏感数据存储在客户端应用程序或设备上，因此物联网服务可以在没有互联网连接的情况下运行。在保护设备上的敏感数据时，需要遵循一些安全原则。首先，切勿将密码、用户名、令牌、私钥或类似变体等固件映像硬编码为固件版本映像。这还包括存储写入磁盘的敏感数据。攻击者在提取固件文件系统时以及在运行时访问操作系统时都可以访问这些数据。如果有**安全元素****SE**或**可信执行环境****TEE**等硬件可用，建议在运行时使用这些功能存储敏感数据。否则，应评估强加密的使用，以使用服务器端计算保护数据，以补偿硬件限制。

如果可能，明文中的所有敏感数据本质上应该是短暂的，并且只驻留在易失性存储器中。此配方将为您提供一些不安全使用数据的场景，以及如何缓解物联网设备中不安全的 C 代码。

# 怎么做。。。

通过编程示例，我们将展示如何不安全地存储数据以及如何修复存储漏洞。

1.  在下面的示例中，敏感信息被不安全地存储在由`key`引用的动态分配内存中，该内存被复制到动态分配的缓冲区`new_key`，然后通过调用`free()`进行处理并最终解除分配。由于内存未被清除，它可能会被重新分配到程序的另一个部分，`new_key`中存储的信息可能会意外泄漏：

```
char *key; 

/* Initialize secret */ 

char *new_key; 
size_t size = strlen(key); 
if (size == SIZE_MAX) { 
  /* Handle error */ 
} 

new_key = (char *)malloc(size+1); 
if (!new_key) { 
  /* Handle error */ 
} 
strcpy(new_key, key); 

/* Process new_key... */ 

free(new_key); 
new_key = NULL; 
```

2.  为了防止发生这种信息泄漏，在释放包含敏感信息的动态内存之前，应该对其进行清理。清理通常通过使用`'\0'`字符清除分配的空间来执行，也称为零输出：

```
char *key; 

/* Initialize secret */ 

char *new_key; 
size_t size = strlen(key); 
if (size == SIZE_MAX) { 
  /* Handle error */ 
} 

/* Use calloc() to zero-out space */ 
new_key = (char *)calloc(size+1, sizeof(char)); 
if (!new_key) { 
  /* Handle error */ 
} 
strcpy(new_key, key); 

/* Process new_key... */ 

/* Sanitize memory  */ 
memset_s(new_key, '\0', size); 
free(new_secret); 
new_key = NULL; 
```

上述示例可用于设备没有可用于单独操作系统进程和内存位置的硬件安全芯片的情况。如果没有硬件安全芯片（例如 TPM 或 SE）或用于 ARM 体系结构的 TEE 环境，安全地存储数据对于嵌入式设备来说是一个挑战。有时，开发人员可能将敏感数据存储在平台操作系统不可用的不同存储分区中，但这也不是一个安全的存储位置。通常，闪存芯片可以从 PCB 板上取下，并带到离线位置进行检查或数据过滤。

正在创建新的框架和操作系统平台，以帮助解决存储敏感数据的问题。如果使用 ARM Mbed 操作系统，则可以利用名为 uVisor 的设备安全层通过硬件安全功能限制对内存的访问来隔离代码块。尽管 Mbed 尚处于起步阶段，但它拥有大型半导体公司的强大支持，不仅包含操作系统平台，还包含云服务平台。

# 另见

*   有关 uVisor 的详细信息，请访问以下网站：

[https://www.mbed.com/en/technologies/security/uvisor/](https://www.mbed.com/en/technologies/security/uvisor/)

*   可以通过以下 URL 在 GitHub 存储库中找到 uVisor 的示例代码用法：

[https://github.com/ARMmbed/mbed-os-example-uvisor-number-store](https://github.com/ARMmbed/mbed-os-example-uvisor-number-store)

*   有关 Mbed 操作系统的更多信息，请访问其网站，网址如下：

[https://www.mbed.com](https://www.mbed.com/)

# 强化嵌入式框架

设计和构建嵌入式固件可能很复杂，它的所有依赖项和意大利面条制作文件都是几十年来从未接触过的。尽管这些共同的复杂性，建立一个建立安全软件的基础从平台和工具链的硬化开始。许多嵌入式 Linux 设备使用 BusyBox，其中包含常见的 GNU 实用程序。BusyBox 有一些特定的配置，也有一些更新。除了 BusyBox 之外，嵌入式框架和工具链应该修改为仅在配置固件构建时使用的库和函数。RTOS 系统通常也有 POSIX 实用程序，但由修改了常用实用程序版本的 SoC、MCU 和芯片供应商进行配置。嵌入式 Linux 构建系统（如 Buildroot、Yocto 等）执行设置和配置工具链环境的任务。移除已知的不安全库和协议（如 Telnet）不仅可以最大限度地减少固件构建中的攻击入口点，还可以提供一种安全的设计方法来构建软件，从而挫败潜在的安全威胁。在这个配方中，我们将展示如何使用 Buildroot 选择和取消选择网络服务和配置。

# 准备

在本配方中，Buildroot 将用于演示硬化。

**Buildroot**是通过交叉编译生成嵌入式 Linux 系统的工具。Buildroot 可通过以下站点下载：

[https://buildroot.uclibc.org/download.html](https://buildroot.uclibc.org/download.html) 。

# 怎么做。。。

我们将首先使用 Buildroot 并打开其配置菜单选项。

1.  下载 Buildroot 后，在 Buildroot 文件夹的根目录中运行以下命令以显示 Buildroot 的配置选项：

```
    $ make menuconfig
```

其他配置用户界面根据偏好提供，如`xconfig`和`gconfig`。有关更多详细信息，请查看 Buildroot 的用户手册，网址为：[https://buildroot.uclibc.org/downloads/manual/manual.html](https://buildroot.uclibc.org/downloads/manual/manual.html) 。

2.  应出现以下屏幕：

![](Images/b940eca2-6c98-4eb7-bb84-81d5036264c8.png)

3.  在这里，可以对 Linux 固件映像进行配置。出于我们的目的，我们将向您介绍如何选择安全守护进程和安全默认值。
4.  接下来，导航到 Toolchain 菜单并启用使用`-fstack-protector-all`构建标志的堆栈保护支持：

![](Images/98ad6f32-da38-4355-bcc3-5bf03a4093b2.png)

5.  导航至主菜单屏幕并进入系统配置菜单。选择密码编码并选择 sha-512：

![](Images/8429a2f7-cb90-4549-b4c2-af3060a1aeaf.png)

6.  在系统配置页面中，我们可以为固件映像创建根密码。在这里，我们希望使用一个长的字母数字密码，如屏幕截图所示：

![](Images/02cc8e17-c5c0-4e6b-a11d-4f31a8229a4b.png)

7.  退出系统配置菜单并导航到目标软件包菜单选项。在这里，我们可以指定要包含在固件映像中的工具、库、守护进程和第三方代码。根据设备的不同，有许多选项可用，因此我们将仅使用一个示例。以下屏幕截图显示选择的是 openssh 而不是 Telnet：

仅在使用 TLS 时启用 FTP。对于纯 FTPd，这需要通过传递`./configure --with-tls`进行自定义编译。

![](Images/8d0fd502-8aa7-42d4-9f97-4fb750e13a5e.png)

8.  导航回目标软件包菜单，然后选择 Shell 和 utilities 子菜单。在此，确保仅选择一个 shell 解释器以减少攻击面：

![](Images/2ee86680-4a80-4eb3-9ea8-418ed861e5cb.png)

选择所有选项后，您将保存配置，然后选择 exit 以保留 menuconfig 选项。然后，从 Buildroot 文件夹中输入`make`以构建您的配置和工具链。

在使用 Yocto 构建系统时，可以采取类似的步骤，确保仅使用所需的软件包更新和配置配方。有几种其他配置可用于强化 Linux 构建环境，包括以下内容：

1.  删除未使用的语言解释器，如 Perl、Python 和 Lua。
2.  从未使用的库函数中删除死代码。
3.  删除传统的不安全守护程序，包括但不限于 Telnet、FTP 和 TFTP。
4.  从 Busybox 中删除未使用的 shell 实用程序，如 grep、awk、wget、curl 和 sed。

5.  强化库或服务以支持加密。
6.  确保为构建选择的所有包和库都使用最新版本。
7.  使用最新的 Linux 内核。
8.  禁用 IPv4 转发
9.  禁用 IP 源路由
10.  禁用 ICMP
11.  忽略所有广播消息
12.  禁用 IPV6
13.  启用 TCP SYN Cookie 保护
14.  使用 Linux 安全模块（包括 SELinux）。
15.  使用免费工具，如 Lynis（[https://raw.githubusercontent.com/CISOfy/lynis/master/lynis](https://raw.githubusercontent.com/CISOfy/lynis/master/lynis) 用于构建后的强化建议。

上述清单并非详尽无遗。在嵌入式设备上运行的软件上，与开发人员以及相关利益相关者进行迭代威胁模型练习，可确保低挂果实，如易受攻击的过时软件，并且不会引入。

# 保护第三方代码和组件

在工具链设置之后，重要的是确保软件包和第三方上游库保持更新，以在 IoT 设备投入生产后防止公开的漏洞。黑盒第三方软件（如 RomPager、NetUSB）和嵌入式构建工具（如 Buildroot）应根据漏洞数据库及其变更日志进行检查，以确定何时以及是否需要更新。使用上游 BSP 驱动程序并非易事；在发布版本之前，开发团队应该测试对库和上游 BSP 驱动程序的更改，因为更新可能会导致不可预见的依赖性问题。

嵌入式项目和应用程序应维护固件映像中包含的第三方库和开源软件的物料清单（BOM）。这有时是世界上某些受监管地区以及 GPL 的一项要求，但维护 BOM 也可以改进资产和库的管理。应检查此材料清单，以确认所含的第三方软件没有任何未修补的漏洞或已知问题。最新的漏洞信息可通过**国家漏洞数据库**（**NVD**）、Open Hub 或类似的第三方网站找到。

在固件发布到所有细分市场之前，确保删除所有不必要的预生产构建代码以及死掉和未使用的应用程序代码非常重要。这包括但不限于**原始设计制造商**（**ODMs**）、供应商和第三方承包商出于测试或客户支持目的可能留下的潜在后门代码和根特权帐户。通常，这属于**原始设备制造商**（**原始设备制造商**使用[第 3 章](03.html)中所述的方法对二进制文件进行逆向工程，*分析和开发固件*的范围。为防止 OEM 产生额外的人工开销，ODM 应同意**主服务协议**（**MSAs**），确保未包含任何后门代码或用户帐户，并且已审查所有代码是否存在软件安全漏洞，从而使第三方开发公司对大量部署到市场上的设备负责。此外，考虑冗长，要求 ODMs 有信息安全人员的工作人员，以及建立服务水平协议（SLA），以修复关键的安全漏洞。此配方将向您展示使用免费工具保护第三方代码和组件的方法。

# 准备

此配方需要以下工具：

*   **RetireJS**：RetireJS 检测具有已知漏洞的 JavaScript 库的使用情况。RetireJS 可以通过其 GitHub 存储库（[下载 https://github.com/RetireJS/retire.js](https://github.com/RetireJS/retire.js) 或通过`npm`使用以下命令：

```
npm install -g retire

```

*   **节点安全平台**（**NSP**）：NSP 检测已知易受攻击的 NodeJS 包在项目中的使用情况。NSP 可以通过其 GitHub 存储库（[安装 https://github.com/nodesecurity/nsp](https://github.com/nodesecurity/nsp) 或通过`npm`使用以下命令：

```
npm install -g nsp

```

*   **LibScanner**：LibScanner 是一个免费工具，可以根据用于 Yocto 构建环境的 NVD 数据库解析 RPM 或 SWID 包列表。LibScanner 可从其 GitHub 存储库下载，网址为[https://github.com/DanBeard/LibScanner](https://github.com/DanBeard/LibScanner) 。

# 怎么做。。。

许多物联网设备运行各种 JavaScript 代码，以帮助减轻硬件资源消耗。有时，当设备需要充当特定用例的服务器时，此代码也在设备上运行。有一些很棒的工具可以扫描项目目录，查找项目中使用的已知易受攻击的 JavaScript 版本。首先，我们将看一看 RetireJS。

1.  要运行 RetireJS，只需运行`retire`命令并指定 JavaScript 目录，如下所示：

```
$ retire path/to/js/
Loading from cache: https://raw.githubusercontent.com/RetireJS/retire.js/master/repository/jsrepository.json
    Loading from cache: https://raw.githubusercontent.com/RetireJS/retire.js/master/repository/npmrepository.json
    /static/js/lib/jquery-ui.js
      jquery-ui-dialog 1.8.17 has known vulnerabilities: severity: medium; bug: 6016, summary: Title cross-site scripting vulnerability; http://bugs.jqueryui.com/ticket/6016 severity: high; bug: 281, summary: XSS Vulnerability on closeText option; https://github.com/jquery/api.jqueryui.com/issues/281 https://snyk.io/vuln/npm:jquery-ui:20160721
      jquery-ui-autocomplete 1.8.17
    /static/js/lib/jquery.js
      jquery 1.7.1 has known vulnerabilities: severity: medium; bug: 11290, summary: Selector interpreted as HTML; http://bugs.jquery.com/ticket/11290 http://research.insecurelabs.org/jquery/test/ severity: medium; issue: 2432, summary: 3rd party CORS request may execute; https://github.com/jquery/jquery/issues/2432 http://blog.jquery.com/2016/01/08/jquery-2-2-and-1-12-released/

```

扫描发现了项目中使用的两个易受攻击的 jQuery 库，以及补充阅读和解释。这些发现可能会使设备在未来受到攻击，但在生产之前发现这些类型的问题要便宜得多。

2.  NSP 是一个很棒的 NodeJS 漏洞扫描工具。与 RetireJS 一样，NSP 可以通过调用`nsp`和 NodeJS 项目目录或`packages.json`的路径来执行，如下所示：

```
    $ nsp check /path/to/package.json 
    (+) 1 vulnerabilities found
    ┌───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
    │               │ Command Injection                                                                                                                                                                 │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Name          │ growl                                                                                                                                                                             │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ CVSS          │ 9.8 (Critical)                                                                                                                                                                    │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Installed     │ 1.1.0                                                                                                                                                                             │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Vulnerable    │ All                                                                                                                                                                               │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Patched       │ None                                                                                                                                                                              │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ Path          │ stylus@0.22.4 > growl@1.1.0                                                                                                                                                       │
    ├───────────────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    │ More Info     │ https://nodesecurity.io/advisories/146                                                                                                                                            │
    └───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘

```

NSP 发现了一个易受攻击的库，该库可能已将设备暴露于 IoT 中的一个常见漏洞。

3.  如果物联网设备的构建系统使用的是 Yocto，则可以使用免费的 LibScanner 工具查询 NVD 数据库，查看项目已安装软件包列表中的已知易受攻击库。要开始使用 LibScanner，请通过运行以下命令更新漏洞数据库：

```
$ ./download_xml.sh 

```

4.  更新 NVD 数据库后，对 Yocto`installed-packages.txt`文件运行 LibScanner，如下所示：

```
$ ./cli.py  --format yocto "path/to/installed-packages.txt" dbs/  > cve_results.xml 

```

5.  执行后，查看`cve_results.xml`文件，该文件不仅包含易受攻击文件的扫描结果，还包含 xUnit 格式的单元测试：

```
    $ cat cve_results.xml
    <failure> Medium (6.8) - Use-after-free vulnerability in libxml2 through 2.9.4, as used in Google Chrome before 52.0.2743.82, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the XPointer range-to function. 

     CVE Published on: 2016-07-23 https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-5131 </failure>
    </testcase>
    <testcase id="CVE-2016-9318" name="CVE-2016-9318" classname="libxml2 - 2.9.4" time="0">
    <failure> Medium (6.8) - libxml2 2.9.4 and earlier, as used in XMLSec 1.2.23 and earlier and other products, does not offer a flag directly indicating that the current document may be read but other files may not be opened, which makes it easier for remote attackers to conduct XML External Entity (XXE) attacks via a crafted document. 

     CVE Published on: 2016-11-15 https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-9318 </failure>
    </testcase>
    </testsuite>

```

有几种工具可以在设备生成之前执行静态任务，也可以在设备生成之后和设备运行时执行动态检查。在前面的章节中，已经讨论了动态工具，如用于 web 应用程序测试的 OWASP ZAP，以及可以直接在设备的命令行界面上运行的工具，如 Lynis。所有这些都加强了设备的安全态势，并最大限度地降低了对设备进行成功攻击的可能性。

在本章中，我们讨论了在构建和编写固件时要结合的几个最佳实践。建议根据您的操作系统平台（即嵌入式 Linux、RTOS、Windows 物联网等）对与您的物联网设备相关的特定安全控制进行尽职调查。