# 九、逆向工程与压力测试

如果你想知道恶意软件的行为，实现这一目标最简单的方法就是让它在你的网络中肆虐，并在野外跟踪它的行为。这不是您想要了解恶意软件行为的方式。您可能很容易错过一些您的网络环境无法实现的功能，现在您必须从网络中的所有计算机中删除恶意软件。Kali 有一些选定的工具可以帮助您完成这项工作。本章还介绍了 Windows 服务器或应用的压力测试。如果你想知道 DDoS 会让你的服务器崩溃多少，这是一个好主意。本章是如何利用抗脆弱、自我修复的 Windows 网络的开始。

本章将涵盖以下主题：

*   设置测试环境
*   逆向工程理论
*   使用布尔逻辑
*   实践逆向工程

    *   调试器
    *   拆卸
    *   杂项再工具

*   压力测试你的 Windows 机器

与 Kali Linux 1.x 中的工具相比，Kali Linux 2.0 中可用的反向工程工具有一些变化。一些工具已经从菜单结构中消失，如果您愿意，您可以使用本书[第 6 章](06.html#aid-1FLS42 "Chapter 6. Password Attacks")的最后一节*密码攻击*将它们放回原处。有些工具根本没有包含在 Kali Linux 2 中，尽管这里和那里都有它们的踪迹。下表显示了这些更改。

显示完整路径的工具根本不在默认的 Kali 2.0 菜单中，而 Metasploit 框架工具套件的一部分 NASM Shell 也不在 Kali 1.x 菜单中：

![Reverse Engineering and Stress Testing](../Images/image00965.jpeg)

# 设置测试环境

利用您的测试环境需要您测试的所有 Windows 操作系统的虚拟机示例。例如，应用利用人员可能正在运行非常旧的浏览器/操作系统测试机器，以查看运行仿古硬件的客户会遇到什么问题。在本例中，我们运行的是 Windows XP、Windows 7 和 Windows 10。我们正在使用 Oracle VirtualBox 进行桌面虚拟化，但如果您更喜欢使用 VMWare，请改用它。重要的是要使用可以与主网络隔离的机器，以防恶意软件按其应有的方式运行，并试图感染周围的机器。

## 创建您的受害者机器

如果您已经为其他目的设置了 Windows 虚拟机，您可以克隆它们（可能是最安全的）或从快照运行（设置速度最快）。这些机器在构建之后不应该能够访问主网络，并且您可能只应该将它们设置为与内部网络通信。

## 测试您的测试环境

1.  带上你的卡利 VM。
2.  确保您的 Kali 实例可以与 Internet 对话，以便于获取更新。
3.  确保您的 Kali 实例可以与主机通信。
4.  启动目标 Windows 实例。
5.  确保您的 Windows 受害者无法联系 Internet 或您的专用以太网 LAN，以避免恶意软件的意外传播。

我们测试网络上的三个虚拟机位于 Oracle VirtualBox 内的仅主机网络上。DHCP 由主机（`192.168.56.100`提供，三台测试网络机分别为`101`、`102`、`103`。

![Testing your testing environment](../Images/image00966.jpeg)

# 逆向工程理论

出于某种原因，理论吓坏了 IT 专业人士。这并不是真正的保证，因为理论是所有故障排除的基础。这可能是你在 X 年的艰苦尝试和错误中学到的公理。在定性研究领域，这被字面上称为扎根理论研究方法。逆向工程的基本理论是，输出推断应用的内部行为。当你面对一个恶意软件时，你将从以下几个方面开始做出工作假设：

*   从召回的与被认为类似的恶意软件的交互中获得的先验知识
*   概括与被测恶意软件交互的感知结果

### 提示

**黑客提示**

以*先验*的方式标记应用可能没有用。它可能会屏蔽数据，以便将“如果它像鸭子一样走路，像鸭子一样嘎嘎叫，那么它可能就是鸭子”的公理应用到应用中。特别是恶意软件，它的设计很可能包括一些欺骗功能，预计会让你走上错误的轨道。考虑木马和 rootkit，移除其他木马和 rootkit 作为他们的第一个任务。他们正在清理你的环境，但是，他们真的是你的朋友吗？

恶意软件应用旨在提供输入输出，但请注意，这些输出和输入并不能真正让您了解输出是如何实现的。输出可以用几种不同的方式生成，您可能会发现利用人员选择如何创建应用很重要。

## 一种逆向工程的一般理论

这一理论由 Lee 和 Johnson Laird 于 2013 年在《认知心理学杂志》上发表，对信息安全从业者很有用，因为它显示在布尔系统上。布尔系统是一个逻辑门。条件要么为真，要么为假。问题的一个非常常见的定义可能如下：

> *“任何要进行逆向工程的系统都包含有限数量的组件，这些组件一起工作，从而导致系统的行为。其中一些组件是可变的，也就是说，它们可以处于影响系统性能的多个不同状态，例如，数码相机上允许回放或擦除照片的设置。系统的其他部件没有变化，例如，从开关到灯泡的导线。系统有许多来自用户的不同输入和随后的输出，它们由有限数量的互连组件介导。在某些系统中，部件可能具有无限多个特定状态，例如不同的电压。但是，出于逆向工程的目的，我们假设所有可变组件都可以被视为具有有限数量的不同状态，即系统作为一个整体相当于一个有限状态自动机。换句话说，模拟系统可以数字化，如数码相机、CD 和其他以前的模拟设备。我们还假设设备是确定性的，尽管非确定性有限状态设备总是可以被确定性设备模拟（Lee&Johnson Laird，2013）。“*

Lee 和 Johnson-Laird 模型仅对可能的内部条件使用布尔内部模型，以揭示所注意到的行为。因为不可能测试无限多的输入，所以只测试可能的输入、输出和输出的子集更有用。我们可以从一个简单的例子开始，例如：

*   如果恶意软件登陆苹果平台，并被设计为利用 Windows 漏洞进行攻击，那么它很可能根本不会运行（开关 1）
*   如果它降落在 Windows 计算机上，但针对的是 XP 版本的漏洞，它可能会测试该操作系统版本，如果它发现自己在 Windows Server 2012 上，则什么也不做（开关 2）
*   如果它恰好是 Windows XP，但已针对所查找的漏洞进行了修补，则它也可能什么都不做（开关 3）
*   如果它降落在一台 Windows XP 计算机上，而该计算机上包含了该备受追捧的未修补漏洞，则会丢弃其有效负载

![One general theory of reverse engineering](../Images/image00967.jpeg)

# 使用布尔逻辑

计算机程序由**数据结构**组成，这些数据结构使用产生所需输出的条件和决策。这里我们将使用 Python 表示法，因为它很简单，您以前可能见过它。基本数据结构包括：

*   迭代器，如 while 循环和 for 循环。迭代器循环的次数与它被告知的次数相同，每次循环都运行其他命令
*   **决定点**如**If 结构**和**案例结构**等。前面的图像是一组嵌套的**If 结构**

    <colgroup><col></colgroup>
    | 

    的示意图布尔算子

     |  |
    | --- | --- |
    | **符号** | **说明** |
    | X==Y | X 相当于 Y 这并不总是一个数值集 |
    | X！=Y | X 不等于 Y |
    | X<=Y | X 小于或等于 Y |
    | X>=Y | X 大于或等于 Y |
    | X | X 小于 Y |
    | X>Y | X 大于 Y |

*   X 和 Y 都是真的
*   X 和 Y 都是假的
*   X 或 Y 都是真的
*   除了 X 什么都可以
*   除了 Y

    <colgroup><col><col></colgroup>
    | 

    之外的任何内容布尔变量

     |  |
    | --- | --- |
    | **变量** | **说明** |
    | 和 | 生成仅当所有元素均为真时才为真的布尔比较。 |
    | 或 | 如果任何元素为真，则生成布尔比较。 |
    | 不 | 生成一个布尔比较，该比较仅在所有元素都不为真时才为真。 |

下面的图像针对 NOT 布尔变量测试 X 的两个条件。您可能已经开始了解如何从许多不同的内部编码选择中提取输出。攻击者或原始攻击者可能通过多种条件中的任何一种来测试条件，因此您必须考虑获得输出的所有方法。

![Working with Boolean logic](../Images/image00968.jpeg)

## 回顾 while 循环结构

**while 循环**由真/假选择点显式启动和停止。这些可能看起来非常复杂，但它们解决了单一条件下的有限测试集。

```
X = 0
Y = 20
while (X != Y): print (X), X = X + 1
```

这个 Python3 循环将反复打印 X 的值，直到它达到 10，然后停止。如果我们说`while``X``<``Y`，它的工作原理是完全相同的，因为循环结构在递增时测试 X。对于递增元素使用随机数的更复杂循环可能会持续更长的时间（或者不会），然后随机命中与 Y 等价的 X 值。

![Reviewing a while loop structure](../Images/image00969.jpeg)

很明显程序每次都在测试循环条件。下面是一个使用该随机 X 值的示例。首先选择 X 值，然后运行两次`print``(X)`命令。因为 X 在第一行中只设置了一次，所以它在两个打印命令中没有更改。当重置 X 的值时，它会打印一个不同的值。条件是 X 不等于 Y。我们将 Y 的值设置为几行，因此不需要重置以运行此示例。X 只返回一次的原因是，在第二次返回时，X 被随机设置为 11。从随机抽奖中被设置为 11 的几率是 11 分之一，这比你赢得强力球彩票的几率大得多。

![Reviewing a while loop structure](../Images/image00970.jpeg)

如果我们再次运行循环，它可能会运行更多的次，因为它会随机避免一个等于 Y 的 X 值。再次，它不会打印`X``=``11`的值，因为 while 循环条件排除了这一点。

![Reviewing a while loop structure](../Images/image00971.jpeg)

## 回顾 for-loop 结构

**for 循环**不需要**递增器**，因为它将范围构建到条件中，而 while 循环只包含一个限制，超过该限制，循环将不会运行。使用 Python 表示法，下图显示了当 X 值为 0 且范围为 1 到 11 时发生的情况。X 的预设值对于 while 循环迭代并不重要。它将所有值应用于它测试的 X。

![Reviewing the for loop structure](../Images/image00972.jpeg)

我们将从 X 设置为 100 开始，但是 for 循环从其自身条件中获取 X 值。

![Reviewing the for loop structure](../Images/image00973.jpeg)

如果确实希望 X 保持不变，可以将其用作不同范围的基础，如下图所示。

![Reviewing the for loop structure](../Images/image00974.jpeg)

### 了解决策点

**If 结构**是二元决策：是或否。墙上上的灯开关是 If 结构的物理示例。如果开关处于一个位置，则指示灯点亮，如果开关处于另一个位置，则指示灯熄灭：

![Understanding the decision points](../Images/image00975.jpeg)

**案例结构**是一种决策结构，具有多个“正确答案”、多个“是”，而不是单个“否”。这方面的一个例子可能是有三种口味的冰淇淋分配器，巧克力、草莓和香草。如果你不想要冰激凌，你甚至不需要接近机器。您有三种选择，它们都是正确的：

![Understanding the decision points](../Images/image00976.jpeg)

# 实践逆向工程

由于知道输入和输出不能保证为您提供想要进行反向工程的应用的内部构造的真实情况，因此让我们来看一些来自 Kali Linux 的有用实用程序，它们可能会使反向工程变得更简单。我们将介绍三个**调试器**、一个**拆卸**工具和一个杂项逆向工程工具。

我们将展示两个基于 Linux 的调试器 Valgrind 和 EDB Debugger 的使用情况和输出，然后展示仅限 Windows 的调试器 OllyDbg 的类似输出。

反汇编程序是 JAD，一个 Java 反编译器。

![Practicing reverse engineering](../Images/image00977.jpeg)

## 揭开调试器的神秘面纱

什么是调试？创造这一术语的荣誉常常被错误地归因于格雷斯·霍珀上将，当时她的团队成员发现一只物理（但已死亡）的蛾子卡在哈佛大学马克 II 计算机的继电器中。这个术语实际上可能来自托马斯·爱迪生（Thomas Edison），正如他所提到的，并将其定义为“……小错误和困难……”在软件利用中，bug 通常是逻辑错误，而不是代码中的印刷错误。输入错误通常会阻止代码编译，因此它们不会离开利用人员的实验室。逻辑错误不会阻止程序编译，但它们可能会导致输出失败或程序启动时出现意外行为。另一个常用于**bug**的同义词是**缺陷**。项目中的**技术债务**是指项目中未修复的缺陷数量。不同的项目经理对未修复的 bug 有不同的容忍度。许多恶意软件包在其发布的版本中都有一些显示停止错误，但最近一些更复杂的恶意软件包似乎技术债务非常低。

调试器允许您逐步观察应用的行为。您可以看到内存中放入了什么，进行了哪些系统调用，以及应用如何提取和释放内存。我们使用调试器的主要原因是检查我们可以访问源代码的程序的行为。原因是我们最有可能调试的程序都是在我们自己的工作室中编写的代码。这并不完全构成一个代码安全审计，但它可以帮助发现程序在哪里泄漏内存，以及它清理已用内存的效果如何。如果以这种方式启动，许多程序会在命令行上显示状态报告，这些报告是内部调试信息。这可以在应用发布后进行清理，但在大多数用例中，最终用户从未看到过任何内容。

### 使用 Valgrind 调试器发现内存泄漏

程序通常从可用的总 RAM 中保留内存。我们发现在命令行上调试有用的一个程序是 Valgrind，它不在默认的 Kali 安装中。当我们发现需要进行初步调试时，我们会添加它。例如，曾经有一个版本的 OpenOffice.org，免费的开源办公套件。Linux 中存在允许安装的错误，但无法运行程序。它只是在最初的启动屏幕显示时突然出现。运行以下命令表明它正在查找一个不存在的文件。我们不只是发送一个 bug 报告，并希望将一个解决方案作为补丁添加到源代码中，而是将缺少的文件作为一个空白文本文件添加。这允许 OpenOffice.org 启动。org 利用人员后来添加了一个补丁，删除了这个 bug，但我们不必等待。

作为 Valgrind 的一个示例，以下是在文本编辑器 gedit 上运行测试的命令行代码：

```
valgrind -v --log-file="gedit-test.txt" gedit

```

当程序被封装在调试器中时，启动程序需要更长的时间，并且整个输出将进入指定的日志文件。一旦程序打开，您可以通过在命令行上键入`[CTRL][C]`来关闭程序，或者如果正在测试的应用具有 GUI 界面，您可以关闭窗口，并且 Valgrind 将在看到正在测试的应用关闭后关闭。在本例中，调试器有 600 多行输出，您需要使用更友好的调试器来查找更多有用的信息。请记住，gedit 是一个非常成熟的程序，每次我们使用它编辑文本文件时，它都能完美地工作。Valgrind 在打开 gedit、键入几个字符和关闭而不保存新文档这一简单用例中指出，它仍然有 24 个内存错误。

![Using the Valgrind Debugger to discover memory leaks](../Images/image00978.jpeg)

### 使用 EDB 调试器将应用转换为汇编程序

EDB 调试器是一个名为 Olly 调试器的 Windows 应用版本。EDB 调试器具有以下功能：

*   利用人员称之为直观的 GUI 界面
*   标准调试操作（步进/步过/运行/中断）
*   更不寻常的条件断点
*   作为插件实现的调试核心（您可以插入替换核心插件）
*   某些平台可能有几个可用的调试 API，在这种情况下，您可能有一个插件来实现其中的任何一个
*   基础教学分析
*   查看/转储内存区域
*   有效地址检查
*   数据转储视图是选项卡式的，允许您同时打开多个内存视图，并在它们之间快速切换
*   它允许导入和生成符号映射
*   扩展可用性的插件

EDB Debugger 设计用于调试 Linux 应用，我们将使用 EDB Debugger 查看同一个应用 gedit。GUI 界面如下所示：

![Translating your app to assembler with the EDB-Debugger](../Images/image00979.jpeg)

以下是您所看到的内容：

1.  正在测试的应用，以及标题栏中的进程 ID
2.  内存位置
3.  命令
4.  通用二进制命令映射
5.  书签–代码中的兴趣点
6.  为数据预留的寄存器（特别是 2/3 中的标记行）
7.  数据转储–内存位置和内容
8.  内存栈数据

### EDB 调试器符号映射器

EDB 调试器可以通过命令行条目为您提供符号映射：

```
edb --symbols /usr/bin/gedit > gedit.map
```

符号表映射程序中的函数、行或变量。对于 gedit，符号表如下所示：

![EDB-Debugger symbol mapper](../Images/image00980.jpeg)

### 运行 OllyDbg

如果您正在运行 64 位版本的 Kali Linux 2.0，您首先需要更新 Kali。它缺少 32 位的 wine 基础设施，wine 甚至不想在没有它的情况下启动。幸运的是，Kali Linux 提供了一条有用的错误消息。您只需复制错误消息的引用部分并运行它。

![Running OllyDbg](../Images/image00981.jpeg)

OllyDbg GUI 窗口看起来确实很像 EDB 调试器，尽管它在图形上有点难看。我们正在研究`notepad.exe`，它是一个仅限 Windows 的编辑器，类似于 gedit 的精简版。该窗口分为以下几个部分：

1.  正在标题栏中测试的应用
2.  内存位置
3.  符号映射
4.  命令
5.  登记册
6.  数据转储–内存位置和内容
7.  内存堆栈数据

打开可执行文件（EXE、PIF 或 COM）时，它会显示整个正在运行的程序。

![Running OllyDbg](../Images/image00982.jpeg)

您可以选择在目标 Windows 计算机上运行 OllyDbg，通过将文件夹复制到闪存驱动器并将闪存驱动器带到受感染的计算机上，查看正在进行的感染。您还可以将 Kali Linux 安装到可引导闪存驱动器上，正如我们在[第 1 章](01.html#aid-F8902 "Chapter 1. Sharpening the Saw")、*磨锯*中提到的，并直接在受感染的机器上运行 Kali。

## 拆装机简介

反汇编程序获取已编译的二进制代码并显示汇编代码。这与调试器可以显示的内容类似。

### 正在运行的 JAD

**JAD**是 Kali Linux 附带的 Java 反编译器，它似乎是分析来自网页的潜在危险 Java 小程序的有用工具。它最大的问题是自 2011 年以来一直没有维护人员，因此很难找到，除了在 Kali 存储库中，以及在 Tomas Varaneckas 的博客页面上的在[上的*Jad 反编译程序下载镜像*http://varaneckas.com/jad/](http://varaneckas.com/jad/) 。

以下是 JAD 帮助文件中的一个页面，您可以从主菜单或在命令行中键入`jad`来访问该页面。

![Running JAD](../Images/image00983.jpeg)

作为使用 JAD 的一个简短示例，我们为您创建了一个 Java 类。下面三幅插图是：

1.  原始源代码（并非始终可用）
2.  运行 JAD
3.  反编译源

下面是一个小 Java 类的源代码，它将一些静态内容打印到命令行标准输出：

![Running JAD](../Images/image00984.jpeg)

在应用运行时，我们显示了使用内联帮助（键入问号而不是字母选项）的结果，以显示可用的详细程度。然后我们选择了`a`，JAD 重写了源代码。当您只有已编译的类时，这不会是一个问题。

![Running JAD](../Images/image00985.jpeg)

最后，这里是反编译的源代码。

![Running JAD](../Images/image00986.jpeg)

### 使用 Capstone 创建自己的反汇编代码

**顶点**反编译发动机维护良好，API 简单。基本的 Capstone 库在 Kali Linux 上是默认的，您可以使用您熟悉的任何语言构建自己的前端。我们正在使用 Python，因为它是我们的脚本语言。使用智能搜索<关键字>命令结构，您可以确保您有可用的软件包，并可以查看软件包的状态。在本例中，您可以看到第一列中的“p”表示有可用的软件包，“i”表示已安装。第二列中的“A”表示该软件包是自动安装的，可能是其他软件包的依赖项。我们选择在 Kali 实例上安装 64 位体系结构的 libcapstone dev，以防我们想要定制 Capstone 的行为。你不需要这样做来使用顶点。

![Create your own disassembling code with Capstone](../Images/image00987.jpeg)

下面是一个基于[中示例的简单反汇编脚本 http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html) 。这可能更加自动化，但是例如，十六进制代码是硬编码到脚本中的。

![Create your own disassembling code with Capstone](../Images/image00988.jpeg)

## 一些杂项逆向工程工具

在 Kali Linux 1.x 菜单中列出了大量的类杂项逆向工程工具，但在 Kali Linux 2.0 菜单中没有分类。我们将向您展示一套由 Radare2 领导的集成工具，而不是随机挑选其中的几个。

### 正在运行的雷达 2

您可以点击**逆向工程**下的菜单链接启动 Radare2。现在您可能更熟悉命令行，因此您可能希望直接在命令行中打开它。通过键入键盘快捷键*ALT*+*F2*打开命令行启动器。然后，以下命令在新的终端窗口中打开程序的帮助文件：

```
bash -c "radare2 -h" #  this makes sure that you are opening the bash shell
#  rather than some other possible default shell
#  like the dash shell

```

要为您分解此命令，请执行以下操作：

*   `bash`打开**bash**外壳
*   -c 指示 dash 从命令字符串中读取，该字符串以双引号跟随，而不是等待键盘的标准输入
*   radare2 是我们正在打开的应用
*   `-h`是在终端窗口中打开帮助文件的选项，如果存在的话`--help`是该选项的长格式（几乎每个 Linux 命令行工具都有这些选项）

**Radare2**是一款高级命令行十六进制编辑器、反汇编程序和调试器。雷达 2（[http://radare.org](http://radare.org) 表示 Radare2 是一种便携式倒车框架。

![Running Radare2](../Images/image00989.jpeg)

Radare2 是集成了 10 个插件和其他几个应用的框架的尖端。为了保持 PG 评级，我们模糊了最后一个插件名。

![Running Radare2](../Images/image00990.jpeg)

## 雷达 2 工具套件的其他成员

如果不是整本书的话，Radare2 套件真的应该有自己的章节。我们必须提到本套件中提供的一些其他有用工具：

*   rasm2
*   拉哈什 2
*   半径 2
*   拉芬 2
*   rax2

### 运行 rasm2

`Rasm2``/usr/bin/rasm2`是多个架构的命令行汇编/反汇编程序；例如，英特尔 x86 和 x86-64、MIPS、ARM、PowerPC、Java 和 MSIL。当 JAD 不再可用时，这可能是您拆卸的目标。

![Running rasm2](../Images/image00991.jpeg)

### 正在运行的 rahash2

Rahash2（`/usr/bin/rahash`是一个基于块的哈希工具，支持多种算法；对于 Ty1 T1，例如 MD4、MD5、CRC16、CRC32、Sa1、Sa256、Saa34、Sa512、PAR、XOR、XORION、MOD255、HAMDIST 或 ORD T2 熵。您可以使用 rahash2 检查文件、内存转储和磁盘的完整性，并跟踪其更改。

![Running rahash2](../Images/image00992.jpeg)

下面是一个测试小文件的 sha256 哈希的示例。

![Running rahash2](../Images/image00993.jpeg)

### 运行半径 f2

**Radiff2**是一个二进制实用程序，它使用各种算法比较文件。它支持二进制文件的字节级或增量比较，以及代码分析比较，以查找 radare 代码分析生成的代码块中的更改。以下是在几秒钟内比较`/var/log/`消息日志两种状态的测试。这是位级别的比较，用于随机更改。

![Running radiff2](../Images/image00994.jpeg)

### 正在运行的 rafind2

**Rafind2**是设计用于搜索文件中的模式。在下面的示例中，`rafind2``-s``"<string``searched>"``<file>`显示了我们在搜索已知存在且已知不存在的字符串时看到的内容。

![Running rafind2](../Images/image00995.jpeg)

### 运行 rax2

**Rax2**是命令行的数学表达式求值器。您可以执行许多转换操作，这些操作对于在浮点值、十六进制表示、十六进制对字符串到 ASCII、八进制到整数等之间进行基转换非常有用。它还支持 endianness 设置，如果未提供参数，则可以用作交互式 shell。

![Running rax2](../Images/image00996.jpeg)

使用 rax2 的一些示例转换包括：

*   十进制到十六进制
*   十六进制到十进制
*   八进制到十六进制
*   散列两个字符串
*   散列单个字符串

![Running rax2](../Images/image00997.jpeg)

# 压力测试窗口

在 Kali 1.x 中，压力测试是一个开放的话题，但在 Kali 2.0 中，压力测试已经从主菜单中取消。Kali 1.x 中的两个工具 DHCPig 和 inumdator 不见了，但是在 2.0 工具箱中找到一组好的工具应该不会有问题。

![Stresstesting Windows](../Images/image00998.jpeg)

## 应对否认

ATK6-Denial6 是一个 IPv6 网络压力测试仪，它向目标主机发送数据包，并将其提交。第一个插图是 ATK6-Denial6 的帮助文件。

![Dealing with Denial](../Images/image00999.jpeg)

下一幅图是易受攻击的 Windows 7 目标机器的 nmap`-a`读数。我们想知道它是否有开放的端口，以及它们是哪些端口。我们可以看到，`139`、`445`、`2869`、`5357`和`10243`端口是开放的。这个工具的最大问题是测试网络是 IPv4。

![Dealing with Denial](../Images/image01000.jpeg)

让我们找到一个可以攻击 IPv4 网络的工具。

## 围攻网络

围城是一个网络压力测试仪。这是一个多线程 HTTP 负载测试和基准测试实用程序，可以显示 web 应用如何响应 ridiculoud 负载。您可以配置该工具以模拟硬件支持的尽可能多的用户。正是这些用户将 web 服务器置于“围城”之下。输出详细说明了性能，因此您可以真正深入了解应用的弱点。绩效指标包括以下内容，在每次运行结束时进行量化和报告。它们的含义和意义在下文中讨论。围城基本上有三种作战模式：

*   回归（被轰炸调用时）
*   网络模拟
*   蛮力

使用围城的格式如下：

*   `siege``[options]`
*   `siege``[options]``[url]`
*   `siege``-g``[url]`

![Putting the network under Siege](../Images/image01001.jpeg)

围城模拟了 15 名用户在 Windows7 目标机器上访问该网站。总的来说，演出并没有那么糟糕。在四分钟半的时间里，该网站有 8072 次点击。Windows 7 目标保持了 100%的可用性，响应时间超过了 1/100 秒。

## 配置攻城引擎

如果我们把围攻人数增加到 10000，你认为会发生什么？配置在`/usr/bin/siege.config`处。当我们在命令行上运行它时，它告诉我们在`/root/siegerc`上已经有一个本地配置文件，所以让我们来看一下：

![Configuring your Siege engine](../Images/image01002.jpeg)

要编辑`/root/.siegerc`，我们可以使用命令行或 gnome 启动器*Alt*+*F2*进入 gedit`/root/.siegerc`，或者我们可以在常用应用附件文件夹中找到 gedit，打开文件，打开对话框并打开隐藏文件，然后在`/root`目录中找到`.siegerc`。您可能已经开始了解 Linux 管理员如此喜欢命令行的原因。

在配置文件的第 162 行，您将找到并发用户的数量。当前默认值为 15，但我们将其更改为 10000。让我们看看能不能搞定这个孩子。

![Configuring your Siege engine](../Images/image01003.jpeg)

在强制关闭 Kali 实例之后，让我们用更少的围攻者来尝试它。并发用户的数量越多，您的 Kali 机器上使用的 RAM 也越多。

![Configuring your Siege engine](../Images/image01004.jpeg)

使用 625 围攻者，我们在不撞坏试验机的情况下获得了可靠的结果。在这期间，我们测试了 5000、2500 和 1250 台，但它们都使机器崩溃。如果你有乐趣，你可以测试更高的数字，比如 940、1090 等等。测试机上可用的资源将决定你可以雇佣多少围攻者。

# 总结

对于复杂应用的实际代码，不太可能通过逆向工程获得明确的答案，因为有许多方法可以从循环或选择结构中获得相同的输出。通过测试几个输入，更容易得到输入可能处理的统计列表。通过查看**EDB 调试器**或**OllyDbg**的汇编代码输出，您可能会获得更多详细信息。正如您可能注意到的，Linux 和 Windows 应用的汇编代码基本相同。高级语言（如 TyT4、C、C、T5、T5）和“T+6”、“C++”、“T7”这两种方法都是指汇编代码，可以很容易地转换成机器代码来告诉机器该怎么做。

测试 Windows 主机的压力归结为检查它们在短时间内在任何打开的端口上接收许多输入的能力。记住，当压力测试时，你会在网络上制造大量噪音，任何配置正确的入侵检测工具都会注意到你的攻击。您还可能使目标计算机脱离网络，因此您最好在开始测试之前通知管理层。