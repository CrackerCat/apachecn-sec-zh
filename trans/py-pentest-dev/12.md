# 第二章扫描测试

网络扫描指的是一组过程，用于调查活动主机、主机类型、打开的端口以及主机上运行的服务类型。网络扫描是情报收集的一部分，通过它，攻击可以创建目标组织的个人资料。

在本章中，我们将介绍以下主题：

*   如何检查实时系统
*   平扫
*   TCP 扫描器
*   如何创建高效的 IP 扫描程序
*   在目标计算机上运行的服务
*   端口扫描仪的概念
*   如何创建高效的端口扫描程序

您应该具备 TCP/IP 层通信的基本知识。在继续之前，**协议数据单元**（**PDU**的概念应该清楚。

PDU 是协议中指定的数据单元。它是各层数据的通用术语。

*   对于应用层，PDU 表示数据
*   对于传输层，PDU 表示一个段
*   对于 Internet 或网络层，PDU 表示数据包
*   对于数据链路层或网络访问层，PDU 表示帧
*   对于物理层，即物理传输，PDU 指示位

# 如何检查网络中的带电系统以及带电系统的概念

Ping 扫描涉及向主机发送**ICMP 回送请求**。如果主机处于活动状态，则会返回一个**ICMP 回显回复**，如下图所示：

![How to check live systems in a network and the concept of a live system](graphics/8583OT_02_01.jpg)

ICMP 请求和回复

操作系统的`ping`命令提供了检查主机是否处于活动状态的工具。考虑一种情况，您必须测试 IP 地址的完整列表。在这种情况下，如果您逐个测试 IP，将需要大量的时间和精力。为了处理这种情况，我们使用 ping-sweep。

## 平扫

Ping 扫描用于通过发送 ICMP 回显请求和 ICMP 回显回复，从一系列 IP 地址中识别活动的主机。攻击者或 pentester 可以根据子网和网络地址计算网络范围。在本节中，我将演示如何利用操作系统的 ping 功能。

首先，我将编写一段简单的代码，如下所示：

```
import os
response = os.popen('ping -n 1 10.0.0.1')
for line in response.readlines():
print line,
```

在前面的代码中，`import os`导入 OS 模块，以便我们可以运行 OS 命令。接受 DOS 命令的下一行`os.popen('ping -n 1 10.0.0.1')`作为字符串传入，并返回一个与命令的标准输入或输出流连接的类似文件的对象。`ping –n 1 10.0.0.1`命令是一个 Windows 操作系统命令，发送一个 ICMP 回显请求数据包。通过读取`os.psopen()`函数，可以截获命令的输出。输出存储在`response`变量中。在下一行中，`readlines()`函数用于读取类似文件的对象的输出。

程序的输出如下：

```
G:\Project Snake\Chapter 2\ip>ips.py

Pinging 10.0.0.1 with 32 bytes of data:
Reply from 10.0.0.1: bytes=32 time=3ms TTL=64

Ping statistics for 10.0.0.1:
 Packets: Sent = 1, Received = 1, Lost = 0 (0% loss),
Approximate round trip times in milli-seconds:
 Minimum = 3ms, Maximum = 3ms, Average = 3ms

```

输出显示`reply`、`byte`、`time`和`TTL`值，表示主机处于活动状态。考虑 IP 输出 T4 的程序的另一个输出。

```
G:\Project Snake\Chapter 2\ip>ips.py
Pinging 10.0.0.2 with 32 bytes of data:
Reply from 10.0.0.16: Destination host unreachable.

Ping statistics for 10.0.0.2:
 Packets: Sent = 1, Received = 1, Lost = 0 (0% loss),

```

前面的输出显示主机不是活动的。

上述代码对于正常工作非常重要，与汽车发动机类似。为了使其功能全面，我们需要修改代码，使其独立于平台，并生成易于阅读的输出。

我希望我的代码适用于一系列 IP：

```
import os
net = raw_input("Enter the Network Address ")
net1= net.split('.')
print net1
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
print net2
st1 = int(raw_input("Enter the Starting Number "))
en1 = int(raw_input("Enter the Last Number "))
```

前面的代码要求提供子网的网络地址，但您可以提供子网的任何 IP 地址。下一行`net1= net.split('.')`将 IP 地址分为四部分。`net2 = net1[0]+a+net1[1]+a+net1[2]+a`语句构成网络地址。最后两行要求提供一系列 IP 地址。

要使 it 平台独立，请使用以下代码：

```
import os
import platform
oper = platform.system()
if (oper=="Windows"):
  ping1 = "ping -n 1 "
elif (oper== "Linux"):
  ping1 = "ping -c 1 "
else :
  ping1 = "ping -c 1 "  
```

前面的代码确定代码是在 Windows 操作系统上运行还是在 Linux 平台上运行。`oper = platform.system()`语句将此通知正在运行的操作系统，因为`ping`命令在 Windows 和 Linux 中不同。Windows 操作系统使用`ping –n 1`发送 ICMP 回显请求的一个数据包，而 Linux 使用`ping –c 1`。

现在，让我们看看以下完整代码：

```
import os
import platform
from datetime import datetime
net = raw_input("Enter the Network Address ")
net1= net.split('.')
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
st1 = int(raw_input("Enter the Starting Number "))
en1 = int(raw_input("Enter the Last Number "))
en1=en1+1
oper = platform.system()

if (oper=="Windows"):
  ping1 = "ping -n 1 "
elif (oper== "Linux"):
  ping1 = "ping -c 1 "
else :
  ping1 = "ping -c 1 "
t1= datetime.now()
print "Scanning in Progress"
for ip in xrange(st1,en1):
  addr = net2+str(ip)
  comm = ping1+addr
  response = os.popen(comm)
  for line in response.readlines():
    if(line.count("TTL")):
      break
    if (line.count("TTL")):
      print addr, "--> Live"

t2= datetime.now()
total =t2-t1
print "scanning complete in " , total
```

在这里，前面的代码中有一些新的东西。`for ip in xrange(st1,en1):`语句提供数字值，即 IP 地址的最后一个八位字节值。在循环中，`addr = net2+str(ip)`语句使其成为一个完整的 IP 地址，`comm = ping1+addr`语句使其成为传递给`os.popen(comm)`的完整 OS 命令。`if(line.count("TTL")):`语句检查行中是否出现`TTL`。如果在该行中找到任何`TTL`值，则使用`break`语句中断该行的进一步处理。接下来的两行代码将 IP 地址打印为 live，其中找到了`TTL`。我用`datetime.now()`来计算扫描的总时间。

`ping_sweep.py`程序的输出如下：

```
G:\Project Snake\Chapter 2\ip>python ping_sweep.py
Enter the Network Address 10.0.0.1
Enter the Starting Number 1
Enter the Last Number 60
Scanning in Progress
10.0.0.1 --> Live
10.0.0.2 --> Live
10.0.0.5 --> Live
10.0.0.6 --> Live
10.0.0.7 --> Live
10.0.0.8 --> Live
10.0.0.9 --> Live
10.0.0.10 --> Live
10.0.0.11 --> Live
scanning complete in  0:02:35.230000

```

要扫描 60 个 IP 地址，程序需要 2 分 35 秒。

## TCP 扫描概念及其使用 Python 脚本的实现

Ping sweep 在 ICMP 回送请求和 ICMP 回送回复上起作用。许多用户关闭 ICMP 回送回复功能或使用防火墙阻止 ICMP 数据包。在这种情况下，ping 扫描扫描仪可能无法工作。在这种情况下，需要进行 TCP 扫描。我希望您熟悉三方握手，如下图所示：

![The TCP scan concept and its implementation using a Python script](graphics/8583OT_02_02.jpg)

为了建立连接，主机执行三方握手。建立 TCP 连接的三个步骤如下：

1.  客户端发送带有**SYN**标志的段；这意味着客户端请求服务器启动会话。
2.  服务器以应答的形式发送包含**ACK**和**SYN**标志的段。
3.  客户端以**确认**标志进行响应。

现在，让我们看一下 TCP 扫描的以下代码：

```
import socket 
from datetime import datetime
net= raw_input("Enter the IP address ")
net1= net.split('.')
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
st1 = int(raw_input("Enter the Starting Number "))
en1 = int(raw_input("Enter the Last Number "))
en1=en1+1
t1= datetime.now()
def scan(addr):
  sock= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
  socket.setdefaulttimeout(1)
  result = sock.connect_ex((addr,135))
  if result==0:
    return 1
  else :
    return 0

def run1():
  for ip in xrange(st1,en1):
    addr = net2+str(ip)
    if (scan(addr)):
      print addr , "is live"

run1()
t2= datetime.now()
total =t2-t1
print "scanning complete in " , total
```

前面的代码的上半部分与前面的代码相同。这里，我们使用两个函数。首先，`scan(addr)`函数使用了[第 1 章](11.html "Chapter 1. Python with Penetration Testing and Networking")、*Python 中讨论的套接字，具有渗透测试和联网功能*。`result = sock.connect_ex((addr,135))`语句返回一个错误指示符。如果操作成功，错误指示灯为 0，否则为`errno`变量的值。这里，我们使用了端口`135`；此扫描仪适用于 Windows 系统。有些端口，如 137、138、139（NetBIOS 名称服务）和 445（Microsoft DSActive Directory），通常是打开的。因此，为了获得更好的结果，您必须更改端口并重复扫描。

`iptcpscan.py`程序的输出如下：

```
G:\Project Snake\Chapter 2\ip>python iptcpscan.py
Enter the IP address 10.0.0.1
Enter the Starting Number 1
Enter the Last Number 60
10.0.0.8 is live
10.0.0.11 is live
10.0.0.12 is live
10.0.0.15 is live
scanning complete in  0:00:57.415000

G:\Project Snake\Chapter 2\ip>

```

让我们更改端口号，使用`137`，并查看以下输出：

```
G:\Project Snake\Chapter 2\ip>python iptcpscan.py
Enter the IP address 10.0.0.1
Enter the Starting Number 1
Enter the Last Number 60
scanning complete in  0:01:00.027000
G:\Project Snake\Chapter 2\ip>

```

因此，该端口号不会产生结果。更改端口号，使用`445`，输出如下：

```
G:\Project Snake\Chapter 2\ip>python iptcpscan.py
Enter the IP address 10.0.0.1
Enter the Starting Number 1
Enter the Last Number 60
10.0.0.5 is live
10.0.0.13 is live
scanning complete in  0:00:58.369000

G:\Project Snake\Chapter 2\ip>

```

前面三个输出显示`10.0.0.5`、`10.0.0.8`、`10.0.0.11`、`10.0.0.12`、`10.0.0.13`和`10.0.0.15`处于活动状态。这些 IP 地址在 Windows 操作系统上运行。因此，这是一个用于检查 Linux 的公共开放端口并使 IP 成为完整的 IP TCP 扫描程序的练习。

## 如何创建高效的 IP 扫描器

到目前为止，您已经看到了 ping 扫描扫描程序和 IP-TCP 扫描程序。想象一下，你买了一辆拥有所有设施的车，但是速度很慢，你会觉得这是浪费时间。当我们的程序执行非常慢时，也会发生同样的事情。为了扫描 60 台主机，`ping_sweep.py`程序花了 2 分钟 35 秒，而 TCP 扫描程序花了将近一分钟的时间扫描相同范围的 IP 地址。他们花了很多时间来产生结果。但别担心。Python 为您提供了多线程，这将使您的程序更快。

我已经编写了一个带有多线程的 ping-sweep 完整程序，并将向您详细解释：

```
import os
import collections
import platform
import socket, subprocess,sys
import threading
from datetime import datetime
''' section 1 '''

net = raw_input("Enter the Network Address ")
net1= net.split('.')
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
st1 = int(raw_input("Enter the Starting Number "))
en1 = int(raw_input("Enter the Last Number "))
en1 =en1+1
dic = collections.OrderedDict()
oper = platform.system()

if (oper=="Windows"):
  ping1 = "ping -n 1 "
elif (oper== "Linux"):
  ping1 = "ping -c 1 "
else :
  ping1 = "ping -c 1 "
t1= datetime.now()
'''section 2'''
class myThread (threading.Thread):
  def __init__(self,st,en):
    threading.Thread.__init__(self)
    self.st = st
    self.en = en
  def run(self):
    run1(self.st,self.en)
'''section 3'''		
def run1(st1,en1):
  #print "Scanning in Progess"
  for ip in xrange(st1,en1):
    #print ".",
    addr = net2+str(ip)
    comm = ping1+addr
    response = os.popen(comm)
    for line in response.readlines():
      if(line.count("TTL")):
        break
    if (line.count("TTL")):
      #print addr, "--> Live"
      dic[ip]= addr
''' Section 4  '''
total_ip =en1-st1
tn =20  # number of ip handled by one thread
total_thread = total_ip/tn
total_thread=total_thread+1
threads= []
try:
  for i in xrange(total_thread):
    en = st1+tn
    if(en >en1):
      en =en1
    thread = myThread(st1,en)
    thread.start()
    threads.append(thread)
    st1 =en
except:
  print "Error: unable to start thread"
print "\t
Number of Threads active:", threading.activeCount()

for t in threads:
  t.join()
print "Exiting Main Thread"
dict = collections.OrderedDict(sorted(dic.items()))
for key in dict:
  print dict[key],"-->" "Live"
t2= datetime.now()
total =t2-t1
print "scanning complete in " , total
```

`section 1`部分与上一程序相同。这里还有一件事是，我使用了一个有序字典，因为它记住了内容添加的顺序。因此，如果您想知道哪个线程首先给出输出，那么有序字典适合这里。`section 2`部分包含线程类，`class myThread (threading.Thread):`语句初始化线程类。`self.st = st`和`self.en = en`语句取 IP 地址的起始和结束范围。`section 3`部分包含`run1`函数的定义，该函数是汽车的引擎，每个线程使用不同的 IP 地址范围调用该函数。`dic[ip]= addr`语句将主机 ID 存储为密钥，将 IP 地址存储为有序字典中的值。`section 4`语句在本规范中是全新的；`total_ip`变量是要扫描的 IP 总数。`tn =20`变量的意义在于，它表示一个线程将扫描 20 个 IP。`total_thread`变量包含需要扫描`total_ip`的线程总数，表示 IP 的数量。`threads= []`语句创建一个空列表，用于存储线程。`for`循环`for i in xrange(total_thread):`产生线程。

```
en = st1+tn
  if(en >en1):
    en =en1
  thread = myThread(st1,en)
  thread.start()
  st1 =en
```

前面的代码生成的 IP 范围为 20-20，例如 st1-20、20-40……-en1。`thread = myThread(st1,en)`语句是 threading 类的 thread 对象。

```
for t in threads:
  t.join()
```

前面的代码终止所有线程。下一行`dict = collections.OrderedDict(sorted(dic.items()))`创建一个新的排序字典`dict`**，其中按顺序包含 IP 地址。下一行按顺序打印实时 IP。`threading.activeCount()`语句显示产生了多少线程。一张图片可以节省 1000 字。下图也做了同样的事情：**

 **![How to create an efficient IP scanner](graphics/8583OT_02_03.jpg)

创建和处理线程

`ping_sweep_th_.py`程序的输出如下：

```
G:\Project Snake\Chapter 2\ip>python ping_sweep_th.py
Enter the Network Address 10.0.0.1
Enter the Starting Number 1
Enter the Last Number 60
 Number of Threads active: 4
Exiting Main Thread
10.0.0.1 -->Live
10.0.0.2 -->Live
10.0.0.5 -->Live
10.0.0.6 -->Live
10.0.0.10 -->Live
10.0.0.13 -->Live
scanning complete in  0:01:11.817000

```

扫描已在 1 分 11 秒内完成。作为练习，更改`tn`变量的值，将其从`2`设置为`30`，然后研究结果，找出`tn`的最合适和最佳值。

到目前为止，您已经看到 ping 通过多线程进行扫描；现在，我已经用 TCP 扫描方法编写了一个多线程程序：

```
import threading
import time
import socket, subprocess,sys
import thread
import collections
from datetime import datetime
'''section 1''' 
net = raw_input("Enter the Network Address ")
st1 = int(raw_input("Enter the starting Number  "))
en1 = int(raw_input("Enter the last Number "))
en1=en1+1
dic = collections.OrderedDict()
net1= net.split('.')
a = '.'
net2 = net1[0]+a+net1[1]+a+net1[2]+a
t1= datetime.now()
'''section 2'''
class myThread (threading.Thread):
  def __init__(self,st,en):
    threading.Thread.__init__(self)
    self.st = st
    self.en = en
  def run(self):
    run1(self.st,self.en)

'''section 3'''
def scan(addr):
  sock= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
  socket.setdefaulttimeout(1)
  result = sock.connect_ex((addr,135))
  if result==0:
    sock.close()
    return 1
  else :
    sock.close()

def run1(st1,en1):
  for ip in xrange(st1,en1):
    addr = net2+str(ip)
    if scan(addr):
      dic[ip]= addr
'''section 4'''
total_ip =en1-st1
tn =20  # number of ip handled by one thread
total_thread = total_ip/tn
total_thread=total_thread+1
threads= []
try:
  for i in xrange(total_thread):
    #print "i is ",i
    en = st1+tn
    if(en >en1):
      en =en1
    thread = myThread(st1,en)
    thread.start()
    threads.append(thread)
    st1 =en
except:
  print "Error: unable to start thread"
print "\t Number of Threads active:", threading.activeCount()
for t in threads:
  t.join()
print "Exiting Main Thread"
dict = collections.OrderedDict(sorted(dic.items()))
for key in dict:
  print dict[key],"-->" "Live"
t2= datetime.now()
total =t2-t1
print "scanning complete in " , total
```

理解这个程序应该没有什么困难。下图显示了所有内容：

![How to create an efficient IP scanner](graphics/8583OT_02_04.jpg)

IP-TCP 扫描器

该类将范围作为输入，并调用`run1()`函数。`section 4`部分创建一个线程，它是一个类的实例，占用一个较短的范围，并调用`run1()`函数。`run1()`函数有一个 IP 地址，从线程获取范围，并生成输出。

`iptcpscan.py`程序的输出如下：

```
G:\Project Snake\Chapter 2\ip>python iptcpscan_t.py
Enter the Network Address 10.0.0.1
Enter the starting Number  1
Enter the last Number 60
 Number of Threads active: 4
Exiting Main Thread
10.0.0.5 -->Live
10.0.0.13 -->Live
scanning complete in  0:00:20.018000

```

对于 20 秒内 60 个 IP，性能还不错。作为练习，将两个扫描仪合并为一个扫描仪。**  **# 目标机器上运行哪些服务？

现在，您已经熟悉了如何扫描 IP 地址并识别子网中的活动主机。在本节中，我们将讨论在主机上运行的服务。这些服务是使用网络连接的服务。使用网络连接的服务必须打开一个端口；通过端口号，我们可以识别目标机器上正在运行的服务。在 pentesting 中，端口扫描的意义在于检查主机上是否运行任何非法服务。

考虑用户通常使用他们的计算机下载游戏的情况，并且在安装游戏期间识别木马。特洛伊木马进入隐藏模式并打开一个端口，将所有击键日志信息发送给黑客。在这种情况下，端口扫描有助于识别受害者计算机上运行的未知服务。

端口号范围从 0 到 65536。众所周知的端口（也称为系统端口）是那些范围从 0 到 1023 的端口，它们是为特权服务保留的。从 1024 到 49151 的端口范围是用于应用程序的注册端口类供应商；例如，端口 3306 是为 MySQL 保留的。

## 端口扫描仪的概念

TCP 的三向握手作为端口扫描器的逻辑；在 TCP/IP 扫描程序中，您已经看到端口（137 或 135）的 IP 地址在一定范围内。但是，在端口扫描程序中，IP 只是一个范围内的一个端口。取一个 IP，按用户给定的范围尝试连接每个端口；如果连接成功，端口将打开；否则，端口将保持关闭状态。

我编写了一个非常简单的端口扫描代码：

```
import socket, subprocess,sys
from datetime import datetime

subprocess.call('clear',shell=True)
rmip = raw_input("\t Enter the remote host IP to scan:")
r1 = int(raw_input("\t Enter the start port number\t"))
r2 = int (raw_input("\t Enter the last port number\t"))
print "*"*40
print "\n Mohit's Scanner is working on ",rmip
print "*"*40

t1= datetime.now()
try:
  for port in range(r1,r2):
    sock= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    socket.setdefaulttimeout(1)

    result = sock.connect_ex((rmip,port))
    if result==0:
      print "Port Open:-->\t", port
      # print desc[port]
    sock.close()

except KeyboardInterrupt:
  print "You stop this "
  sys.exit()

except socket.gaierror:
  print "Hostname could not be resolved"
  sys.exit()

except socket.error:
  print "could not connect to server"
  sys.exit()

t2= datetime.now()

total =t2-t1
print "scanning complete in " , total
```

主逻辑已写入`try`块中，表示汽车的发动机。您熟悉的语法。让我们对输出进行 R&D。

`portsc.py`程序的输出如下：

```
root@Mohit|Raj:/port#python portsc.py 
 Enter the remote host IP to scan:192.168.0.3
 Enter the start port number	1
 Enter the last port number	4000
****************************************

 Mohit's Scanner is working on  192.168.0.3
****************************************
Port Open:-->	22
Port Open:-->	80
Port Open:-->	111
Port Open:-->	443
Port Open:-->	924
Port Open:-->	3306
scanning complete in  0:00:00.766535

```

前面的输出显示端口扫描仪在 0.7 秒内扫描了 1000 个端口；连接已满，因为目标机器和扫描机器在同一子网中。

让我们讨论另一个输出：

```
 Enter the remote host IP to scan:10.0.0.1
 Enter the start port number	1
 Enter the last port number	4000
****************************************

Mohit's Scanner is working on  10.0.0.1
****************************************
Port Open:-->  23
Port Open:-->  53
Port Open:-->  80
Port Open:-->  1780
scanning complete in  1:06:43.272751

```

现在，让我们分析输出；要扫描 4000 个端口，扫描仪需要 1:06:43.272751 小时，扫描需要很多时间。拓扑结构是：

192.168.0.10 --> 192.168.0.1 --> 10.0.0.16 ---> 10.0.0.1

`192.168.0.1`和`10.0.0.16`IP 是网关接口。我们在`socket.setdefaulttimeout(1)`中放置了 1 秒，这意味着扫描器在每个端口上最多花费 1 秒。总共 4000 个端口意味着如果所有端口都关闭，则所需的总时间将为 4000 秒；如果我们把它转换成小时，它将变成 1.07 小时，这几乎等于我们程序的输出。如果我们设置`socket.setdefaulttimeout(.5)`，所需的时间将减少到 30 分钟，但仍然需要很长时间。没有人会使用我们的扫描仪。对于 4000 个端口，所用时间应少于 100 秒。

## 如何创建高效的端口扫描仪

我已经说明了良好端口扫描仪应考虑的一些点：

*   多线程应该用于高性能
*   `socket.setdefaulttimeout(1)`方式应根据情况设置
*   端口扫描程序应该能够获取主机名和域名
*   端口应提供带有端口号的服务名称
*   端口扫描应考虑总时间
*   要扫描端口 0 到 65536，所需时间应为 3 分钟左右

现在，我已经编写了我的端口扫描仪，通常用于端口扫描：

```
import threading
import time
import socket, subprocess,sys
from datetime import datetime
import thread
import shelve

'''section 1 '''
subprocess.call('clear',shell=True)
shelf = shelve.open("mohit.raj")
data=(shelf['desc'])

'''section 2 '''
class myThread (threading.Thread):
  def __init__(self, threadName,rmip,r1,r2,c):
    threading.Thread.__init__(self)
    self.threadName = threadName
    self.rmip = rmip
    self.r1 = r1
    self.r2 = r2
    self.c =c
  def run(self):
    scantcp(self.threadName,self.rmip,self.r1,self.r2,self.c)

'''section 3 '''
def scantcp(threadName,rmip,r1,r2,c):
  try:
    for port in range(r1,r2):
      sock= socket.socket(socket.AF_INET,socket.SOCK_STREAM)
      #sock= socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
      socket.setdefaulttimeout(c)
      result = sock.connect_ex((rmip,port))

      if result==0:
        print "Port Open:---->\t", port,"--", data.get(port, "Not in Database")
        sock.close()

    except KeyboardInterrupt:
      print "You stop this "
      sys.exit()

    except socket.gaierror:
      print "Hostname could not be resolved"
      sys.exit()

    except socket.error:
      print "could not connect to server"
      sys.exit()

    shelf.close()
'''section 4 '''
print "*"*60
print " \tWelcome this is the Port scanner of Mohit\n  "

d=raw_input("\ t Press D for Domain Name or Press I for IP Address\t")   

if (d=='D' or d=='d'):
  rmserver = raw_input("\t Enter the Domain Name to scan:\t")
  rmip = socket.gethostbyname(rmserver)
elif(d=='I' or d=='i'):
  rmip = raw_input("\t Enter the IP Address  to scan:  ")

else:
  print "Wrong input"
#rmip = socket.gethostbyname(rmserver)
r11 = int(raw_input("\t Enter the start port number\t"))
r21 = int (raw_input("\t Enter the last port number\t"))

conect=raw_input("For low connectivity press L and High connectivity Press H\t")

if (conect=='L' or conect=='l'):
  c =1.5

elif(conect =='H' or conect=='h'):
  c=0.5

else:
  print "\t wrong Input"

print "\n Mohit's Scanner is working on ",rmip
print "*"*60
t1= datetime.now()
tp=r21-r11

tn =30
# tn number of port handled by one thread
tnum=tp/tn       # tnum number of threads
if (tp%tn != 0):
  tnum= tnum+1

if (tnum > 300):
  tn = tp/300
  tn= tn+1
  tnum=tp/tn
  if (tp%tn != 0):
    tnum= tnum+1

'''section  5'''
threads= []

try:
  for i in range(tnum):
    #print "i is ",i
    k=i
    r2=r11+tn 
    # thread=str(i)
    thread = myThread("T1",rmip,r11,r2,c)
    thread.start()
  threads.append(thread)
  r11=r2

except:
  print "Error: unable to start thread"

print "\t Number of Threads active:", threading.activeCount()

for t in threads:
  t.join()
print "Exiting Main Thread"
t2= datetime.now()

total =t2-t1
print "scanning complete in " , total
```

不要害怕看到完整的代码；我花了两个星期。我将向您解释完整的代码部分。在`section1`中，`subprocess.call('clear',shell=True)`语句在 Linux 中用于清除屏幕。接下来的两行与存储端口信息的数据库文件相关，将在创建数据库文件时对其进行解释。在`section 2`中，`myThread`类扩展了线程类，或者可以说继承了线程类。在下一行，`def __init__(self, threadName,rmip,r1,r2,c):`语句取 5 个值；第一个是`threadName`，存储线程名称；实际上，我把它用于调试目的。如果任何线程无法工作，我们可以打印线程名称。`rmip`参数是一个远程 IP 地址；`r1`和`r2`为第一个和最后一个端口号，`c`为连接方式；`section 4`向`section 1`提供所有值。从`run()`函数调用`scantcp()`函数。`Section 3`是汽车的发动机，在端口扫描仪部分的*概念中有解释。`data.get(port, "Not in Database")`陈述在这里是新的；这意味着如果在字典数据库中找到端口键，那么它将显示该值；否则将打印`Not in Database`。`Section 4`与用户交互。您可以提供主机名和 IP 地址，也可以提供域名；`if…else`语句完成此任务。`r11`和`r21`变量存储第一个和最后一个端口号。接下来的`if…else`语句定义了`c`的值，如果您认为与目标机的连通性差，但没有丢包，则可以按*H*；如果连接良好，则可以按*L*。`tn=30`变量定义单个线程处理的端口数。`tnum`变量计算完成任务所需的线程总数。*

在进行了大量实验后，我编写了以下代码：

```
if (tnum > 300):
  tn = tp/300
  tn= tn+1
  tnum=tp/tn
  if (tp%tn != 0):
    tnum= tnum+1
```

当线程总数超过 300 时，线程将无法工作。这意味着线程数必须小于或等于 300。前面的代码定义了`tn`和`tnum`的新值。在`Section 5`中，没有什么是新的，因为您以前在 IP 扫描仪中看到过一切。

现在是时候查看`portsc14.py`程序的输出了：

```
root@Mohit|Raj:/port# python portsc14.py 

************************************************************
 Welcome this is the Port scanner of Mohit

 Press D for Domain Name or Press I for IP Address	i
 Enter the IP Address  to scan:  10.0.0.1
 Enter the start port number	1
 Enter the last port number	4000
For low connectivity press L and High connectivity Press H	l

Mohit's Scanner is working on 10.0.0.1
************************************************************
 Number of Threads active: 135
Port Open:---->	1780 -- Not in Database
Port Open:---->	80 -- HTTP
Port Open:---->	23 -- Telnet
Port Open:---->	53 -- DNS
Exiting Main Thread
scanning complete in  0:00:33.249338

```

我们的高效端口扫描仪的输出与之前的简单扫描仪相同，但从性能角度来看，存在巨大差异。一个简单的扫描仪花费的时间是 1:06:43.272751，但是新的多线程扫描仪只花费了 33 秒。它还显示服务名称。让我们检查端口 1 到 50000 的另一个输出：

```
root@Mohit|Raj:/port# python portsc14.py 

************************************************************
 Welcome this is the Port scanner of Mohit

 Press D for Domain Name or Press I for IP Address	i 
 Enter the IP Address  to scan:  10.0.0.1
 Enter the start port number	1
 Enter the last port number	50000
For low connectivity press L and High connectivity Press H	l

Mohit's Scanner is working on  10.0.0.1
************************************************************
 Number of Threads active: 301
Port Open:---->	23 -- Telnet
Port Open:---->	53 -- DNS
Port Open:---->	80 -- HTTP
Port Open:---->	1780 -- Not in Database
Port Open:---->	5000 -- Not in Database
Exiting Main Thread
scanning complete in  0:02:54.283984

```

所用时间为 2 分 54 秒；我在 high connectivity 中做了同样的实验，实验时间为 0:01:23.819774，几乎是前一次的一半。

### 注

在多线程实验中，如果我们产生`tn`个线程，那么`threading.activeCount()`总是显示`tn+1`个线程，因为它也计算主线程。主线程是运行所有线程的线程。作为练习，在 simple scanner 程序中使用`threading.activeCount()`方法，然后检查输出。

现在，我将教你如何创建一个包含所有端口号描述的数据库文件；代码如下：

```
import shelve
def create():
  shelf = shelve.open("mohit.raj", writeback=True)
  shelf['desc'] ={}
  shelf.close()
  print "Dictionary is created"

def update():
  shelf = shelve.open("mohit.raj", writeback=True)
  data=(shelf['desc'])
  port =int(raw_input("Enter the Port: "))
  data[port]= raw_input("\n Enter the  description\t")
  shelf.close()

def del1():
  shelf = shelve.open("mohit.raj", writeback=True)
  data=(shelf['desc'])
  port =int(raw_input("Enter the Port: "))
  del data[port]
  shelf.close()
  print "\n Entry is deleted"

def list1():
  print "*"*30
  shelf = shelve.open("mohit.raj", writeback=True)
  data=(shelf['desc'])
  for key, value in data.items():
    print key, ":", value
    print "*"*30
    print "\t Program to update or Add and Delete the port number detail\n"
  while(True):
    print "Press" 
    print "C for create only one time create"
    print "U for Update or Add \nD for delete"
    print "L for list the all values  "
    print "E for Exit  "
    c=raw_input("Enter :  ")

  if (c=='C' or c=='c'):
    create()

  elif (c=='U' or c=='u'):
    update()

  elif(c=='D' or c=='d'):
    del1()

  elif(c=='L' or c=='l'):
    list1()

  elif(c=='E' or c=='e'):
    exit()

  else:
    print "\t Wrong Input"
```

在前面的程序中，我们只存储了一个字典，其中包含作为端口号的键和作为端口号描述的值。词典名称为`desc`。所以我做了一个`desc`书架的钥匙，储存在一个名为`mohit.raj`的文件中。

```
def create():
  shelf = shelve.open("mohit.raj", writeback=True)
  shelf['desc'] ={}
  shelf.close()
```

这个`create()`函数只是一个空字典。`desc`字典是程序中的字典，而`shelf['desc']`是文件中的字典。仅使用此函数一次即可创建文件。

```
def update():
  shelf = shelve.open("mohit.raj", writeback=True)
  data=(shelf['desc'])
  port =int(raw_input("Enter the Port: "))
  data[port]= raw_input("\n Enter the  description\t")
  shelf.close()
```

此`update()`功能更新字典。在`writeback=True`语句**中`writeback`标志架会记住从文件中接收到的所有值，并且当前缓存中的每个值都会写回文件。`data=(shelf['desc'])`字典是货架字典，已分配给变量数据。`del()`功能从字典中删除任何端口号。`list1()`函数显示完整字典。为此，使用`for`循环。**

 **`updatec.py`程序的输出如下：

```
G:\Project Snake\Chapter 2>python updatec.py
 Program to update or Add and Delete the port number detail

Press
C for create only one time create
U for Update or Add
D for delete
L for list the all values
E for Exit
Enter :  c
Dictionary is created
Press
C for create only one time create
U for Update or Add
D for delete
L for list the all values
E for Exit
Enter :  u
Enter the Port: 80

 Enter the  description HTTP
Press
C for create only one time create
U for Update or Add
D for delete
L for list the all values
E for Exit
Enter :  l
******************************
80 : HTTP
******************************
Press
C for create only one time create
U for Update or Add
D for delete
L for list the all values
E for Exit
Enter :  e

G:\Project Snake\Chapter 2>

```

我希望您对端口扫描仪有一个大致的了解；简而言之，端口扫描器包括三个文件，第一个文件是扫描器（`portsc14.py`），第二个文件是数据库（`mohit.raj`），第三个文件是`updatec.py`。您只需升级`mohit.raj`文件以插入最大端口数的说明。**  **# 总结

完成网络扫描以收集有关网络、主机和主机上运行的服务的信息。通过操作系统的`ping`命令进行网络扫描；ping 扫描利用 ping 功能扫描 IP 列表。有时，ping-sweep 不起作用，因为用户可能会关闭其 ICMP 回显回复功能或使用防火墙阻止 ICMP 数据包。在这种情况下，ping 扫描扫描仪可能无法工作。在这种情况下，我们必须利用 TCP 三方握手；TCP 在传输层工作，因此我们必须选择要在其上执行 TCP 连接扫描的端口号。Windows 操作系统的某些端口始终处于打开状态。因此，您可以利用这些开放端口。第一个主要部分专门用于网络扫描；当您执行网络扫描时，您的程序应该具有最大的性能并占用最少的时间。为了显著提高性能，应该使用多线程。

扫描活动主机后，端口扫描用于检查特定主机上运行的服务；有时，一些程序使用允许木马的互联网连接；端口扫描可以检测这些类型的威胁。为了进行有效的端口扫描，多线程起着至关重要的作用，因为端口号范围从 0 到 65536。要扫描一个巨大的列表，必须使用多线程。

在下一章中，您将看到嗅探及其两种类型：被动嗅探和主动嗅探。您还将学习如何捕获数据、数据包制作的概念以及使用 scapy 库制作定制数据包。****