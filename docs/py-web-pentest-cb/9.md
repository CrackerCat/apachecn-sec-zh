# 九、报告

在本章中，我们将介绍以下主题：

*   将 Nmap XML 转换为 CSV
*   从 URL 中提取链接到
*   将电子邮件提取到 Maltego
*   将 Sslscan 解析为 CSV
*   使用`plot.ly`生成图形

# 导言

我们在本书中提供了执行 web 应用程序测试各个方面的方法。所以，我们得到了所有这些信息。我们已经从我们的食谱中获得了控制台输出，但是我们如何将所有这些收集成有用的格式呢？理想情况下，我们希望输出的格式可以使用。或者，我们可能希望将另一个应用程序（如 Nmap）的输出转换为我们正在使用的格式。它可以是**逗号分隔变量**（**CSV**），也可以是 Maltego 转换，或者您想要使用的任何其他格式。

你刚才提到的这件事是什么？我听到你问。Maltego 是一款**开源智能****OSIT**和取证应用软件。它有一个漂亮的 GUI，可以帮助您以一种漂亮、容易理解的方式可视化信息。

# 将 Nmap XML 转换为 CSV

Nmap 是在 web 应用程序测试的侦察阶段使用的通用工具。它通常用于扫描具有多种选项的端口，以帮助您根据自己的喜好定制扫描。例如，您想使用 TCP 还是 UDP？您要设置什么 TCP 标志？是否有您想要运行的特定 Nmap 脚本，例如检查**网络时间协议**（**NTP**）反射，但要在非默认端口上运行？这个清单可能是无穷无尽的。

Nmap 输出易于阅读，但不易于以编程方式使用。这个简单的方法将从 Nmap 转换 XML 输出（通过运行 Nmap 扫描时使用–oX 标志），并将其转换为 CSV 输出。

## 准备好了吗

虽然这个配方的实现非常简单，但您需要安装 Python 的`nmap`模块。您可以使用`pip`或从源文件构建它。您还需要 Nmap 扫描的 XML 输出。您可以通过扫描您选择的易受攻击的虚拟机或您有权在其上运行扫描的站点来实现此目的。您可以按原样使用 Nmap，也可以在 Python 脚本中使用 Python 的`nmap`模块来实现这一点。

## 怎么做…

就像我前面提到的，这个食谱很简单。这主要是因为`nmap`图书馆为我们做了大部分艰苦的工作。

下面是我们将用于此任务的脚本：

```py
import sys
import os
import nmap

nm=nmap.Portscanner()
with open(“./nmap_output.xml”, “r”) as fd:
    content = fd.read()
    nm.analyse_nmap_xml_scan(content)
    print(nm.csv())
```

## 它是如何工作的…

因此，在导入必要的模块之后，我们必须初始化 Nmap 的`Portscanner`函数。虽然我们不会在此配方中进行任何端口扫描，但这是允许我们使用对象中的方法所必需的：

```py
nm=nmap.Portscanner()
```

然后，我们有一个`with`声明。那是什么？以前，当您在 Python 中打开文件时，必须记住在完成后关闭它。在这种情况下，`with`语句将在执行完其中的所有代码后为您执行此操作。如果您没有很好的内存，并且总是忘记关闭代码中的文件，那就太好了：

```py
with open(“./nmap_output.xml”, “r”) as fd:
```

在`with`语句之后，我们将文件的内容读入一个`content`变量（我们可以随意调用这个变量，但为什么会使事情过于复杂？）

```py
    content = fd.read()
```

使用我们之前创建的`Portscanner`对象，我们现在可以使用一种方法分析内容，该方法将解析我们提供的 XML 输出，然后我们可以将其打印为 CSV：

```py
nm.analyse_nmap_xml_scan(content)
    print(nm.csv())
```

# 从 URL 提取指向 Maltego 的链接

本书中还有一个配方，说明了如何使用`BeautifulSoup`库以编程方式获取域名。此配方将向您展示如何创建局部 Maltego 变换，然后您可以在 Maltego 内部使用该变换，以易于使用的图形方式生成信息。通过此转换收集的链接，还可以将其用作更大的爬行或爬行解决方案的一部分。

## 怎么做…

下面的代码显示了如何创建一个脚本，该脚本将枚举的信息输出为 Maltego 的正确格式：

```py
import urllib2
from bs4 import BeautifulSoup
import sys

tarurl = sys.argv[1]
if tarurl[-1] == “/”:
  tarurl = tarurl[:-1]
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”

url = urllib2.urlopen(tarurl).read()
soup = BeautifulSoup(url)
for line in soup.find_all(‘a’):
  newline = line.get(‘href’)
  if newline[:4] == “http”:
    print”<Entity Type=\”maltego.Domain\”>” 
    print”<Value>”+str(newline)+”</Value>”
    print”</Entity>”
  elif newline[:1] == “/”:
    combline = tarurl+newline
    print”<Entity Type=\”maltego.Domain\”>” 
    print”<Value>”+str(combline)+”</Value>”
    print”</Entity>”
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 它是如何工作的…

首先我们导入此配方所需的所有模块。您可能已经注意到，对于`BeautifulSoup`，我们有以下行：

```py
from bs4 import BeautifulSoup
```

因此，当我们使用`BeautifulSoup`时，我们只需键入`BeautifulSoup`而不是`bs4.BeautifulSoup`。

然后，我们将参数中提供的目标 URL 分配到一个变量中：

```py
tarurl = sys.argv[1]
```

完成后，我们检查目标 URL 是否以`/`结尾。如果是，那么我们通过将`tarurl`变量替换为`tarurl`的最后一个字符以外的所有字符来删除最后一个字符，以便以后在完全输出相对链接时可以在配方中使用它：

```py
if tarurl[-1] == “/”:
  tarurl = tarurl[:-1]
```

然后，我们打印出构成 Maltego 转换响应一部分的标签：

```py
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
```

然后我们用`urllib2`打开目标`url`并将其存储在`BeautifulSoup`中：

```py
url = urllib2.urlopen(tarurl).read()
soup = BeautifulSoup(url)
```

我们现在使用“汤”查找所有`<a>`标签。更具体地说，我们将寻找带有超文本引用（链接）的`<a>`标记：

```py
for line in soup.find_all(‘a’):
  newline = line.get(‘href’)
```

如果链接的前四个字符为`http`，我们将其输出为正确的格式，作为 Maltego 的实体：

```py
if newline[:4] == “http”:
    print”<Entity Type=\”maltego.Domain\”>”
    print”<Value>”+str(newline)+”</Value>”
    print”</Entity>”
```

如果第一个字符是`/`，表示该链接是一个相对链接，那么我们将在为该链接添加目标 URL 后，将其输出为正确的格式。虽然此配方显示了如何处理相对链接的一个示例，但需要注意的是，还有其他类型的相对链接，如文件名（`example.php`）、目录以及相对路径点符号（`../../example.php`），如下所示：

```py
elif newline[:1] == “/”:
    combline = tarurl+newline
    if 
    print”<Entity Type=\”maltego.Domain\”>”
    print”<Value>”+str(combline)+”</Value>”
    print”</Entity>”
```

处理完页面上的所有链接后，关闭在输出开始时打开的所有标记：

```py
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 还有更多…

`BeautifulSoup`库包含其他可以使代码更简单的函数。其中一个函数称为**SoupStrainer**。SoupStrainer 将允许您只解析文档中所需的部分。我们将此作为练习留给您进行探索。

# 提取发送给 Maltego 的电子邮件

本书中还有另一个食谱，说明了如何从网站中提取电子邮件。本食谱将向您展示如何创建本地 Maltego 转换，然后您可以在 Maltego 自身中使用该转换生成信息。它可以与 URL 爬行转换结合使用，从整个网站中提取电子邮件。

## 怎么做…

以下代码显示了如何通过使用正则表达式从网站提取电子邮件：

```py
import urllib2
import re
import sys

tarurl = sys.argv[1]
url = urllib2.urlopen(tarurl).read()
regex = re.compile((“([a-z0-9!#$%&’*+\/=?^_`{|}~- ]+(?:\.[*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&’*+\/=?^_`” “{|}~- ]+)*(@|\sat\s)(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?(\.|” “\ sdot\s))+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)”))

print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
emails = re.findall(regex, url)
for email in emails:
  print”    <Entity Type=\”maltego.EmailAddress\”>”
  print”      <Value>”+str(email[0])+”</Value>”
  print”    </Entity>”
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

## 它是如何工作的…

脚本顶部导入必要的模块。然后，我们将作为参数提供的 URL 分配给变量，并使用`urllib2`打开`url`列表：

```py
tarurl = sys.argv[1]
url = urllib2.urlopen(tarurl).read()
```

然后，我们创建一个与标准电子邮件地址格式匹配的正则表达式：

```py
regex = re.compile((“([a-z0-9!#$%&’*+\/=?^_`{|}~-]+(?:\.[a-z0- 9!#$%&’*+\/=?^_`” “{|}~-]+)*(@|\sat\s)(?:[a-z0-9](?:[a-z0-9- ]*[a-z0-9])?(\.|” “\sdot\s))+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?)”))
```

前面的正则表达式应与格式为`email@address.com`的电子邮件地址或地址为.com 的电子邮件地址相匹配。

然后我们输出有效 Maltego 变换输出所需的标签：

```py
print”<MaltegoMessage>”
print”<MaltegoTransformResponseMessage>”
print”  <Entities>”
```

然后，我们在`url`内容中找到与正则表达式匹配的所有文本实例：

```py
emails = re.findall(regex, url)
```

然后，我们获取找到的每个电子邮件地址，并将其以正确的格式输出，以进行 Maltego 转换响应：

```py
for email in emails:
  print”    <Entity Type=\”maltego.EmailAddress\”>”
  print”      <Value>”+str(email[0])+”</Value>”
  print”    </Entity>”
```

然后关闭之前打开的打开标签：

```py
print”  </Entities>”
print”</MaltegoTransformResponseMessage>”
print”</MaltegoMessage>”
```

# 将 Sslscan 解析为 CSV

Sslscan 是一个用于枚举 HTTPS 站点支持的密码的工具。了解站点支持的密码在 web 应用程序测试中很有用。如果某些支持的密码较弱，则这在渗透测试中更有用。

## 怎么做…

此配方将在指定的 IP 地址上运行 Sslscan，并将结果输出为 CSV 格式：

```py
import subprocess
import sys

ipfile = sys.argv[1]

IPs = open(ipfile, “r”)
output = open(“sslscan.csv”, “w+”)

for IP in IPs:
  try:
    command = “sslscan “+IP

    ciphers = subprocess.check_output(command.split())

    for line in ciphers.splitlines():
      if “Accepted” in line:
        output.write(IP+”,”+line.split()[1]+”,”+ line.split()[4]+”,”+line.split()[2]+”\r”)
  except:
    pass
```

## 它是如何工作的…

我们首先导入必要的模块，并将参数中提供的文件名分配给一个变量：

```py
import subprocess
import sys

ipfile = sys.argv[1]
```

提供的文件名应指向包含 IP 地址列表的文件。我们以只读方式打开此文件：

```py
IPs = open(ipfile, “r”)
```

然后用`w+`代替`r`打开文件进行读写输出：

```py
output = open(“sslscan.csv”, “w+”)
```

现在既然我们有了我们的输入和输出，我们就可以开始了。我们首先遍历 IP 地址：

```py
for IP in IPs:
```

对于每个 IP，我们运行 Sslscan：

```py
  try:
    command = “sslscan “+IP
```

然后，我们将命令的输出分为多个块：

```py
    ciphers = subprocess.check_output(command.split())
```

然后我们逐行检查输出。如果该行包含单词`Accepted`，则我们安排该行的元素进行 CSV 输出：

```py
    for line in ciphers.splitlines():
      if “Accepted” in line:
        output.write(IP+”,”+line.split()[1]+”,”+ line.split()[4]+”,”+line.split()[2]+”\r”)
```

最后，如果出于任何原因，尝试在 IP 上运行 SSL 扫描失败，我们只需转到下一个 IP 地址：

```py
  except:
  pass
```

# 使用 plot.ly 生成图形

有时候拥有数据的可视表示真的很好。在这个配方中，我们将使用`plot.ly`python API 生成一个漂亮的图形。

## 准备好了吗

在这个配方中，我们将使用`plot.ly`API 生成图形。如果您还没有账户，您需要在[注册一个账户 https://plot.ly](https://plot.ly) 。

一旦您拥有一个帐户，您将需要准备好使用`plot.ly`的环境。

最简单的方法是使用`pip`安装，所以只需运行以下命令：

```py
$ pip install plotly

```

然后，您需要运行以下命令（用您自己的命令替换`{username}`、`{apikey}`和`{streamids}`，这些命令可以在`plot.ly`站点上的您的帐户订阅下查看）：

```py
python -c “import plotly;  plotly.tools.set_credentials_file(username=’{username}’,  api_key=’{apikey}’, stream_ids=[{streamids}])”

```

如果您遵循这个示例，那么我使用了在线提供的用于测试的`pcap`文件：[http://www.snaketrap.co.uk/pcaps/hbot.pcap](http://www.snaketrap.co.uk/pcaps/hbot.pcap) 。

我们将枚举`pcap`文件中的所有 FTP 数据包，并根据时间绘制它们。

为了解析`pcap`文件，我们将使用`dpkt`模块。与早期配方中使用的`Scapy`类似，`dpkt`也可用于解析和操作数据包。

最简单的方法是使用`pip`安装。只需运行以下命令：

```py
$ pip install dpkt

```

## 怎么做…

此配方将读取一个`pcap`文件，并提取任何 FTP 数据包的日期和时间，然后将此数据绘制成图形：

```py
import time, dpkt
import plotly.plotly as py
from plotly.graph_objs import *
from datetime import datetime

filename = ‘hbot.pcap’

full_datetime_list = []
dates = []

for ts, pkt in dpkt.pcap.Reader(open(filename,’rb’)):
    eth=dpkt.ethernet.Ethernet(pkt) 
    if eth.type!=dpkt.ethernet.ETH_TYPE_IP:
        continue

    ip = eth.data
    tcp=ip.data

    if ip.p not in (dpkt.ip.IP_PROTO_TCP, dpkt.ip.IP_PROTO_UDP):
        continue

    if tcp.dport == 21 or tcp.sport == 21:
        full_datetime_list.append((ts, str(time.ctime(ts))))

for t,d in full_datetime_list:
    if d not in dates:
        dates.append(d)

dates.sort(key=lambda date: datetime.strptime(date, “%a %b %d %H:%M:%S %Y”))

datecount = []

for d in dates:
    counter = 0
    for d1 in full_datetime_list:
        if d1[1] == d:
            counter += 1

    datecount.append(counter)

data = Data([
    Scatter(
        x=dates,
        y=datecount
    )
])
plot_url = py.plot(data, filename=’FTP Requests’)
```

## 它是如何工作的…

我们首先导入必要的模块，并将`pcap`文件的文件名分配给一个变量：

```py
import time, dpkt
import plotly.plotly as py
from plotly.graph_objs import *
from datetime import datetime

filename = ‘hbot.pcap’
```

接下来，我们设置我们的列表，当我们迭代我们的`pcap`文件时，我们将填充这些列表。`Full_datetime_list`变量将保存所有 FTP 数据包日期，而`dates`将用于保存完整列表中唯一的`datetime`：

```py
full_datetime_list = []
dates = []
```

然后我们打开`pcap`文件进行读取，并在`for`循环中对其进行迭代。本节检查数据包是否为 FTP 数据包，如果是，则将时间附加到我们的阵列：

```py
for ts, pkt in dpkt.pcap.Reader(open(filename,’rb’)):
    eth=dpkt.ethernet.Ethernet(pkt) 
    if eth.type!=dpkt.ethernet.ETH_TYPE_IP:
        continue

    ip = eth.data
    tcp=ip.data

    if ip.p not in (dpkt.ip.IP_PROTO_TCP, dpkt.ip.IP_PROTO_UDP):
        continue

    if tcp.dport == 21 or tcp.sport == 21:
        full_datetime_list.append((ts, str(time.ctime(ts))))
```

现在我们有了 FTP 流量的`datetime`函数列表，我们可以从中获得唯一的`datetime`函数并填充我们的`dates`数组：

```py
for t,d in full_datetime_list:
    if d not in dates:
        dates.append(d)
```

然后，我们对日期进行排序，使其在图表上按顺序排列：

```py
dates.sort(key=lambda date: datetime.strptime(date, “%a %b %d H:%M:%S %Y”))
```

然后，我们只需迭代唯一的日期，并计算在此期间从较大的数组发送/接收的所有数据包，然后填充计数器数组：

```py
datecount = []

for d in dates:
    counter = 0
    for d1 in full_datetime_list:
        if d1[1] == d:
            counter += 1

    datecount.append(counter)
```

只需使用我们的日期数组对`plot.ly`进行 API 调用，并将数组作为数据点进行计数：

```py
data = Data([
    Scatter(
        x=dates,
        y=datecount
    )
])
plot_url = py.plot(data, filename=’FTP Requests’)
```

当您运行脚本时，它会弹出浏览器，打开您新创建的`plot.ly`图形，如下所示：

![How it works…](img/B04044_09_01.jpg)

这就是全部。`plot.ly`有很多不同的方法来可视化您的数据，值得一试。想想当你的老板看到你开始发送的所有漂亮图表时，他们会给你留下多么深刻的印象。